/*
Copyright 2022 Huawei Cloud Computing Technologies Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
package executor

import (
	"bytes"
	"container/heap"
	"sort"

	"github.com/openGemini/openGemini/engine/hybridqp"
	"github.com/openGemini/openGemini/lib/rand"
	"github.com/openGemini/openGemini/lib/record"
	"github.com/openGemini/openGemini/open_src/influx/query"
)

{{range .}}
{{- if ne .Name "String"}}
type {{.Name}}Point struct {
	time  int64
	value {{.Type}}
	index int
	isNil bool
}

func new{{.Name}}Point() *{{.Name}}Point {
	return &{{.Name}}Point{isNil: true}
}

func (p *{{.Name}}Point) Set(index int, time int64, value {{.Type}}) {
	p.index = index
	p.time = time
	p.value = value
	p.isNil = false
}

func (p *{{.Name}}Point) Reset() {
	p.isNil = true
}

func (p *{{.Name}}Point) Assign(c *{{.Name}}Point) {
	p.index = c.index
	p.time = c.time
	p.value = c.value
}
{{- end}}
{{end}}

type StringPoint struct {
	time  int64
	value []byte
	index int
	isNil bool
}

func newStringPoint() *StringPoint {
	return &StringPoint{isNil: true}
}

func (p *StringPoint) Set(index int, time int64, value string) {
	p.index = index
	p.time = time
	p.isNil = false
	valueByte := record.Str2bytes(value)
	if cap(p.value) >= len(valueByte) {
		p.value = p.value[:len(valueByte)]
		copy(p.value, valueByte)
	} else {
		p.value = make([]byte, len(valueByte))
		copy(p.value, valueByte)
	}
}

func (p *StringPoint) Reset() {
	p.isNil = true
	p.value = p.value[:0]
}

func (p *StringPoint) Assign(c *StringPoint) {
	p.index = c.index
	p.time = c.time
	p.value = p.value[:0]
	if cap(p.value) >= len(c.value) {
		p.value = p.value[:len(c.value)]
		copy(p.value, c.value)
	} else {
		p.value = make([]byte, len(c.value))
		copy(p.value, c.value)
	}
}

{{with $types := .}}
{{range $k := $types}}
{{- if eq $k.Name "Float"}}
{{range $v := $types}}
{{- if or (eq $v.Name "Integer") (eq $v.Name "Float")}}
type {{$k.Name}}Col{{$v.Name}}Reduce func(c Chunk, ordinal, start, end int) (index int, value {{$v.Type}}, isNil bool)

type {{$k.Name}}Col{{$v.Name}}Merge func(prevPoint, currPoint *{{$v.Name}}Point)

type {{$k.Name}}Col{{$v.Name}}Iterator struct {
	isSingleCall bool
	inOrdinal    int
	outOrdinal   int
	prevPoint   *{{$v.Name}}Point
	currPoint   *{{$v.Name}}Point
	fn           {{$k.Name}}Col{{$v.Name}}Reduce
	fv           {{$k.Name}}Col{{$v.Name}}Merge
	auxChunk     Chunk
	auxProcessor []*AuxProcessor
}

func New{{$k.Name}}Col{{$v.Name}}Iterator(fn {{$k.Name}}Col{{$v.Name}}Reduce, fv {{$k.Name}}Col{{$v.Name}}Merge,
    isSingleCall bool, inOrdinal, outOrdinal int, auxProcessor []*AuxProcessor, rowDataType hybridqp.RowDataType,
) *{{$k.Name}}Col{{$v.Name}}Iterator {
	r := &{{$k.Name}}Col{{$v.Name}}Iterator{
		fn:           fn,
		fv:           fv,
		isSingleCall: isSingleCall,
		inOrdinal:    inOrdinal,
		outOrdinal:   outOrdinal,
		prevPoint:    new{{$v.Name}}Point(),
		currPoint:    new{{$v.Name}}Point(),
	}
	if isSingleCall && len(auxProcessor) > 0 {
		r.auxProcessor = auxProcessor
		r.auxChunk = NewChunkBuilder(rowDataType).NewChunk("")
	}
	return r
}

func (r *{{$k.Name}}Col{{$v.Name}}Iterator) appendInAuxCol(
    inChunk, outChunk Chunk, index int,
) {
	for j := range r.auxProcessor {
		r.auxProcessor[j].auxHelperFunc(
			inChunk.Column(r.auxProcessor[j].inOrdinal),
			outChunk.Column(r.auxProcessor[j].outOrdinal),
			index,
		)
	}
}

func (r *{{$k.Name}}Col{{$v.Name}}Iterator) appendOutAuxCol(
    inChunk, outChunk Chunk, index int,
) {
	for j := range r.auxProcessor {
		r.auxProcessor[j].auxHelperFunc(
			inChunk.Column(r.auxProcessor[j].outOrdinal),
			outChunk.Column(r.auxProcessor[j].outOrdinal),
			index,
		)
	}
}

func (r *{{$k.Name}}Col{{$v.Name}}Iterator) mergePrevItem(
    inChunk, outChunk Chunk,
) {
	if r.isSingleCall {
		outChunk.AppendTime(r.prevPoint.time)
		outChunk.AppendIntervalIndex(outChunk.Len() - 1)
	}
	outChunk.Column(r.outOrdinal).AppendNilsV2(true)
	{{- if ne $v.Name "String"}}
	outChunk.Column(r.outOrdinal).Append{{$v.Name}}Values(r.prevPoint.value)
	{{- else}}
	outChunk.Column(r.outOrdinal).AppendStringValues(string(r.prevPoint.value))
	{{- end}}
	if r.auxProcessor != nil {
		if r.prevPoint.index == 0 {
			r.appendOutAuxCol(r.auxChunk, outChunk, r.prevPoint.index)
		} else {
			r.appendInAuxCol(inChunk, outChunk, r.prevPoint.index-1)
		}
		r.auxChunk.Reset()
	}
}

func (r *{{$k.Name}}Col{{$v.Name}}Iterator) processFirstWindow(
	inChunk, outChunk Chunk, isNil, sameInterval, onlyOneInterval bool, index int, value {{$v.Type}},
) {
	// To distinguish values between inChunk and auxChunk, r.currPoint.index incremented by 1.
	if !isNil {
		r.currPoint.Set(index+1, inChunk.TimeByIndex(index), value)
		r.fv(r.prevPoint, r.currPoint)
	}
	if onlyOneInterval && sameInterval {
		if r.auxProcessor != nil && r.prevPoint.index > 0 {
			r.auxChunk.Reset()
			r.auxChunk.AppendTime(inChunk.TimeByIndex(r.prevPoint.index - 1))
			r.appendInAuxCol(inChunk, r.auxChunk, r.prevPoint.index-1)
		}
		r.prevPoint.index = 0
	} else {
		if !r.prevPoint.isNil {
			r.mergePrevItem(inChunk, outChunk)
		}
		r.prevPoint.Reset()
	}
	r.currPoint.Reset()
}

func (r *{{$k.Name}}Col{{$v.Name}}Iterator) processLastWindow(
	inChunk Chunk, index int, isNil bool, value {{$v.Type}},
) {
	if isNil {
		r.prevPoint.Reset()
	} else {
		r.prevPoint.Set(0, inChunk.TimeByIndex(index), value)
	}
	if r.auxProcessor != nil {
		r.auxChunk.AppendTime(inChunk.TimeByIndex(index))
		r.appendInAuxCol(inChunk, r.auxChunk, index)
	}
}

func (r *{{$k.Name}}Col{{$v.Name}}Iterator) processMiddleWindow(
	inChunk, outChunk Chunk, index int, value {{$v.Type}},
) {
	if r.isSingleCall {
		outChunk.AppendTime(inChunk.TimeByIndex(index))
		outChunk.AppendIntervalIndex(outChunk.Len() - 1)
	}
	outChunk.Column(r.outOrdinal).AppendNilsV2(true)
	outChunk.Column(r.outOrdinal).Append{{$v.Name}}Values(value)
	if r.auxProcessor != nil {
		r.appendInAuxCol(inChunk, outChunk, index)
	}
}

func (r *{{$k.Name}}Col{{$v.Name}}Iterator) Next(ie *IteratorEndpoint, p *IteratorParams) {
	inChunk, outChunk := ie.InputPoint.Chunk, ie.OutputPoint.Chunk
	if inChunk.Column(r.inOrdinal).IsEmpty() && r.prevPoint.isNil {
		var addIntervalLen int
		if p.sameInterval {
			addIntervalLen = inChunk.IntervalLen() - 1
		} else {
			addIntervalLen = inChunk.IntervalLen()
		}
		if addIntervalLen > 0 {
			outChunk.Column(r.outOrdinal).AppendManyNil(addIntervalLen)
		}
		return
	}

	var end int
	firstIndex, lastIndex := 0, len(inChunk.IntervalIndex())-1
	for i, start := range inChunk.IntervalIndex() {
		if i < lastIndex {
			end = inChunk.IntervalIndex()[i+1]
		} else {
			end = inChunk.NumberOfRows()
		}
		index, value, isNil := r.fn(inChunk, r.inOrdinal, start, end)
		if isNil && ((i > firstIndex && i < lastIndex) ||
			(firstIndex == lastIndex && r.prevPoint.isNil && !p.sameInterval) ||
			(firstIndex != lastIndex && i == firstIndex && r.prevPoint.isNil) ||
			(firstIndex != lastIndex && i == lastIndex && !p.sameInterval)) {
			outChunk.Column(r.outOrdinal).AppendNil()
			continue
		}
		if i == firstIndex && !r.prevPoint.isNil {
			r.processFirstWindow(inChunk, outChunk, isNil, p.sameInterval,
			    firstIndex == lastIndex, index, value)
		} else if i == lastIndex && p.sameInterval {
			r.processLastWindow(inChunk, index, isNil, value)
		} else if !isNil {
			r.processMiddleWindow(inChunk, outChunk, index, value)
		}
	}
}
{{- end}}
{{end}}
{{- end}}
{{end}}
{{end}}

{{with $types := .}}
{{range $k := $types}}
{{- if eq $k.Name "Integer"}}
{{range $v := $types}}
{{- if eq $v.Name "Integer"}}
type {{$k.Name}}Col{{$v.Name}}Reduce func(c Chunk, ordinal, start, end int) (index int, value {{$v.Type}}, isNil bool)

type {{$k.Name}}Col{{$v.Name}}Merge func(prevPoint, currPoint *{{$v.Name}}Point)

type {{$k.Name}}Col{{$v.Name}}Iterator struct {
	isSingleCall bool
	inOrdinal    int
	outOrdinal   int
	prevPoint   *{{$v.Name}}Point
	currPoint   *{{$v.Name}}Point
	fn           {{$k.Name}}Col{{$v.Name}}Reduce
	fv           {{$k.Name}}Col{{$v.Name}}Merge
	auxChunk     Chunk
	auxProcessor []*AuxProcessor
}

func New{{$k.Name}}Col{{$v.Name}}Iterator(fn {{$k.Name}}Col{{$v.Name}}Reduce, fv {{$k.Name}}Col{{$v.Name}}Merge,
    isSingleCall bool, inOrdinal, outOrdinal int, auxProcessor []*AuxProcessor, rowDataType hybridqp.RowDataType,
) *{{$k.Name}}Col{{$v.Name}}Iterator {
	r := &{{$k.Name}}Col{{$v.Name}}Iterator{
		fn:           fn,
		fv:           fv,
		isSingleCall: isSingleCall,
		inOrdinal:    inOrdinal,
		outOrdinal:   outOrdinal,
		prevPoint:    new{{$v.Name}}Point(),
		currPoint:    new{{$v.Name}}Point(),
	}
	if isSingleCall && len(auxProcessor) > 0 {
		r.auxProcessor = auxProcessor
		r.auxChunk = NewChunkBuilder(rowDataType).NewChunk("")
	}
	return r
}

func (r *{{$k.Name}}Col{{$v.Name}}Iterator) appendInAuxCol(
    inChunk, outChunk Chunk, index int,
) {
	for j := range r.auxProcessor {
		r.auxProcessor[j].auxHelperFunc(
			inChunk.Column(r.auxProcessor[j].inOrdinal),
			outChunk.Column(r.auxProcessor[j].outOrdinal),
			index,
		)
	}
}

func (r *{{$k.Name}}Col{{$v.Name}}Iterator) appendOutAuxCol(
    inChunk, outChunk Chunk, index int,
) {
	for j := range r.auxProcessor {
		r.auxProcessor[j].auxHelperFunc(
			inChunk.Column(r.auxProcessor[j].outOrdinal),
			outChunk.Column(r.auxProcessor[j].outOrdinal),
			index,
		)
	}
}

func (r *{{$k.Name}}Col{{$v.Name}}Iterator) mergePrevItem(
    inChunk, outChunk Chunk,
) {
	if r.isSingleCall {
		outChunk.AppendTime(r.prevPoint.time)
		outChunk.AppendIntervalIndex(outChunk.Len() - 1)
	}
	outChunk.Column(r.outOrdinal).AppendNilsV2(true)
	{{- if ne $v.Name "String"}}
	outChunk.Column(r.outOrdinal).Append{{$v.Name}}Values(r.prevPoint.value)
	{{- else}}
	outChunk.Column(r.outOrdinal).AppendStringValues(string(r.prevPoint.value))
	{{- end}}
	if r.auxProcessor != nil {
		if r.prevPoint.index == 0 {
			r.appendOutAuxCol(r.auxChunk, outChunk, r.prevPoint.index)
		} else {
			r.appendInAuxCol(inChunk, outChunk, r.prevPoint.index-1)
		}
		r.auxChunk.Reset()
	}
}

func (r *{{$k.Name}}Col{{$v.Name}}Iterator) processFirstWindow(
	inChunk, outChunk Chunk, isNil, sameInterval, onlyOneInterval bool, index int, value {{$v.Type}},
) {
	// To distinguish values between inChunk and auxChunk, r.currPoint.index incremented by 1.
	if !isNil {
		r.currPoint.Set(index+1, inChunk.TimeByIndex(index), value)
		r.fv(r.prevPoint, r.currPoint)
	}
	if onlyOneInterval && sameInterval {
		if r.auxProcessor != nil && r.prevPoint.index > 0 {
			r.auxChunk.Reset()
			r.auxChunk.AppendTime(inChunk.TimeByIndex(r.prevPoint.index - 1))
			r.appendInAuxCol(inChunk, r.auxChunk, r.prevPoint.index-1)
		}
		r.prevPoint.index = 0
	} else {
		if !r.prevPoint.isNil {
			r.mergePrevItem(inChunk, outChunk)
		}
		r.prevPoint.Reset()
	}
	r.currPoint.Reset()
}

func (r *{{$k.Name}}Col{{$v.Name}}Iterator) processLastWindow(
	inChunk Chunk, index int, isNil bool, value {{$v.Type}},
) {
	if isNil {
		r.prevPoint.Reset()
	} else {
		r.prevPoint.Set(0, inChunk.TimeByIndex(index), value)
	}
	if r.auxProcessor != nil {
		r.auxChunk.AppendTime(inChunk.TimeByIndex(index))
		r.appendInAuxCol(inChunk, r.auxChunk, index)
	}
}

func (r *{{$k.Name}}Col{{$v.Name}}Iterator) processMiddleWindow(
	inChunk, outChunk Chunk, index int, value {{$v.Type}},
) {
	if r.isSingleCall {
		outChunk.AppendTime(inChunk.TimeByIndex(index))
		outChunk.AppendIntervalIndex(outChunk.Len() - 1)
	}
	outChunk.Column(r.outOrdinal).AppendNilsV2(true)
	outChunk.Column(r.outOrdinal).Append{{$v.Name}}Values(value)
	if r.auxProcessor != nil {
		r.appendInAuxCol(inChunk, outChunk, index)
	}
}

func (r *{{$k.Name}}Col{{$v.Name}}Iterator) Next(ie *IteratorEndpoint, p *IteratorParams) {
	inChunk, outChunk := ie.InputPoint.Chunk, ie.OutputPoint.Chunk
	if inChunk.Column(r.inOrdinal).IsEmpty() && r.prevPoint.isNil {
		var addIntervalLen int
		if p.sameInterval {
			addIntervalLen = inChunk.IntervalLen() - 1
		} else {
			addIntervalLen = inChunk.IntervalLen()
		}
		if addIntervalLen > 0 {
			outChunk.Column(r.outOrdinal).AppendManyNil(addIntervalLen)
		}
		return
	}

	var end int
	firstIndex, lastIndex := 0, len(inChunk.IntervalIndex())-1
	for i, start := range inChunk.IntervalIndex() {
		if i < lastIndex {
			end = inChunk.IntervalIndex()[i+1]
		} else {
			end = inChunk.NumberOfRows()
		}
		index, value, isNil := r.fn(inChunk, r.inOrdinal, start, end)
		if isNil && ((i > firstIndex && i < lastIndex) ||
			(firstIndex == lastIndex && r.prevPoint.isNil && !p.sameInterval) ||
			(firstIndex != lastIndex && i == firstIndex && r.prevPoint.isNil) ||
			(firstIndex != lastIndex && i == lastIndex && !p.sameInterval)) {
			outChunk.Column(r.outOrdinal).AppendNil()
			continue
		}
		if i == firstIndex && !r.prevPoint.isNil {
			r.processFirstWindow(inChunk, outChunk, isNil, p.sameInterval,
			    firstIndex == lastIndex, index, value)
		} else if i == lastIndex && p.sameInterval {
			r.processLastWindow(inChunk, index, isNil, value)
		} else if !isNil {
			r.processMiddleWindow(inChunk, outChunk, index, value)
		}
	}
}
{{- end}}
{{end}}
{{- end}}
{{end}}
{{end}}

{{with $types := .}}
{{range $k := $types}}
{{- if or (eq $k.Name "String")}}
{{range $v := $types}}
{{- if or (eq $v.Name "Integer") (eq $v.Name "String")}}
type {{$k.Name}}Col{{$v.Name}}Reduce func(c Chunk, ordinal, start, end int) (index int, value {{$v.Type}}, isNil bool)

type {{$k.Name}}Col{{$v.Name}}Merge func(prevPoint, currPoint *{{$v.Name}}Point)

type {{$k.Name}}Col{{$v.Name}}Iterator struct {
	isSingleCall bool
	inOrdinal    int
	outOrdinal   int
	prevPoint   *{{$v.Name}}Point
	currPoint   *{{$v.Name}}Point
	fn           {{$k.Name}}Col{{$v.Name}}Reduce
	fv           {{$k.Name}}Col{{$v.Name}}Merge
	auxChunk     Chunk
	auxProcessor []*AuxProcessor
}

func New{{$k.Name}}Col{{$v.Name}}Iterator(fn {{$k.Name}}Col{{$v.Name}}Reduce, fv {{$k.Name}}Col{{$v.Name}}Merge,
    isSingleCall bool, inOrdinal, outOrdinal int, auxProcessor []*AuxProcessor, rowDataType hybridqp.RowDataType,
) *{{$k.Name}}Col{{$v.Name}}Iterator {
	r := &{{$k.Name}}Col{{$v.Name}}Iterator{
		fn:           fn,
		fv:           fv,
		isSingleCall: isSingleCall,
		inOrdinal:    inOrdinal,
		outOrdinal:   outOrdinal,
		prevPoint:    new{{$v.Name}}Point(),
		currPoint:    new{{$v.Name}}Point(),
	}
	if isSingleCall && len(auxProcessor) > 0 {
		r.auxProcessor = auxProcessor
		r.auxChunk = NewChunkBuilder(rowDataType).NewChunk("")
	}
	return r
}

func (r *{{$k.Name}}Col{{$v.Name}}Iterator) appendInAuxCol(
    inChunk, outChunk Chunk, index int,
) {
	for j := range r.auxProcessor {
		r.auxProcessor[j].auxHelperFunc(
			inChunk.Column(r.auxProcessor[j].inOrdinal),
			outChunk.Column(r.auxProcessor[j].outOrdinal),
			index,
		)
	}
}

func (r *{{$k.Name}}Col{{$v.Name}}Iterator) appendOutAuxCol(
    inChunk, outChunk Chunk, index int,
) {
	for j := range r.auxProcessor {
		r.auxProcessor[j].auxHelperFunc(
			inChunk.Column(r.auxProcessor[j].outOrdinal),
			outChunk.Column(r.auxProcessor[j].outOrdinal),
			index,
		)
	}
}

func (r *{{$k.Name}}Col{{$v.Name}}Iterator) mergePrevItem(
    inChunk, outChunk Chunk,
) {
	if r.isSingleCall {
		outChunk.AppendTime(r.prevPoint.time)
		outChunk.AppendIntervalIndex(outChunk.Len() - 1)
	}
	outChunk.Column(r.outOrdinal).AppendNilsV2(true)
	{{- if ne $v.Name "String"}}
	outChunk.Column(r.outOrdinal).Append{{$v.Name}}Values(r.prevPoint.value)
	{{- else}}
	outChunk.Column(r.outOrdinal).AppendStringValues(string(r.prevPoint.value))
	{{- end}}
	if r.auxProcessor != nil {
		if r.prevPoint.index == 0 {
			r.appendOutAuxCol(r.auxChunk, outChunk, r.prevPoint.index)
		} else {
			r.appendInAuxCol(inChunk, outChunk, r.prevPoint.index-1)
		}
		r.auxChunk.Reset()
	}
}

func (r *{{$k.Name}}Col{{$v.Name}}Iterator) processFirstWindow(
	inChunk, outChunk Chunk, isNil, sameInterval, onlyOneInterval bool, index int, value {{$v.Type}},
) {
	// To distinguish values between inChunk and auxChunk, r.currPoint.index incremented by 1.
	if !isNil {
		r.currPoint.Set(index+1, inChunk.TimeByIndex(index), value)
		r.fv(r.prevPoint, r.currPoint)
	}
	if onlyOneInterval && sameInterval {
		if r.auxProcessor != nil && r.prevPoint.index > 0 {
			r.auxChunk.Reset()
			r.auxChunk.AppendTime(inChunk.TimeByIndex(r.prevPoint.index - 1))
			r.appendInAuxCol(inChunk, r.auxChunk, r.prevPoint.index-1)
		}
		r.prevPoint.index = 0
	} else {
		if !r.prevPoint.isNil {
			r.mergePrevItem(inChunk, outChunk)
		}
		r.prevPoint.Reset()
	}
	r.currPoint.Reset()
}

func (r *{{$k.Name}}Col{{$v.Name}}Iterator) processLastWindow(
	inChunk Chunk, index int, isNil bool, value {{$v.Type}},
) {
	if isNil {
		r.prevPoint.Reset()
	} else {
		r.prevPoint.Set(0, inChunk.TimeByIndex(index), value)
	}
	if r.auxProcessor != nil {
		r.auxChunk.AppendTime(inChunk.TimeByIndex(index))
		r.appendInAuxCol(inChunk, r.auxChunk, index)
	}
}

func (r *{{$k.Name}}Col{{$v.Name}}Iterator) processMiddleWindow(
	inChunk, outChunk Chunk, index int, value {{$v.Type}},
) {
	if r.isSingleCall {
		outChunk.AppendTime(inChunk.TimeByIndex(index))
		outChunk.AppendIntervalIndex(outChunk.Len() - 1)
	}
	outChunk.Column(r.outOrdinal).AppendNilsV2(true)
	outChunk.Column(r.outOrdinal).Append{{$v.Name}}Values(value)
	if r.auxProcessor != nil {
		r.appendInAuxCol(inChunk, outChunk, index)
	}
}

func (r *{{$k.Name}}Col{{$v.Name}}Iterator) Next(ie *IteratorEndpoint, p *IteratorParams) {
	inChunk, outChunk := ie.InputPoint.Chunk, ie.OutputPoint.Chunk
	if inChunk.Column(r.inOrdinal).IsEmpty() && r.prevPoint.isNil {
		var addIntervalLen int
		if p.sameInterval {
			addIntervalLen = inChunk.IntervalLen() - 1
		} else {
			addIntervalLen = inChunk.IntervalLen()
		}
		if addIntervalLen > 0 {
			outChunk.Column(r.outOrdinal).AppendManyNil(addIntervalLen)
		}
		return
	}

	var end int
	firstIndex, lastIndex := 0, len(inChunk.IntervalIndex())-1
	for i, start := range inChunk.IntervalIndex() {
		if i < lastIndex {
			end = inChunk.IntervalIndex()[i+1]
		} else {
			end = inChunk.NumberOfRows()
		}
		index, value, isNil := r.fn(inChunk, r.inOrdinal, start, end)
		if isNil && ((i > firstIndex && i < lastIndex) ||
			(firstIndex == lastIndex && r.prevPoint.isNil && !p.sameInterval) ||
			(firstIndex != lastIndex && i == firstIndex && r.prevPoint.isNil) ||
			(firstIndex != lastIndex && i == lastIndex && !p.sameInterval)) {
			outChunk.Column(r.outOrdinal).AppendNil()
			continue
		}
		if i == firstIndex && !r.prevPoint.isNil {
			r.processFirstWindow(inChunk, outChunk, isNil, p.sameInterval,
			    firstIndex == lastIndex, index, value)
		} else if i == lastIndex && p.sameInterval {
			r.processLastWindow(inChunk, index, isNil, value)
		} else if !isNil {
			r.processMiddleWindow(inChunk, outChunk, index, value)
		}
	}
}
{{- end}}
{{end}}
{{- end}}
{{end}}
{{end}}

{{with $types := .}}
{{range $k := $types}}
{{- if or (eq $k.Name "Boolean")}}
{{range $v := $types}}
{{- if or (eq $v.Name "Integer") (eq $v.Name "Boolean")}}
type {{$k.Name}}Col{{$v.Name}}Reduce func(c Chunk, ordinal, start, end int) (index int, value {{$v.Type}}, isNil bool)

type {{$k.Name}}Col{{$v.Name}}Merge func(prevPoint, currPoint *{{$v.Name}}Point)

type {{$k.Name}}Col{{$v.Name}}Iterator struct {
	isSingleCall bool
	inOrdinal    int
	outOrdinal   int
	prevPoint   *{{$v.Name}}Point
	currPoint   *{{$v.Name}}Point
	fn           {{$k.Name}}Col{{$v.Name}}Reduce
	fv           {{$k.Name}}Col{{$v.Name}}Merge
	auxChunk     Chunk
	auxProcessor []*AuxProcessor
}

func New{{$k.Name}}Col{{$v.Name}}Iterator(fn {{$k.Name}}Col{{$v.Name}}Reduce, fv {{$k.Name}}Col{{$v.Name}}Merge,
    isSingleCall bool, inOrdinal, outOrdinal int, auxProcessor []*AuxProcessor, rowDataType hybridqp.RowDataType,
) *{{$k.Name}}Col{{$v.Name}}Iterator {
	r := &{{$k.Name}}Col{{$v.Name}}Iterator{
		fn:           fn,
		fv:           fv,
		isSingleCall: isSingleCall,
		inOrdinal:    inOrdinal,
		outOrdinal:   outOrdinal,
		prevPoint:    new{{$v.Name}}Point(),
		currPoint:    new{{$v.Name}}Point(),
	}
	if isSingleCall && len(auxProcessor) > 0 {
		r.auxProcessor = auxProcessor
		r.auxChunk = NewChunkBuilder(rowDataType).NewChunk("")
	}
	return r
}

func (r *{{$k.Name}}Col{{$v.Name}}Iterator) appendInAuxCol(
    inChunk, outChunk Chunk, index int,
) {
	for j := range r.auxProcessor {
		r.auxProcessor[j].auxHelperFunc(
			inChunk.Column(r.auxProcessor[j].inOrdinal),
			outChunk.Column(r.auxProcessor[j].outOrdinal),
			index,
		)
	}
}

func (r *{{$k.Name}}Col{{$v.Name}}Iterator) appendOutAuxCol(
    inChunk, outChunk Chunk, index int,
) {
	for j := range r.auxProcessor {
		r.auxProcessor[j].auxHelperFunc(
			inChunk.Column(r.auxProcessor[j].outOrdinal),
			outChunk.Column(r.auxProcessor[j].outOrdinal),
			index,
		)
	}
}

func (r *{{$k.Name}}Col{{$v.Name}}Iterator) mergePrevItem(
    inChunk, outChunk Chunk,
) {
	if r.isSingleCall {
		outChunk.AppendTime(r.prevPoint.time)
		outChunk.AppendIntervalIndex(outChunk.Len() - 1)
	}
	outChunk.Column(r.outOrdinal).AppendNilsV2(true)
	{{- if ne $v.Name "String"}}
	outChunk.Column(r.outOrdinal).Append{{$v.Name}}Values(r.prevPoint.value)
	{{- else}}
	outChunk.Column(r.outOrdinal).AppendStringValues(string(r.prevPoint.value))
	{{- end}}
	if r.auxProcessor != nil {
		if r.prevPoint.index == 0 {
			r.appendOutAuxCol(r.auxChunk, outChunk, r.prevPoint.index)
		} else {
			r.appendInAuxCol(inChunk, outChunk, r.prevPoint.index-1)
		}
		r.auxChunk.Reset()
	}
}

func (r *{{$k.Name}}Col{{$v.Name}}Iterator) processFirstWindow(
	inChunk, outChunk Chunk, isNil, sameInterval, onlyOneInterval bool, index int, value {{$v.Type}},
) {
	// To distinguish values between inChunk and auxChunk, r.currPoint.index incremented by 1.
	if !isNil {
		r.currPoint.Set(index+1, inChunk.TimeByIndex(index), value)
		r.fv(r.prevPoint, r.currPoint)
	}
	if onlyOneInterval && sameInterval {
		if r.auxProcessor != nil && r.prevPoint.index > 0 {
			r.auxChunk.Reset()
			r.auxChunk.AppendTime(inChunk.TimeByIndex(r.prevPoint.index - 1))
			r.appendInAuxCol(inChunk, r.auxChunk, r.prevPoint.index-1)
		}
		r.prevPoint.index = 0
	} else {
		if !r.prevPoint.isNil {
			r.mergePrevItem(inChunk, outChunk)
		}
		r.prevPoint.Reset()
	}
	r.currPoint.Reset()
}

func (r *{{$k.Name}}Col{{$v.Name}}Iterator) processLastWindow(
	inChunk Chunk, index int, isNil bool, value {{$v.Type}},
) {
	if isNil {
		r.prevPoint.Reset()
	} else {
		r.prevPoint.Set(0, inChunk.TimeByIndex(index), value)
	}
	if r.auxProcessor != nil {
		r.auxChunk.AppendTime(inChunk.TimeByIndex(index))
		r.appendInAuxCol(inChunk, r.auxChunk, index)
	}
}

func (r *{{$k.Name}}Col{{$v.Name}}Iterator) processMiddleWindow(
	inChunk, outChunk Chunk, index int, value {{$v.Type}},
) {
	if r.isSingleCall {
		outChunk.AppendTime(inChunk.TimeByIndex(index))
		outChunk.AppendIntervalIndex(outChunk.Len() - 1)
	}
	outChunk.Column(r.outOrdinal).AppendNilsV2(true)
	outChunk.Column(r.outOrdinal).Append{{$v.Name}}Values(value)
	if r.auxProcessor != nil {
		r.appendInAuxCol(inChunk, outChunk, index)
	}
}

func (r *{{$k.Name}}Col{{$v.Name}}Iterator) Next(ie *IteratorEndpoint, p *IteratorParams) {
	inChunk, outChunk := ie.InputPoint.Chunk, ie.OutputPoint.Chunk
	if inChunk.Column(r.inOrdinal).IsEmpty() && r.prevPoint.isNil {
		var addIntervalLen int
		if p.sameInterval {
			addIntervalLen = inChunk.IntervalLen() - 1
		} else {
			addIntervalLen = inChunk.IntervalLen()
		}
		if addIntervalLen > 0 {
			outChunk.Column(r.outOrdinal).AppendManyNil(addIntervalLen)
		}
		return
	}

	var end int
	firstIndex, lastIndex := 0, len(inChunk.IntervalIndex())-1
	for i, start := range inChunk.IntervalIndex() {
		if i < lastIndex {
			end = inChunk.IntervalIndex()[i+1]
		} else {
			end = inChunk.NumberOfRows()
		}
		index, value, isNil := r.fn(inChunk, r.inOrdinal, start, end)
		if isNil && ((i > firstIndex && i < lastIndex) ||
			(firstIndex == lastIndex && r.prevPoint.isNil && !p.sameInterval) ||
			(firstIndex != lastIndex && i == firstIndex && r.prevPoint.isNil) ||
			(firstIndex != lastIndex && i == lastIndex && !p.sameInterval)) {
			outChunk.Column(r.outOrdinal).AppendNil()
			continue
		}
		if i == firstIndex && !r.prevPoint.isNil {
			r.processFirstWindow(inChunk, outChunk, isNil, p.sameInterval,
			    firstIndex == lastIndex, index, value)
		} else if i == lastIndex && p.sameInterval {
			r.processLastWindow(inChunk, index, isNil, value)
		} else if !isNil {
			r.processMiddleWindow(inChunk, outChunk, index, value)
		}
	}
}
{{- end}}
{{end}}
{{- end}}
{{end}}
{{end}}

{{range .}}
type {{.Name}}TimeCol{{.Name}}Reduce func(c Chunk, ordinal, start, end int) (index int, value {{.Type}}, isNil bool)

type {{.Name}}TimeCol{{.Name}}Merge func(prevPoint, currPoint *{{.Name}}Point)

type {{.Name}}TimeCol{{.Name}}Iterator struct {
	initTimeCol  bool
	inOrdinal    int
	outOrdinal   int
	prevPoint   *{{.Name}}Point
	currPoint   *{{.Name}}Point
	fn           {{.Name}}TimeCol{{.Name}}Reduce
	fv           {{.Name}}TimeCol{{.Name}}Merge
}

func New{{.Name}}TimeCol{{.Name}}Iterator(
    fn {{.Name}}TimeCol{{.Name}}Reduce, fv {{.Name}}TimeCol{{.Name}}Merge, inOrdinal, outOrdinal int,
) *{{.Name}}TimeCol{{.Name}}Iterator {
	r := &{{.Name}}TimeCol{{.Name}}Iterator{
		fn:           fn,
		fv:           fv,
		inOrdinal:    inOrdinal,
		outOrdinal:   outOrdinal,
		prevPoint:    new{{.Name}}Point(),
		currPoint:    new{{.Name}}Point(),
	}
	return r
}

func (r *{{.Name}}TimeCol{{.Name}}Iterator) mergePrevItem(
    outChunk Chunk,
) {
	{{- if ne .Name "String"}}
	outChunk.Column(r.outOrdinal).Append{{.Name}}Values(r.prevPoint.value)
	{{- else}}
	outChunk.Column(r.outOrdinal).AppendStringValues(string(r.prevPoint.value))
	{{- end}}
	outChunk.Column(r.outOrdinal).AppendColumnTimes(r.prevPoint.time)
	outChunk.Column(r.outOrdinal).AppendNilsV2(true)
}

func (r *{{.Name}}TimeCol{{.Name}}Iterator) processFirstWindow(
	inChunk, outChunk Chunk, isNil, sameInterval, onlyOneInterval bool, index int, value {{.Type}},
) {
	// To distinguish values between inChunk and auxChunk, r.currPoint.index incremented by 1.
	if !isNil {
		if r.initTimeCol {
			r.currPoint.Set(index+1, inChunk.Column(r.inOrdinal).ColumnTime(index), value)
		} else {
			r.currPoint.Set(index+1, inChunk.TimeByIndex(index), value)
		}
		r.fv(r.prevPoint, r.currPoint)
	}
	if onlyOneInterval && sameInterval {
		r.prevPoint.index = 0
	} else {
		if !r.prevPoint.isNil {
			r.mergePrevItem(outChunk)
		}
		r.prevPoint.Reset()
	}
	r.currPoint.Reset()
}

func (r *{{.Name}}TimeCol{{.Name}}Iterator) processLastWindow(
	inChunk Chunk, index int, isNil bool, value {{.Type}},
) {
	if isNil {
		r.prevPoint.Reset()
		return
	}
	if r.initTimeCol {
		r.prevPoint.Set(0, inChunk.Column(r.inOrdinal).ColumnTime(index), value)
	} else {
		r.prevPoint.Set(0, inChunk.TimeByIndex(index), value)
	}
}

func (r *{{.Name}}TimeCol{{.Name}}Iterator) processMiddleWindow(
	inChunk, outChunk Chunk, index int, value {{.Type}},
) {
	if r.initTimeCol {
		outChunk.Column(r.outOrdinal).AppendColumnTimes(inChunk.Column(r.inOrdinal).ColumnTime(index))
	} else {
		outChunk.Column(r.outOrdinal).AppendColumnTimes(inChunk.TimeByIndex(index))
	}
	outChunk.Column(r.outOrdinal).Append{{.Name}}Values(value)
	outChunk.Column(r.outOrdinal).AppendNilsV2(true)
}

func (r *{{.Name}}TimeCol{{.Name}}Iterator) Next(ie *IteratorEndpoint, p *IteratorParams) {
	inChunk, outChunk := ie.InputPoint.Chunk, ie.OutputPoint.Chunk
	if inChunk.Column(r.inOrdinal).IsEmpty() && r.prevPoint.isNil {
		var addIntervalLen int
		if p.sameInterval {
			addIntervalLen = inChunk.IntervalLen() - 1
		} else {
			addIntervalLen = inChunk.IntervalLen()
		}
		if addIntervalLen > 0 {
			outChunk.Column(r.outOrdinal).AppendManyNil(addIntervalLen)
		}
		return
	}

	var end int
	r.initTimeCol = len(inChunk.Column(r.inOrdinal).ColumnTimes()) > 0
	firstIndex, lastIndex := 0, len(inChunk.IntervalIndex())-1
	for i, start := range inChunk.IntervalIndex() {
		if i < lastIndex {
			end = inChunk.IntervalIndex()[i+1]
		} else {
			end = inChunk.NumberOfRows()
		}
		index, value, isNil := r.fn(inChunk, r.inOrdinal, start, end)
		if isNil && ((i > firstIndex && i < lastIndex) ||
			(firstIndex == lastIndex && r.prevPoint.isNil && !p.sameInterval) ||
			(firstIndex != lastIndex && i == firstIndex && r.prevPoint.isNil) ||
			(firstIndex != lastIndex && i == lastIndex && !p.sameInterval)) {
			outChunk.Column(r.outOrdinal).AppendNil()
			continue
		}
		if i == firstIndex && !r.prevPoint.isNil {
			r.processFirstWindow(inChunk, outChunk, isNil, p.sameInterval,
				firstIndex == lastIndex, index, value)
		} else if i == lastIndex && p.sameInterval {
			r.processLastWindow(inChunk, index, isNil, value)
		} else if !isNil {
			r.processMiddleWindow(inChunk, outChunk, index, value)
		}
	}
}
{{end}}

{{range .}}
{{- if and (ne .Name "String") (ne .Name "Boolean")}}
type {{.Name}}SliceItem struct {
	index []int
	time  []int64
	value []{{.Type}}
}

func (f *{{.Name}}SliceItem) AppendItem(c Chunk, ordinal, start, end int) {
    if start==end{
            return
    }
	fLen := len(f.time)
	if c.Column(ordinal).NilCount() == 0 {
		// fast path
		for i := start; i < end; i++ {
			f.index = append(f.index, fLen+i-start)
			f.time = append(f.time, c.TimeByIndex(i))
		}
	} else {
		// slow path
		getTimeIndex := c.Column(ordinal).GetTimeIndex
		for i := start; i < end; i++ {
			f.index = append(f.index, fLen+i-start)
			f.time = append(f.time, c.TimeByIndex(getTimeIndex(i)))
		}
	}
	f.value = append(f.value, c.Column(ordinal).{{.Name}}Values()[start:end]...)
}

func (f *{{.Name}}SliceItem) Reset() {
	f.index = f.index[:0]
	f.time = f.time[:0]
	f.value = f.value[:0]
}

func (f *{{.Name}}SliceItem) Len() int {
	return len(f.time)
}

func (f *{{.Name}}SliceItem) Less(i, j int) bool {
	return f.value[i] < f.value[j]
}

func (f *{{.Name}}SliceItem) Swap(i, j int) {
	f.index[i], f.index[j] = f.index[j], f.index[i]
	f.time[i], f.time[j] = f.time[j], f.time[i]
	f.value[i], f.value[j] = f.value[j], f.value[i]
}
{{- end}}
{{end}}

type StringSliceItem struct {
	index     []int
	time      []int64
	value     []string
	valueBits []byte
}

func (f *StringSliceItem) AppendItem(c Chunk, ordinal, start, end int) {
    if start==end{
        return
    }
	fLen := len(f.time)
	if c.Column(ordinal).NilCount() == 0 {
		// fast path
		for i := start; i < end; i++ {
			f.index = append(f.index, fLen+i-start)
			f.time = append(f.time, c.TimeByIndex(i))
		}
	} else {
		// slow path
		getTimeIndex := c.Column(ordinal).GetTimeIndex
		for i := start; i < end; i++ {
			f.index = append(f.index, fLen+i-start)
			f.time = append(f.time, c.TimeByIndex(getTimeIndex(i)))
		}
	}

	col := c.Column(ordinal)
	f.valueBits, f.value = col.GetStringValueBytes(f.valueBits, f.value, start, end)
}

func (f *StringSliceItem) Reset() {
	f.index = f.index[:0]
	f.time = f.time[:0]
	f.value = f.value[:0]
	f.valueBits = f.valueBits[:0]
}

func (f *StringSliceItem) Len() int {
	return len(f.time)
}

func (f *StringSliceItem) Less(i, j int) bool {
	return f.value[i] < f.value[j]
}

func (f *StringSliceItem) Swap(i, j int) {
	f.index[i], f.index[j] = f.index[j], f.index[i]
	f.time[i], f.time[j] = f.time[j], f.time[i]
	f.value[i], f.value[j] = f.value[j], f.value[i]
}

type BooleanSliceItem struct {
	index []int
	time  []int64
	value []bool
}

func (f *BooleanSliceItem) AppendItem(c Chunk, ordinal, start, end int) {
    if start==end{
        return
    }
	fLen := len(f.time)
	if c.Column(ordinal).NilCount() == 0 {
		// fast path
		for i := start; i < end; i++ {
			f.index = append(f.index, fLen+i-start)
			f.time = append(f.time, c.TimeByIndex(i))
		}
	} else {
		// slow path
		getTimeIndex := c.Column(ordinal).GetTimeIndex
		for i := start; i < end; i++ {
			f.index = append(f.index, fLen+i-start)
			f.time = append(f.time, c.TimeByIndex(getTimeIndex(i)))
		}
	}
	f.value = append(f.value, c.Column(ordinal).BooleanValues()[start:end]...)
}

func (f *BooleanSliceItem) Reset() {
	f.index = f.index[:0]
	f.time = f.time[:0]
	f.value = f.value[:0]
}

func (f *BooleanSliceItem) Len() int {
	return len(f.time)
}

{{range .}}
type {{.Name}}ColReduceSliceReduce func({{.name}}Item *{{.Name}}SliceItem) (index int, time int64, value float64, isNil bool)

func New{{.Name}}SliceItem() *{{.Name}}SliceItem {
	return &{{.Name}}SliceItem{}
}

type {{.Name}}Col{{.Name}}SliceIterator struct {
	isSingleCall bool
	inOrdinal    int
	outOrdinal   int
	buf          *{{.Name}}SliceItem
	fn           {{.Name}}ColReduceSliceReduce
	auxChunk     Chunk
	auxProcessor []*AuxProcessor
	windowIndex  []int
}

func New{{.Name}}Col{{.Name}}SliceIterator(fn {{.Name}}ColReduceSliceReduce,
	isSingleCall bool, inOrdinal, outOrdinal int, auxProcessor []*AuxProcessor, rowDataType hybridqp.RowDataType,
) *{{.Name}}Col{{.Name}}SliceIterator {
	r := &{{.Name}}Col{{.Name}}SliceIterator{
		buf:          New{{.Name}}SliceItem(),
		fn:           fn,
		isSingleCall: isSingleCall,
		inOrdinal:    inOrdinal,
		outOrdinal:   outOrdinal,
	}
	if isSingleCall && len(auxProcessor) > 0 {
		r.auxProcessor = auxProcessor
		r.auxChunk = NewChunkBuilder(rowDataType).NewChunk("")
	}
	return r
}

func (r *{{.Name}}Col{{.Name}}SliceIterator) appendInAuxCol(
	inChunk, outChunk Chunk, index int,
) {
	for j := range r.auxProcessor {
		r.auxProcessor[j].auxHelperFunc(
			inChunk.Column(r.auxProcessor[j].inOrdinal),
			outChunk.Column(r.auxProcessor[j].outOrdinal),
			index,
		)
	}
}

func (r *{{.Name}}Col{{.Name}}SliceIterator) appendOutAuxCol(
	inChunk, outChunk Chunk, index int,
) {
	for j := range r.auxProcessor {
		r.auxProcessor[j].auxHelperFunc(
			inChunk.Column(r.auxProcessor[j].outOrdinal),
			outChunk.Column(r.auxProcessor[j].outOrdinal),
			index,
		)
	}
}

func (r *{{.Name}}Col{{.Name}}SliceIterator) updateAuxChunk(
	inChunk, outChunk Chunk, start, end int,
) {
   if start==end {
        return
   }
	for j := start; j < end; j++ {
		r.windowIndex = append(r.windowIndex, j)
	}
	for j := range r.auxProcessor {
		r.auxProcessor[j].auxHelperFunc(
			inChunk.Column(r.auxProcessor[j].inOrdinal),
			outChunk.Column(r.auxProcessor[j].outOrdinal),
			r.windowIndex...,
		)
	}
	r.windowIndex = r.windowIndex[:0]
}

func (r *{{.Name}}Col{{.Name}}SliceIterator) mergePrevItem(
	outChunk Chunk, idx int, time int64, val float64,
) {
	if idx != -1 {
        if r.isSingleCall {
            outChunk.AppendTime(r.buf.time[idx])
            outChunk.AppendIntervalIndex(outChunk.Len() - 1)
        }
        outChunk.Column(r.outOrdinal).AppendNilsV2(true)
        outChunk.Column(r.outOrdinal).Append{{.Name}}Values(r.buf.value[idx])
        if r.auxProcessor != nil {
            r.appendOutAuxCol(r.auxChunk, outChunk, r.buf.index[idx])
            r.auxChunk.Reset()
        }
    } else {
        if r.isSingleCall {
            outChunk.AppendTime(time)
            outChunk.AppendIntervalIndex(outChunk.Len() - 1)
        }
        outChunk.Column(r.outOrdinal).AppendNilsV2(true)
        outChunk.Column(r.outOrdinal).AppendFloatValues(val)
    }
}

func (r *{{.Name}}Col{{.Name}}SliceIterator) assembleCurrItem(
	inChunk, outChunk Chunk, vs, idx int, time int64, val float64,
) {
	if idx != -1 {
        if r.isSingleCall {
            outChunk.AppendTime(r.buf.time[idx])
            outChunk.AppendIntervalIndex(outChunk.Len() - 1)
        }
        outChunk.Column(r.outOrdinal).AppendNilsV2(true)
        outChunk.Column(r.outOrdinal).Append{{.Name}}Values(r.buf.value[idx])
        if r.auxProcessor != nil {
            r.appendInAuxCol(inChunk, outChunk, vs+r.buf.index[idx])
        }
    } else {
        if r.isSingleCall {
            outChunk.AppendTime(time)
            outChunk.AppendIntervalIndex(outChunk.Len() - 1)
        }
        outChunk.Column(r.outOrdinal).AppendNilsV2(true)
        outChunk.Column(r.outOrdinal).AppendFloatValues(val)
    }
}

func (r *{{.Name}}Col{{.Name}}SliceIterator) processFirstWindow(
	inChunk, outChunk Chunk, sameInterval, haveMultiInterval bool, start, end int,
) {
	r.buf.AppendItem(inChunk, r.inOrdinal, start, end)
	if r.auxProcessor != nil {
		r.updateAuxChunk(inChunk, r.auxChunk, start, end)
	}
	if haveMultiInterval || !sameInterval {
		index, time, value, isNil := r.fn(r.buf)
		if !isNil {
			r.mergePrevItem(outChunk, index, time, value)
		}
		r.buf.Reset()
	}
}

func (r *{{.Name}}Col{{.Name}}SliceIterator) processLastWindow(
	inChunk Chunk, start, end int,
) {
	r.buf.AppendItem(inChunk, r.inOrdinal, start, end)
	if r.auxProcessor != nil {
		r.updateAuxChunk(inChunk, r.auxChunk, start, end)
	}
}

func (r *{{.Name}}Col{{.Name}}SliceIterator) processMiddleWindow(
	inChunk, outChunk Chunk, start, end int,
) {
	r.buf.AppendItem(inChunk, r.inOrdinal, start, end)
	index, time, value, isNil := r.fn(r.buf)
	if !isNil {
		r.assembleCurrItem(inChunk, outChunk, start, index, time, value)
	}
	r.buf.Reset()
}

func (r *{{.Name}}Col{{.Name}}SliceIterator) Next(ie *IteratorEndpoint, p *IteratorParams) {
	inChunk, outChunk := ie.InputPoint.Chunk, ie.OutputPoint.Chunk

	var end int
	firstIndex, lastIndex := 0, len(inChunk.IntervalIndex())-1
	for i, start := range inChunk.IntervalIndex() {
		if i < lastIndex {
            end = inChunk.IntervalIndex()[i+1]
        } else {
            end = inChunk.NumberOfRows()
        }
        if !r.isSingleCall {
            start, end = inChunk.Column(r.inOrdinal).GetRangeValueIndexV2(start, end)
            if start == end && r.buf.Len() == 0 && (i<lastIndex || (i==lastIndex && !p.sameInterval)){
                outChunk.Column(r.outOrdinal).AppendNilsV2(false)
                continue
            }
        }
		if i == firstIndex && r.buf.Len() > 0 {
			r.processFirstWindow(inChunk, outChunk, p.sameInterval,
				firstIndex != lastIndex, start, end)
		} else if i == lastIndex && p.sameInterval {
			r.processLastWindow(inChunk, start, end)
		} else {
			r.processMiddleWindow(inChunk, outChunk, start, end)
		}
	}
}
{{end}}

{{range .}}
{{- if and (ne .Name "String") (ne .Name "Boolean")}}
type {{.Name}}PointItem struct {
	time  int64
	value {{.Type}}
	index int
}

func New{{.Name}}PointItem(time int64, value {{.Type}}) *{{.Name}}PointItem {
	return &{{.Name}}PointItem{
		time:  time,
		value: value,
	}
}

type {{.Name}}HeapItem struct {
	sortByTime bool
	maxIndex   int
	cmpByValue func(a, b *{{.Name}}PointItem) bool
	cmpByTime  func(a, b *{{.Name}}PointItem) bool
	items      []{{.Name}}PointItem
}

func New{{.Name}}HeapItem(n int, cmpByValue, cmpByTime  func(a, b *{{.Name}}PointItem) bool) *{{.Name}}HeapItem {
	return &{{.Name}}HeapItem{
        items:      make([]{{.Name}}PointItem, 0, n),
        cmpByValue : cmpByValue,
        cmpByTime : cmpByTime,
    }
}

func (f *{{.Name}}HeapItem) appendFast(input Chunk, start, end, ordinal int) {
	// fast path
	for i := start; i < end; i++ {
		p := New{{.Name}}PointItem(
			input.TimeByIndex(i),
			input.Column(ordinal).{{.Name}}Values()[i])
		if f.Len() == cap(f.items) {
			if !f.cmpByValue(&f.items[0], p) {
				continue
			}
			f.items[0] = *p
			heap.Fix(f, 0)
			continue
		} else {
			heap.Push(f, *p)
		}
	}
}

func (f *{{.Name}}HeapItem) appendSlow(input Chunk, start, end, ordinal int) {
	// slow path
	for i := start; i < end; i++ {
		if input.Column(ordinal).IsNilV2(i) {
			continue
		}
		p := New{{.Name}}PointItem(
			input.TimeByIndex(i),
			input.Column(ordinal).{{.Name}}Values()[input.Column(ordinal).GetValueIndexV2(i)])
		if f.Len() == cap(f.items) {
			if !f.cmpByValue(&f.items[0], p) {
				continue
			}
			f.items[0] = *p
			heap.Fix(f, 0)
			continue
		} else {
			heap.Push(f, *p)
		}
	}
}

func (f *{{.Name}}HeapItem) append(input Chunk, start, end, ordinal int) {
	if input.Column(ordinal).NilCount() == 0 {
		f.appendFast(input, start, end, ordinal)
	} else {
		f.appendSlow(input, start, end, ordinal)
	}
}

func (f *{{.Name}}HeapItem) appendForAuxFast(input Chunk, start, end, ordinal, maxIndex int) {
	// fast path
	for i := start; i < end; i++ {
		p := New{{.Name}}PointItem(
			input.TimeByIndex(i),
			input.Column(ordinal).{{.Name}}Values()[i])
		p.index = maxIndex + i
		if f.Len() == cap(f.items) {
			if !f.cmpByValue(&f.items[0], p) {
				continue
			}
			if (*p).index > f.maxIndex {
				f.maxIndex = (*p).index
			}
			f.items[0] = *p
			heap.Fix(f, 0)
			continue
		} else {
			if (*p).index > f.maxIndex {
				f.maxIndex = (*p).index
			}
			heap.Push(f, *p)
		}
	}
}

func (f *{{.Name}}HeapItem) appendForAuxSlow(input Chunk, start, end, ordinal, maxIndex int) {
	// slow path
	for i := start; i < end; i++ {
		if input.Column(ordinal).IsNilV2(i) {
			continue
		}
		p := New{{.Name}}PointItem(
			input.TimeByIndex(i),
			input.Column(ordinal).{{.Name}}Values()[input.Column(ordinal).GetValueIndexV2(i)])
		p.index = maxIndex + i
		if f.Len() == cap(f.items) {
			if !f.cmpByValue(&f.items[0], p) {
				continue
			}
			if (*p).index > f.maxIndex {
				f.maxIndex = (*p).index
			}
			f.items[0] = *p
			heap.Fix(f, 0)
			continue
		} else {
			if (*p).index > f.maxIndex {
				f.maxIndex = (*p).index
			}
			heap.Push(f, *p)
		}
	}
}

func (f *{{.Name}}HeapItem) appendForAux(input Chunk, start, end, ordinal int) []int {
	// make each index unique
	maxIndex := f.maxIndex + 1 - start
	if input.Column(ordinal).NilCount() == 0 {
		f.appendForAuxFast(input, start, end, ordinal, maxIndex)
	} else {
		f.appendForAuxSlow(input, start, end, ordinal, maxIndex)
	}
	index := make([]int, 0)
	for i := range f.items {
		if idx := f.items[i].index - maxIndex; idx >= start {
			index = append(index, idx)
		}
	}
	return index
}

func (f *{{.Name}}HeapItem) Reset() {
	f.items = f.items[:0]
	f.sortByTime = false
	f.maxIndex = 0
}

func (f *{{.Name}}HeapItem) Len() int {
	return len(f.items)
}

func (f *{{.Name}}HeapItem) Less(i, j int) bool {
	if !f.sortByTime {
		return f.cmpByValue(&f.items[i], &f.items[j])
	}
	return f.cmpByTime(&f.items[i], &f.items[j])
}

func (f *{{.Name}}HeapItem) Swap(i, j int) {
	f.items[i], f.items[j] = f.items[j], f.items[i]
}

func (f *{{.Name}}HeapItem) Push(x interface{}) {
	f.items = append(f.items, x.({{.Name}}PointItem))
}

func (f *{{.Name}}HeapItem) Pop() interface{} {
	p := f.items[len(f.items)-1]
	f.items = f.items[:len(f.items)-1]
	return p
}
{{- end}}
{{end}}



{{range .}}
{{- if and (ne .Name "String") (ne .Name "Boolean")}}

type {{.Name}}Col{{.Name}}HeapIterator struct {
	n             int
	inOrdinal     int
	outOrdinal    int
	prevMaxIndex  int
	buf           *{{.Name}}HeapItem
	auxChunk      Chunk
	auxProcessor  []*AuxProcessor
	windowIndex   []int
	prevBufIndex  []int
	currBufIndex  []int
	interBufIndex []int
}


func New{{.Name}}Col{{.Name}}HeapIterator(
	inOrdinal, outOrdinal int, auxProcessor []*AuxProcessor, rowDataType hybridqp.RowDataType, {{.Name}}HeapItem *{{.Name}}HeapItem,
) *{{.Name}}Col{{.Name}}HeapIterator {
	r := &{{.Name}}Col{{.Name}}HeapIterator{
		buf:        {{.Name}}HeapItem,
		inOrdinal:  inOrdinal,
		outOrdinal: outOrdinal,
	}
	if len(auxProcessor) > 0 {
		r.auxProcessor = auxProcessor
		r.auxChunk = NewChunkBuilder(rowDataType).NewChunk("")
	}
	return r
}

func (r *{{.Name}}Col{{.Name}}HeapIterator) appendPrevItem(
	inChunk, outChunk Chunk,
) {
	for j := range r.buf.items {
        outChunk.AppendTime(r.buf.items[j].time)
        outChunk.Column(r.outOrdinal).Append{{.Name}}Values(r.buf.items[j].value)
        outChunk.Column(r.outOrdinal).AppendNilsV2(true)
    }
    if len(r.auxProcessor) > 0 {
        for j := range r.buf.items {
            r.windowIndex = append(r.windowIndex, j)
        }
        for j := range r.auxProcessor {
            r.auxProcessor[j].auxHelperFunc(
                r.auxChunk.Column(r.auxProcessor[j].outOrdinal),
                outChunk.Column(r.auxProcessor[j].outOrdinal),
                r.windowIndex...,
            )
        }
        r.windowIndex = r.windowIndex[:0]
        r.auxChunk.Reset()
    }
    outChunk.AppendIntervalIndex(outChunk.Len() - r.buf.Len())
}

func (r *{{.Name}}Col{{.Name}}HeapIterator) appendCurrItem(
	inChunk, outChunk Chunk, start int,
) {
	for j := range r.buf.items {
        outChunk.AppendTime(r.buf.items[j].time)
        outChunk.Column(r.outOrdinal).Append{{.Name}}Values(r.buf.items[j].value)
        outChunk.Column(r.outOrdinal).AppendNilsV2(true)
    }
    if len(r.auxProcessor) > 0 {
        for i := range r.buf.items {
            r.currBufIndex = append(r.currBufIndex, r.buf.items[i].index+start-r.prevMaxIndex)
        }
        hybridqp.SortS1ByS2(r.windowIndex, r.currBufIndex)
        for j := range r.auxProcessor {
            r.auxProcessor[j].auxHelperFunc(
                inChunk.Column(r.auxProcessor[j].inOrdinal),
                outChunk.Column(r.auxProcessor[j].outOrdinal),
                r.windowIndex...,
            )
        }
        r.windowIndex = r.windowIndex[:0]
        r.currBufIndex = r.currBufIndex[:0]
    }
    outChunk.AppendIntervalIndex(outChunk.Len() - r.buf.Len())
}


func (r *{{.Name}}Col{{.Name}}HeapIterator) updateAuxColInChunk(inChunk Chunk) {
	if len(r.interBufIndex) == 0 {
        r.auxChunk.Reset()
    }
    // inserts elements pushed from the heap
    r.currBufIndex = r.currBufIndex[:0]
    for i := range r.buf.items {
        r.currBufIndex = append(r.currBufIndex, r.buf.items[i].index-r.prevMaxIndex)
    }
    hybridqp.SortS1ByS2(r.windowIndex, r.currBufIndex)

    for j := range r.auxProcessor {
        r.auxProcessor[j].auxHelperFunc(
            inChunk.Column(r.auxProcessor[j].inOrdinal),
            r.auxChunk.Column(r.auxProcessor[j].outOrdinal),
            r.windowIndex...,
        )
    }
}

func (r *{{.Name}}Col{{.Name}}HeapIterator) updateAuxColBothChunk(inChunk Chunk) {
	clone := r.auxChunk.Clone()
    r.auxChunk.Reset()
    sort.Ints(r.interBufIndex)

    r.currBufIndex = r.currBufIndex[:0]
    for i := range r.prevBufIndex {
        if hybridqp.BinarySearch(r.prevBufIndex[i], r.interBufIndex) {
            r.currBufIndex = append(r.currBufIndex, i)
        }
    }

    r.prevBufIndex = r.prevBufIndex[:0]
    for i := range r.buf.items {
        r.prevBufIndex = append(r.prevBufIndex, r.buf.items[i].index-r.prevMaxIndex)
    }
    hybridqp.SortS1ByS2(r.windowIndex, r.prevBufIndex)

    cs, ws := 0, 0
    for i := range r.buf.items {
        if hybridqp.BinarySearch(r.buf.items[i].index, r.interBufIndex) {
            // inserts elements still remained in the heap
            for j := range r.auxProcessor {
                r.auxProcessor[j].auxHelperFunc(
                    clone.Column(r.auxProcessor[j].outOrdinal),
                    r.auxChunk.Column(r.auxProcessor[j].outOrdinal),
                    r.currBufIndex[cs],
                )
            }
            cs++
        } else {
            // inserts elements pushed from the heap
            for j := range r.auxProcessor {
                r.auxProcessor[j].auxHelperFunc(
                    inChunk.Column(r.auxProcessor[j].inOrdinal),
                    r.auxChunk.Column(r.auxProcessor[j].outOrdinal),
                    r.windowIndex[ws],
                )
            }
            ws++
        }
    }
    clone.Reset()
}

func (r *{{.Name}}Col{{.Name}}HeapIterator) reset() {
    r.prevBufIndex = r.prevBufIndex[:0]
	r.currBufIndex = r.currBufIndex[:0]
	r.interBufIndex = r.interBufIndex[:0]
	r.windowIndex = r.windowIndex[:0]
	r.buf.sortByTime = false
}

func (r *{{.Name}}Col{{.Name}}HeapIterator) updatePrevItem(
	inChunk Chunk, start, end int,
) {
	if len(r.auxProcessor) == 0 {
        r.buf.append(inChunk, start, end, r.inOrdinal)
    } else {
        r.buf.sortByTime = true
        sort.Sort(r.buf)
        for i := range r.buf.items {
            r.prevBufIndex = append(r.prevBufIndex, r.buf.items[i].index)
        }
        r.buf.sortByTime = false
        sort.Sort(r.buf)
        r.prevMaxIndex = r.buf.maxIndex + 1

        r.windowIndex = r.buf.appendForAux(inChunk, start, end, r.inOrdinal)

        r.buf.sortByTime = true
        sort.Sort(r.buf)

        for i := range r.buf.items {
            r.currBufIndex = append(r.currBufIndex, r.buf.items[i].index)
        }
        r.interBufIndex = hybridqp.Intersect(r.prevBufIndex, r.currBufIndex)

		if !hybridqp.IsSubSlice(r.prevBufIndex, r.currBufIndex) {
            r.updateAuxColBothChunk(inChunk)
        } else {
            r.updateAuxColInChunk(inChunk)
        }
    }
    r.reset()
}

func (r *{{.Name}}Col{{.Name}}HeapIterator) updateCurrItem(
	inChunk Chunk, start, end int,
) {
	if len(r.auxProcessor) == 0 {
        r.buf.append(inChunk, start, end, r.inOrdinal)
    } else {
        r.buf.sortByTime = true
        sort.Sort(r.buf)
        r.prevMaxIndex = r.buf.maxIndex + 1
        r.windowIndex = r.buf.appendForAux(inChunk, start, end, r.inOrdinal)
        for j := range r.auxProcessor {
            r.auxProcessor[j].auxHelperFunc(
                inChunk.Column(r.auxProcessor[j].inOrdinal),
                r.auxChunk.Column(r.auxProcessor[j].outOrdinal),
                r.windowIndex...,
            )
        }
        r.windowIndex = r.windowIndex[:0]
        r.currBufIndex = r.currBufIndex[:0]
        r.buf.sortByTime = false
    }
}

func (r *{{.Name}}Col{{.Name}}HeapIterator) processFirstWindow(
	inChunk, outChunk Chunk, sameInterval, hasMultiInterval bool, start, end int,
) {
	r.updatePrevItem(inChunk, start, end)
    if hasMultiInterval || !sameInterval {
        r.buf.sortByTime = true
        sort.Sort(r.buf)
        if r.buf.Len() > 0 {
            r.appendPrevItem(r.auxChunk, outChunk)
        }
        r.buf.Reset()
    }
}

func (r *{{.Name}}Col{{.Name}}HeapIterator) processLastWindow(
	inChunk Chunk, start, end int,
) {
	r.updateCurrItem(inChunk, start, end)
}

func (r *{{.Name}}Col{{.Name}}HeapIterator) processMiddleWindow(
	inChunk, outChunk Chunk, start, end int,
) {
	if len(r.auxProcessor) == 0 {
        r.buf.append(inChunk, start, end, r.inOrdinal)
    } else {
        r.prevMaxIndex = r.buf.maxIndex + 1
        r.windowIndex = r.buf.appendForAux(inChunk, start, end, r.inOrdinal)
    }
    r.buf.sortByTime = true
    sort.Sort(r.buf)
    if r.buf.Len() > 0 {
        r.appendCurrItem(inChunk, outChunk, start)
    }
    r.buf.Reset()
}

func (r *{{.Name}}Col{{.Name}}HeapIterator) Next(ie *IteratorEndpoint, p *IteratorParams) {
	inChunk, outChunk := ie.InputPoint.Chunk, ie.OutputPoint.Chunk
    if inChunk.Column(r.inOrdinal).IsEmpty() {
        return
    }

    var end int
    firstIndex, lastIndex := 0, len(inChunk.IntervalIndex())-1
    for i, start := range inChunk.IntervalIndex() {
        if i < lastIndex {
            end = inChunk.IntervalIndex()[i+1]
        } else {
            end = inChunk.NumberOfRows()
        }
        if i == firstIndex && r.buf.Len() > 0 {
            r.processFirstWindow(inChunk, outChunk, p.sameInterval,
                firstIndex != lastIndex, start, end)
        } else if i == lastIndex && p.sameInterval {
            r.processLastWindow(inChunk, start, end)
        } else {
            r.processMiddleWindow(inChunk, outChunk, start, end)
        }
    }
}
{{- end}}
{{end}}


{{range .}}
{{- if and (ne .Name "Boolean")}}
type {{.Name}}DistinctItem struct {
	m     map[{{.Type}}]struct{}
	time  []int64
	value []{{.Type}}
}

func New{{.Name}}DistinctItem() *{{.Name}}DistinctItem {
	return &{{.Name}}DistinctItem{
		m: make(map[{{.Type}}]struct{}),
	}
}

func (f *{{.Name}}DistinctItem) appendItem(time []int64, value []{{.Type}}) {
	for i := 0; i < len(time); i++ {
		if _, ok := f.m[value[i]]; !ok {
			f.m[value[i]] = struct{}{}
			f.time = append(f.time, time[i])
			f.value = append(f.value, value[i])
		}
	}
}

func (f *{{.Name}}DistinctItem) Nil() bool {
	return len(f.time) == 0
}

func (f *{{.Name}}DistinctItem) Reset() {
	for k := range f.m {
		delete(f.m, k)
	}
	f.time = f.time[:0]
	f.value = f.value[:0]
}

func (f *{{.Name}}DistinctItem) Len() int {
	return len(f.value)
}

func (f *{{.Name}}DistinctItem) Less(i, j int) bool {
	if f.time[i] != f.time[j] {
		return f.time[i] < f.time[j]
	}
	return f.value[i] < f.value[j]
}

func (f *{{.Name}}DistinctItem) Swap(i, j int) {
	f.time[i], f.time[j] = f.time[j], f.time[i]
	f.value[i], f.value[j] = f.value[j], f.value[i]
}
{{- end}}
{{end}}

type BooleanDistinctItem struct {
	m     map[bool]struct{}
	time  []int64
	value []bool
}

func NewBooleanDistinctItem() *BooleanDistinctItem {
	return &BooleanDistinctItem{
		m: make(map[bool]struct{}),
	}
}

func (f *BooleanDistinctItem) appendItem(time []int64, value []bool) {
	for i := 0; i < len(time); i++ {
		if _, ok := f.m[value[i]]; !ok {
			f.m[value[i]] = struct{}{}
			f.time = append(f.time, time[i])
			f.value = append(f.value, value[i])
		}
	}
}

func (f *BooleanDistinctItem) Nil() bool {
	return len(f.time) == 0
}

func (f *BooleanDistinctItem) Reset() {
	for k := range f.m {
		delete(f.m, k)
	}
	f.time = f.time[:0]
	f.value = f.value[:0]
}

func (f *BooleanDistinctItem) Len() int {
	return len(f.value)
}

func (f *BooleanDistinctItem) Less(i, j int) bool {
	if f.time[i] != f.time[j] {
		return f.time[i] < f.time[j]
	}
	return !f.value[i]
}

func (f *BooleanDistinctItem) Swap(i, j int) {
	f.time[i], f.time[j] = f.time[j], f.time[i]
	f.value[i], f.value[j] = f.value[j], f.value[i]
}

{{range .}}
type {{.Name}}Col{{.Name}}DistinctIterator struct {
	buf        *{{.Name}}DistinctItem
	inOrdinal  int
	outOrdinal int
	{{- if eq .Name "String"}}
	stringBuff []string
	{{- end}}
}

func New{{.Name}}Col{{.Name}}DistinctIterator(
    inOrdinal, outOrdinal int,
) *{{.Name}}Col{{.Name}}DistinctIterator {
	return &{{.Name}}Col{{.Name}}DistinctIterator{
		buf:        New{{.Name}}DistinctItem(),
		inOrdinal:  inOrdinal,
		outOrdinal: outOrdinal,
	}
}

func (r *{{.Name}}Col{{.Name}}DistinctIterator) processFirstWindow(
	inChunk, outChunk Chunk, sameInterval, hasMultiInterval bool, start, end int,
) {
    {{- if ne .Name "String"}}
    r.buf.appendItem(inChunk.Time()[start:end], inChunk.Column(r.inOrdinal).{{.Name}}Values()[start:end])
    {{- else}}
    r.buf.appendItem(inChunk.Time()[start:end], inChunk.Column(r.inOrdinal).StringValuesRange(r.stringBuff[:0], start, end))
    {{- end}}
	if hasMultiInterval || !sameInterval {
		sort.Sort(r.buf)
		if r.buf.Len() > 0 {
			for j := range r.buf.time {
				outChunk.AppendTime(r.buf.time[j])
				outChunk.Column(r.outOrdinal).Append{{.Name}}Values(r.buf.value[j])
				outChunk.Column(r.outOrdinal).AppendNilsV2(true)
			}
			outChunk.AppendIntervalIndex(outChunk.Len() - r.buf.Len())
		}
		r.buf.Reset()
	}
}

func (r *{{.Name}}Col{{.Name}}DistinctIterator) processLastWindow(
	inChunk Chunk, start, end int,
) {
    {{- if ne .Name "String"}}
    r.buf.appendItem(inChunk.Time()[start:end], inChunk.Column(r.inOrdinal).{{.Name}}Values()[start:end])
    {{- else}}
    r.buf.appendItem(inChunk.Time()[start:end], inChunk.Column(r.inOrdinal).StringValuesRange(r.stringBuff[:0], start, end))
    {{- end}}
}

func (r *{{.Name}}Col{{.Name}}DistinctIterator) processMiddleWindow(
	inChunk, outChunk Chunk, start, end int,
) {
    {{- if ne .Name "String"}}
    r.buf.appendItem(inChunk.Time()[start:end], inChunk.Column(r.inOrdinal).{{.Name}}Values()[start:end])
    {{- else}}
    r.buf.appendItem(inChunk.Time()[start:end], inChunk.Column(r.inOrdinal).StringValuesRange(r.stringBuff[:0], start, end))
    {{- end}}
	sort.Sort(r.buf)
	if r.buf.Len() > 0 {
		for j := range r.buf.time {
			outChunk.AppendTime(r.buf.time[j])
			outChunk.Column(r.outOrdinal).Append{{.Name}}Values(r.buf.value[j])
			outChunk.Column(r.outOrdinal).AppendNilsV2(true)
		}
		outChunk.AppendIntervalIndex(outChunk.Len() - r.buf.Len())
	}
	r.buf.Reset()
}

func (r *{{.Name}}Col{{.Name}}DistinctIterator) Next(ie *IteratorEndpoint, p *IteratorParams) {
	inChunk, outChunk := ie.InputPoint.Chunk, ie.OutputPoint.Chunk
	if inChunk.Column(r.inOrdinal).IsEmpty() {
		return
	}

	var end int
	firstIndex, lastIndex := 0, len(inChunk.IntervalIndex())-1
	for i, start := range inChunk.IntervalIndex() {
		if i < lastIndex {
			end = inChunk.IntervalIndex()[i+1]
		} else {
			end = inChunk.NumberOfRows()
		}

		if i == firstIndex && !r.buf.Nil() {
			r.processFirstWindow(inChunk, outChunk, p.sameInterval,
				firstIndex != lastIndex, start, end)
		} else if i == lastIndex && p.sameInterval {
			r.processLastWindow(inChunk, start, end)
		} else {
			r.processMiddleWindow(inChunk, outChunk, start, end)
		}
	}
}
{{end}}

type TransItem interface {
	AppendItem(Chunk, int, int, int, bool)
	Reset()
	Len() int
	PrevNil() bool
	ResetPrev()
	GetBaseTransData() BaseTransData
}

type BaseTransData struct{
    time          []int64
    floatValue    []float64
    integerValue  []int64
    nils          []bool
}

{{range .}}
{{- if and (ne .Name "String") (ne .Name "Boolean")}}
type {{.name}}Difference func(prev, curr {{.Type}}) {{.Type}}

type {{.Name}}DifferenceItem struct {
	isNonNegative bool
	diff          func(prev, curr {{.Type}}) {{.Type}}
	prev          *{{.Name}}Point
	times         []int64
	values        []{{.Type}}
	nils          []bool
}

func New{{.Name}}DifferenceItem(isNonNegative bool, diff {{.name}}Difference) *{{.Name}}DifferenceItem {
	return &{{.Name}}DifferenceItem{isNonNegative: isNonNegative, diff: diff, prev: new{{.Name}}Point()}
}

func (f *{{.Name}}DifferenceItem) diffComputeFast(prevValue, currValue {{.Type}}, currTime int64) {
	if dv := f.diff(prevValue, currValue); !f.isNonNegative || (f.isNonNegative && dv >= 0) {
		f.times = append(f.times, currTime)
		f.values = append(f.values, dv)
		f.nils = append(f.nils, false)
	} else {
		f.times = append(f.times, currTime)
		f.values = append(f.values, 0)
		f.nils = append(f.nils, true)
	}
}

func (f *{{.Name}}DifferenceItem) AppendItemFastFunc(c Chunk, ordinal int, start, end int, sameInterval bool) {
	// fast path
	var st int64
	var si int
	col := c.Column(ordinal)
	times := c.Time()[start:end]
	values := col.{{.Name}}Values()[start:end]

	// calculate diff for middle points
	for i := 0; i < len(times); i++ {
		if i == 0 {
			if f.prev.isNil {
				st, si = times[0], 0
			} else if f.prev.time != times[0] {
				f.diffComputeFast(f.prev.value, values[0], times[0])
				st, si = times[0], 0
			} else if f.prev.time == times[0] {
				st, si = f.prev.time, -1
			}
			continue
		}

		if st == times[i] {
			continue
		}

		if si == -1 {
			f.diffComputeFast(f.prev.value, values[i], times[i])
		} else {
			f.diffComputeFast(values[si], values[i], times[i])
		}
		st, si = times[i], i
	}

	// process the last point
	if sameInterval {
		if si >= 0 {
			f.prev.Set(end, times[si], values[si])
		}
	} else {
		f.prev.Reset()
	}
}

func (f *{{.Name}}DifferenceItem) doNullWindow(times []int64, sameInterval bool) {
	var st int64
	for i, t := range times {
		if i == 0 {
			if !f.prev.isNil {
				f.times = append(f.times, times[0])
				f.values = append(f.values, 0)
				f.nils = append(f.nils, true)
			}
			st = t
			continue
		}
		if st == t {
			continue
		}
		f.times = append(f.times, times[i])
		f.values = append(f.values, 0)
		f.nils = append(f.nils, true)
		st = t
	}

	if !sameInterval {
		f.prev.Reset()
	}
}

func (f *{{.Name}}DifferenceItem) diffComputeSlow(prevValue, currValue {{.Type}}, currTime int64) {
	if dv := f.diff(prevValue, currValue); !f.isNonNegative || (f.isNonNegative && dv >= 0) {
		f.times = append(f.times, currTime)
		f.values = append(f.values, dv)
		f.nils = append(f.nils, false)
	} else if f.isNonNegative && dv < 0 {
		f.times = append(f.times, currTime)
		f.values = append(f.values, 0)
		f.nils = append(f.nils, true)
	}
}

func (f *{{.Name}}DifferenceItem) AppendItemSlowFunc(c Chunk, ordinal int, start, end int, sameInterval bool) {
	// slow path
	col := c.Column(ordinal)
	times := c.Time()[start:end]
	vs, ve := col.GetRangeValueIndexV2(start, end)
	if vs == ve {
		f.doNullWindow(times, sameInterval)
		return
	}

	// calculate diff for middle points
	var vos int
	for i := start; i < end; i++ {
		isNil := col.IsNilV2(i)
		t := c.TimeByIndex(i)
		if isNil && (f.prev.isNil || (i < end-1 && t == c.TimeByIndex(i+1))) {
			continue
		}
		if i > 0 && !f.prev.isNil && f.prev.time == t {
			if !isNil {
				vos++
			}
			continue
		}
		if isNil {
			f.times = append(f.times, t)
			f.values = append(f.values, 0)
			f.nils = append(f.nils, true)
			continue
		}
		v := col.{{.Name}}Value(vs + vos)
		vos++
		if f.prev.isNil {
			f.prev.Set(i, t, v)
			continue
		}
		f.diffComputeSlow(f.prev.value, v, t)
		f.prev.Set(i, t, v)
	}

	// process the last point
	if !sameInterval {
		f.prev.Reset()
	}
}

func (f *{{.Name}}DifferenceItem) AppendItem(c Chunk, ordinal int, start, end int, sameInterval bool) {
	if c.Column(ordinal).NilCount() == 0 {
		f.AppendItemFastFunc(c, ordinal, start, end, sameInterval)
		return
	}
	f.AppendItemSlowFunc(c, ordinal, start, end, sameInterval)
}

func (f *{{.Name}}DifferenceItem) Reset() {
	f.times = f.times[:0]
	f.values = f.values[:0]
	f.nils = f.nils[:0]
}

func (f *{{.Name}}DifferenceItem) Len() int {
	return len(f.times)
}

func (f *{{.Name}}DifferenceItem) PrevNil() bool {
	return f.prev.isNil
}

func (f *{{.Name}}DifferenceItem) ResetPrev() {
	f.prev.Reset()
}

func (f *{{.Name}}DifferenceItem) GetBaseTransData() BaseTransData {
	return BaseTransData{time: f.times, {{.name}}Value: f.values, nils: f.nils}
}
{{- end}}
{{end}}

{{range .}}
{{- if and (ne .Name "String") (ne .Name "Boolean")}}
type {{.Name}}DerivativeItem struct {
	isNonNegative bool
	ascending     bool
	prev          *{{.Name}}Point
	times         []int64
	values        []float64
	nils          []bool
	interval      hybridqp.Interval
}

func New{{.Name}}DerivativeItem(isNonNegative, ascending bool, interval hybridqp.Interval) *{{.Name}}DerivativeItem {
	return &{{.Name}}DerivativeItem{
		isNonNegative: isNonNegative, ascending: ascending, interval: interval, prev: new{{.Name}}Point(),
	}
}

func (f *{{.Name}}DerivativeItem) derivativeComputeFast(prevValue, currValue {{.Type}}, prevTime, currTime int64) {
	if diff, elapsed := float64(currValue-prevValue), currTime-prevTime; !f.isNonNegative || (f.isNonNegative && diff >= 0) {
		if !f.ascending {
			elapsed = -elapsed
		}
		v := diff / (float64(elapsed) / float64(f.interval.Duration))
		f.times = append(f.times, currTime)
		f.values = append(f.values, v)
		f.nils = append(f.nils, false)
	} else {
		f.times = append(f.times, currTime)
		f.values = append(f.values, 0)
		f.nils = append(f.nils, true)
	}
}

func (f *{{.Name}}DerivativeItem) AppendItemFastFunc(c Chunk, ordinal int, start, end int, sameInterval bool) {
	// fast path
	var st int64
	var si int
	col := c.Column(ordinal)
	times := c.Time()[start:end]
	values := col.{{.Name}}Values()[start:end]

	// calculate diff for middle points
	for i := 0; i < len(times); i++ {
		if i == 0 {
			if f.prev.isNil {
				st, si = times[0], 0
			} else if f.prev.time != times[0] {
				f.derivativeComputeFast(f.prev.value, values[0], f.prev.time, times[0])
				st, si = times[0], 0
			} else if f.prev.time == times[0] {
				st, si = f.prev.time, -1
			}
			continue
		}

		if st == times[i] {
			continue
		}
		if si == -1 {
			f.derivativeComputeFast(f.prev.value, values[i], f.prev.time, times[i])
		} else {
			f.derivativeComputeFast(values[si], values[i], times[si], times[i])
		}
		st, si = times[i], i
	}

	// process the last point
	if sameInterval {
		if si >= 0 {
			f.prev.Set(end, times[si], values[si])
		}
	} else {
		f.prev.Reset()
	}
}

func (f *{{.Name}}DerivativeItem) doNullWindow(times []int64, sameInterval bool) {
	var st int64
	for i, t := range times {
		if i == 0 {
			if !f.prev.isNil {
				f.times = append(f.times, times[0])
				f.values = append(f.values, 0)
				f.nils = append(f.nils, true)
			}
			st = t
			continue
		}
		if st == t {
			continue
		}
		f.times = append(f.times, times[i])
		f.values = append(f.values, 0)
		f.nils = append(f.nils, true)
		st = t
	}

	if !sameInterval {
		f.prev.Reset()
	}
}

func (f *{{.Name}}DerivativeItem) derivativeComputeSlow(prevValue, currValue {{.Type}}, prevTime, currTime int64) {
	if diff, elapsed := float64(currValue-prevValue), currTime-prevTime; !f.isNonNegative || (f.isNonNegative && diff >= 0) {
		if !f.ascending {
			elapsed = -elapsed
		}
		v := diff / (float64(elapsed) / float64(f.interval.Duration))
		f.times = append(f.times, currTime)
		f.values = append(f.values, v)
		f.nils = append(f.nils, false)
	} else if f.isNonNegative && diff < 0 {
		f.times = append(f.times, currTime)
		f.values = append(f.values, 0)
		f.nils = append(f.nils, true)
	}
}

func (f *{{.Name}}DerivativeItem) AppendItemSlowFunc(c Chunk, ordinal int, start, end int, sameInterval bool) {
	// slow path
	col := c.Column(ordinal)
	times := c.Time()[start:end]
	vs, ve := col.GetRangeValueIndexV2(start, end)
	if vs == ve {
		f.doNullWindow(times, sameInterval)
		return
	}

	// calculate diff for middle points
	var vos int
	for i := start; i < end; i++ {
		isNil := col.IsNilV2(i)
		t := c.TimeByIndex(i)
		if isNil && (f.prev.isNil || (i < end-1 && t == c.TimeByIndex(i+1))) {
			continue
		}
		if i > 0 && !f.prev.isNil && f.prev.time == t {
			if !isNil {
				vos++
			}
			continue
		}
		if isNil {
			f.times = append(f.times, t)
			f.values = append(f.values, 0)
			f.nils = append(f.nils, true)
			continue
		}
		v := col.{{.Name}}Value(vs + vos)
		vos++
		if f.prev.isNil {
			f.prev.Set(i, t, v)
			continue
		}
		f.derivativeComputeSlow(f.prev.value, v, f.prev.time, t)
		f.prev.Set(i, t, v)
	}

	// process the last point
	if !sameInterval {
		f.prev.Reset()
	}
}

func (f *{{.Name}}DerivativeItem) AppendItem(c Chunk, ordinal int, start, end int, sameInterval bool) {
	if c.Column(ordinal).NilCount() == 0 {
		f.AppendItemFastFunc(c, ordinal, start, end, sameInterval)
		return
	}
	f.AppendItemSlowFunc(c, ordinal, start, end, sameInterval)
}

func (f *{{.Name}}DerivativeItem) Reset() {
	f.times = f.times[:0]
	f.values = f.values[:0]
	f.nils = f.nils[:0]
}

func (f *{{.Name}}DerivativeItem) Len() int {
	return len(f.times)
}

func (f *{{.Name}}DerivativeItem) PrevNil() bool {
	return f.prev.isNil
}

func (f *{{.Name}}DerivativeItem) ResetPrev() {
	f.prev.Reset()
}

func (f *{{.Name}}DerivativeItem) GetBaseTransData() BaseTransData {
	return BaseTransData{time: f.times, floatValue: f.values, nils: f.nils}
}
{{- end}}
{{end}}

func linearFloat(windowTime, previousTime, nextTime int64, previousValue, nextValue float64) float64 {
	m := (nextValue - previousValue) / float64(nextTime-previousTime) // the slope of the line
	x := float64(windowTime - previousTime)                           // how far into the interval we are
	b := previousValue
	return m*x + b
}

{{range .}}
{{- if and (ne .Name "String") (ne .Name "Boolean")}}
type {{.Name}}IntegralItem struct {
    sameTag       bool
    sameInterval  bool
    pointNum      int
    sum           float64
    window        struct {
        start     int64
        end       int64
    }
	prev          *FloatPoint
	time          []int64
	value         []float64
	interval      hybridqp.Interval
	opt           query.ProcessorOptions
}

func New{{.Name}}IntegralItem(interval hybridqp.Interval, opt query.ProcessorOptions) *{{.Name}}IntegralItem {
	return &{{.Name}}IntegralItem{interval: interval, prev: newFloatPoint(), opt: opt, sameTag: false}
}

func (f *{{.Name}}IntegralItem) CalculateUnit(index int, time int64, value float64) {
	if f.prev.time == time {
		f.prev.Set(index, time, value)
	} else {
		f.sum += 0.5 * (value + f.prev.value) * float64(time-f.prev.time) / float64(f.interval.Duration)
		f.prev.Set(index, time, value)
	}
}

func (f *{{.Name}}IntegralItem) StartNewInterval(time int64){
	f.value = append(f.value, f.sum)
	if f.opt.Interval.IsZero() {
		f.time = append(f.time, 0)
	} else {
		f.time = append(f.time, f.window.start)
		if f.opt.Ascending {
			f.window.start, f.window.end = f.opt.Window(time)
		} else {
			f.window.end, f.window.start = f.opt.Window(time)
		}
	}
	f.sum = 0.0
}

func (f *{{.Name}}IntegralItem) doNullWindow(sameInterval, sameTag bool) {
	if !f.sameTag {
	    if f.pointNum > 1{
            f.value = append(f.value, f.sum)
            if f.opt.Interval.IsZero() {
                f.time = append(f.time, 0)
            } else {
                f.time = append(f.time, f.window.start)
            }
		}
		f.sum = 0.0
		f.pointNum = 0
	} else {
		f.sameInterval = sameInterval
		f.sameTag = sameTag
	}
}

func (f *{{.Name}}IntegralItem) AppendItemFastFunc(c Chunk, ordinal int, start, end int, sameInterval bool, sameTag bool) {
	// fast path
	col := c.Column(ordinal)
	time := c.Time()[start:end]
	value := col.{{.Name}}Values()[start:end]

	// process the first point
	if f.prev.isNil {
		f.prev.Set(0, time[0], float64(value[0]))
		if !f.opt.Interval.IsZero() {
			if f.opt.Ascending {
				f.window.start, f.window.end = f.opt.Window(time[0])
			} else {
				f.window.end, f.window.start = f.opt.Window(time[0])
			}
		}
	} else {
		// process the last point of front window and the first point of this window
		if !f.sameTag { // not sametag
			if !(f.pointNum == 1 && f.prev.time == f.window.start) && !(f.pointNum == 0){
                f.StartNewInterval(time[0])
            } else {
                if !f.opt.Interval.IsZero() {
                    if f.opt.Ascending {
                        f.window.start, f.window.end = f.opt.Window(time[0])
                    } else {
                        f.window.end, f.window.start = f.opt.Window(time[0])
                    }
                }
                f.sum = 0.0
            }
            f.prev.Set(0, time[0], float64(value[0]))
		} else if !f.sameInterval {// sametag not sameinterval
			if f.prev.time != f.window.end && !f.opt.Interval.IsZero() {
				value := linearFloat(f.window.end, f.prev.time, time[0], f.prev.value, float64(value[0]))
				f.sum += 0.5 * (value + f.prev.value) * float64(f.window.end-f.prev.time) / float64(f.interval.Duration)

				f.prev.value = value
				f.prev.time = f.window.end
			}
			f.StartNewInterval(time[0])
            f.CalculateUnit(0, time[0], float64(value[0]))
		} else { // sametag sameinterval
			f.CalculateUnit(0, time[0], float64(value[0]))
		}
	}
	// process the rest ponints
	for i := 1; i < len(time); i++ {
		f.CalculateUnit(i, time[i], float64(value[i]))
	}
	f.pointNum = end-start
	f.sameTag = sameTag
	f.sameInterval = sameInterval
}

func (f *{{.Name}}IntegralItem) AppendItemSlowFunc(c Chunk, ordinal int, vs, ve int, sameInterval, sameTag bool) {
	// slow path
	col := c.Column(ordinal)
    getTimeIndex := col.GetTimeIndex
    if vs == ve {
        f.doNullWindow(sameInterval, sameTag)
        return
    }

	// process the first point
	if f.prev.isNil {
		f.prev.Set(0, c.TimeByIndex(getTimeIndex(vs)), float64(col.{{.Name}}Values()[vs]))
		if !f.opt.Interval.IsZero() {
			if f.opt.Ascending {
				f.window.start, f.window.end = f.opt.Window(c.TimeByIndex(getTimeIndex(vs)))
			} else {
				f.window.end, f.window.start = f.opt.Window(c.TimeByIndex(getTimeIndex(vs)))
			}
		}
	} else {
	    // process the last point of front window and the first point of this window
		if !f.sameTag {
		    if !(f.pointNum == 1 && f.prev.time == f.window.start) && !(f.pointNum == 0) {
                f.StartNewInterval(c.TimeByIndex(getTimeIndex(vs)))
            } else {
                if !f.opt.Interval.IsZero() {
                    if f.opt.Ascending {
                        f.window.start, f.window.end = f.opt.Window(c.TimeByIndex(getTimeIndex(vs)))
                    } else {
                        f.window.end, f.window.start = f.opt.Window(c.TimeByIndex(getTimeIndex(vs)))
                    }
                }
                f.sum = 0.0
            }
            f.prev.Set(0, c.TimeByIndex(getTimeIndex(vs)), float64(col.{{.Name}}Values()[vs]))
		} else if !f.sameInterval {
			if f.prev.time != f.window.end && !f.opt.Interval.IsZero() {
				value := linearFloat(f.window.end, f.prev.time, c.TimeByIndex(getTimeIndex(vs)), f.prev.value, float64(col.{{.Name}}Values()[vs]))
				f.sum += 0.5 * (value + f.prev.value) * float64(f.window.end-f.prev.time) / float64(f.interval.Duration)

				f.prev.value = value
				f.prev.time = f.window.end
			}
			f.StartNewInterval(c.TimeByIndex(getTimeIndex(vs)))
			f.CalculateUnit(0, c.TimeByIndex(getTimeIndex(vs)), float64(col.{{.Name}}Values()[vs]))
		} else {
			f.CalculateUnit(0, c.TimeByIndex(getTimeIndex(vs)), float64(col.{{.Name}}Values()[vs]))
		}
	}
	// process the rest ponints
	for i := vs + 1; i < ve; i++ {
        f.CalculateUnit(i-vs, c.TimeByIndex(getTimeIndex(i)), float64(col.{{.Name}}Values()[i]))
	}
	f.pointNum = ve-vs
	f.sameTag = sameTag
	f.sameInterval = sameInterval
}

func (f *{{.Name}}IntegralItem) AppendItem(c Chunk, ordinal int, start, end int, sameInterval, sameTag bool) {
	if c.Column(ordinal).NilCount() == 0 {
		f.AppendItemFastFunc(c, ordinal, start, end, sameInterval, sameTag)
		return
	}
	f.AppendItemSlowFunc(c, ordinal, start, end, sameInterval, sameTag)
}

func (f *{{.Name}}IntegralItem) Reset() {
	f.time = f.time[:0]
	f.value = f.value[:0]
}

func (f *{{.Name}}IntegralItem) Len() int {
	return len(f.time)
}

func (f *{{.Name}}IntegralItem) Nil() bool {
	return f.prev.isNil
}
{{- end}}
{{end}}

{{range .}}
{{- if and (ne .Name "String") (ne .Name "Boolean")}}
type {{.Name}}ColFloatIntegralIterator struct {
	isSingleCall bool
	inOrdinal    int
	outOrdinal   int
	nilCount     int
	buf          *{{.Name}}IntegralItem
}

func New{{.Name}}ColFloatIntegralIterator(
	isSingleCall bool, inOrdinal, outOrdinal int, rowDataType hybridqp.RowDataType, interval hybridqp.Interval,
	opt query.ProcessorOptions,
) *{{.Name}}ColFloatIntegralIterator {
	r := &{{.Name}}ColFloatIntegralIterator{
		buf:          New{{.Name}}IntegralItem(interval, opt),
		isSingleCall: isSingleCall,
		inOrdinal:    inOrdinal,
		outOrdinal:   outOrdinal,
		nilCount:     0,
	}
	return r
}

func (r *{{.Name}}ColFloatIntegralIterator) processFirstWindow(
	inChunk Chunk, haveMultiInterval, sameInterval, sameTag bool, start, end int,
) {
	if haveMultiInterval {
		r.buf.AppendItem(inChunk, r.inOrdinal, start, end, false, sameTag)
	} else {
		r.buf.AppendItem(inChunk, r.inOrdinal, start, end, sameInterval, sameTag)
	}
	if !sameTag && (end-start) == 1 && r.buf.prev.time == r.buf.window.start {
		r.nilCount++
	}
}

func (r *{{.Name}}ColFloatIntegralIterator) processLastWindow(
	inChunk, outChunk Chunk, start, end, tagIdx int,
) {
	r.buf.AppendItem(inChunk, r.inOrdinal, start, end, true, true)
	if r.buf.Len() > 0 {
		r.appendPrevItem(inChunk, outChunk, tagIdx)
		r.buf.Reset()
		if !r.isSingleCall {
			outChunk.Column(r.outOrdinal).AppendManyNil(r.nilCount)
			r.nilCount = 0
		}
	}
}

func (r *{{.Name}}ColFloatIntegralIterator) processMiddleWindow(
	inChunk, outChunk Chunk, start, end, tagIdx int, sameTag bool,
) {
	r.buf.AppendItem(inChunk, r.inOrdinal, start, end, false, sameTag)
	if !sameTag && (end-start) == 1 && r.buf.prev.time == r.buf.window.start {
		r.nilCount++
	}
	if r.buf.Len() > 0 {
		r.appendPrevItem(inChunk, outChunk, tagIdx)
		r.buf.Reset()
		if !r.isSingleCall {
			outChunk.Column(r.outOrdinal).AppendManyNil(r.nilCount)
			r.nilCount = 0
		}
	}
}

func (r *{{.Name}}ColFloatIntegralIterator) appendPrevItem(
	inChunk, outChunk Chunk, tagIdx int,
) {
	if r.isSingleCall {
		for j := range r.buf.time {
			outChunk.AppendTime(r.buf.time[j])
			outChunk.Column(r.outOrdinal).AppendFloatValues(r.buf.value[j])
			outChunk.Column(r.outOrdinal).AppendNilsV2(true)
		}
		outChunk.AppendIntervalIndex(outChunk.Len()-r.buf.Len())
		if !(outChunk.TagLen() > 0 && bytes.Equal(inChunk.Tags()[tagIdx].Subset(r.buf.opt.Dimensions),
			outChunk.Tags()[outChunk.TagLen()-1].Subset(r.buf.opt.Dimensions))) {
			outChunk.AppendTagsAndIndex(inChunk.Tags()[tagIdx], outChunk.IntervalIndex()[outChunk.IntervalLen()-1])
		}
		return
	}

	for j := range r.buf.time {
		outChunk.Column(r.outOrdinal).AppendFloatValues(r.buf.value[j])
		outChunk.Column(r.outOrdinal).AppendNilsV2(true)
	}
}

func (r *{{.Name}}ColFloatIntegralIterator) appendLastItem(
	inChunk, outChunk Chunk, tagIdx int,
) {
	if r.isSingleCall {
		if r.buf.opt.Interval.IsZero() {
			outChunk.AppendTime(0)
		} else {
			outChunk.AppendTime(r.buf.window.start)
		}
		outChunk.Column(r.outOrdinal).AppendFloatValues(r.buf.sum)
		outChunk.Column(r.outOrdinal).AppendNilsV2(true)
		outChunk.AppendIntervalIndex(outChunk.Len()-1)
		if !(outChunk.TagLen() > 0 && bytes.Equal(inChunk.Tags()[tagIdx].Subset(r.buf.opt.Dimensions),
			outChunk.Tags()[outChunk.TagLen()-1].Subset(r.buf.opt.Dimensions))) {
			outChunk.AppendTagsAndIndex(inChunk.Tags()[tagIdx], outChunk.IntervalIndex()[outChunk.IntervalLen()-1])
		}
		return
	}

	outChunk.Column(r.outOrdinal).AppendFloatValues(r.buf.sum)
	outChunk.Column(r.outOrdinal).AppendNilsV2(true)
}

func (r *{{.Name}}ColFloatIntegralIterator) Next(ie *IteratorEndpoint, p *IteratorParams) {
	inChunk, outChunk := ie.InputPoint.Chunk, ie.OutputPoint.Chunk
	if inChunk.Column(r.inOrdinal).IsEmpty() && r.buf.Len() > 0 {
		return
	}

	var start, end int
	firstIndex, lastIndex := 0, len(inChunk.IntervalIndex())-1
	lastTagIndex := len(inChunk.TagIndex()) - 1
	intervali := 0
	var subIntervalIndexEnd int
	for i, _ := range inChunk.TagIndex() {
		if i == lastTagIndex {
			subIntervalIndexEnd = inChunk.NumberOfRows()
		} else {
			subIntervalIndexEnd = inChunk.TagIndex()[i+1]
		}
		for inChunk.IntervalIndex()[intervali] < subIntervalIndexEnd {
			start = inChunk.IntervalIndex()[intervali]
			if intervali < lastIndex {
				end = inChunk.IntervalIndex()[intervali+1]
			} else {
				end = subIntervalIndexEnd
			}
			var sametag bool
			if end == inChunk.NumberOfRows() {
				sametag = !(end == subIntervalIndexEnd) || p.sameTag
			} else {
				sametag = !(end == subIntervalIndexEnd)
			}
			if !r.isSingleCall {
				start, end = inChunk.Column(r.inOrdinal).GetRangeValueIndexV2(start, end)
				if start == end {
					if r.buf.Nil() {
						outChunk.Column(r.outOrdinal).AppendNilsV2(false)
						intervali++
						if intervali >= len(inChunk.IntervalIndex()) {
							break
						}
						continue
					} else {
						r.nilCount++
					}
				}
			}
			if intervali == firstIndex && r.buf.sameInterval {
				r.processFirstWindow(inChunk, firstIndex != lastIndex, p.sameInterval, sametag, start, end)
			} else if intervali == lastIndex && p.sameInterval {
				r.processLastWindow(inChunk, outChunk, start, end, i)
			} else {
				r.processMiddleWindow(inChunk, outChunk, start, end, i, sametag)
			}
			intervali++
			if intervali >= len(inChunk.IntervalIndex()) {
				break
			}
		}
	}
	if p.lastChunk {
		if !(r.buf.pointNum == 1 && r.buf.prev.time == r.buf.window.start) && !(r.buf.pointNum == 0) {
			r.appendLastItem(inChunk, outChunk, inChunk.TagLen()-1)
		}
		if !r.isSingleCall {
			outChunk.Column(r.outOrdinal).AppendManyNil(r.nilCount)
			r.nilCount = 0
		}
	}
}
{{- end}}
{{end}}

type ElapsedItem struct {
	prev     int64
	time     []int64
	nils     []bool
	value    []int64
	interval hybridqp.Interval
}

func NewElapsedItem(interval hybridqp.Interval) *ElapsedItem {
	return &ElapsedItem{
		interval: interval, prev: -1,
	}
}

func (f *ElapsedItem) AppendItemFastFunc(c Chunk, _ int, start, end int, sameInterval bool) {
	// fast path
	time := c.Time()[start:end]

	// process the first point
	if f.prev > 0 {
		elapsed := time[0] - f.prev
		v := elapsed / int64(f.interval.Duration)
		f.time = append(f.time, time[0])
		f.value = append(f.value, v)
		f.nils = append(f.nils, false)
	}

	// calculate diff for middle points
	for i := 1; i < len(time); i++ {
		elapsed := time[i] - time[i-1]
		v := elapsed / int64(f.interval.Duration)
		f.time = append(f.time, time[i])
		f.value = append(f.value, v)
		f.nils = append(f.nils, false)
	}

	// process the last point
	if sameInterval {
		f.prev = time[len(time)-1]
	} else {
		f.prev = -1
	}
}

func (f *ElapsedItem) doNullWindow(time []int64, sameInterval bool) {
	if f.prev == -1 {
		f.time = append(f.time, time[1:]...)
		f.value = append(f.value, make([]int64, len(time)-1)...)
		f.nils = append(f.nils, make([]bool, len(time)-1)...)
        for i := len(f.nils) - 1; i >= (len(f.nils)-len(time)+1); i-- {
            f.nils[i] = true
        }
	} else {
		f.time = append(f.time, time...)
		f.value = append(f.value, make([]int64, len(time))...)
		f.nils = append(f.nils, make([]bool, len(time))...)
        for i := len(f.nils) - 1; i >= (len(f.nils)-len(time)); i-- {
            f.nils[i] = true
        }
	}

	if !sameInterval {
		f.prev = -1
	}
}

func (f *ElapsedItem) AppendItemSlowFunc(c Chunk, ordinal int, start, end int, sameInterval bool) {
	// slow path
	col := c.Column(ordinal)
	time := c.Time()[start:end]
	vs, ve := col.GetRangeValueIndexV2(start, end)
	if vs == ve {
		f.doNullWindow(time, sameInterval)
		return
	}

	// calculate diff for middle points
	for i := start; i < end; i++ {
		t := c.TimeByIndex(i)
		if col.IsNilV2(i) {
			f.time = append(f.time, t)
			f.value = append(f.value, 0)
			f.nils = append(f.nils, true)
			continue
		}

		if f.prev == -1 {
			f.prev = t
			continue
		}
		elapsed := t - f.prev
		v := elapsed / int64(f.interval.Duration)
		f.time = append(f.time, t)
		f.value = append(f.value, v)
		f.nils = append(f.nils, false)
		f.prev = t
	}

	// process the last point
	if !sameInterval {
		f.prev = -1
	}
}

func (f *ElapsedItem) AppendItem(c Chunk, ordinal int, start, end int, sameInterval bool) {
	if c.Column(ordinal).NilCount() == 0 {
		f.AppendItemFastFunc(c, ordinal, start, end, sameInterval)
		return
	}
	f.AppendItemSlowFunc(c, ordinal, start, end, sameInterval)
}

func (f *ElapsedItem) Reset() {
	f.time = f.time[:0]
	f.value = f.value[:0]
	f.nils = f.nils[:0]
}

func (f *ElapsedItem) Len() int {
	return len(f.time)
}

func (f *ElapsedItem) PrevNil() bool {
	return f.prev == -1
}

func (f *ElapsedItem) ResetPrev() {
	f.prev = -1
}

func (f *ElapsedItem) GetBaseTransData() BaseTransData {
    return BaseTransData{time: f.time, integerValue: f.value, nils:f.nils}
}

{{range .}}
{{- if and (ne .Name "String") (ne .Name "Boolean")}}
type {{.Name}}MovingAverageItem struct {
	window []{{.Name}}Point
	cur    int
	pos    int
	sum    {{.Type}}
	time   []int64
	value  []float64
	nils   []bool
	n      int
}

func New{{.Name}}MovingAverageItem(n int) *{{.Name}}MovingAverageItem {
	return &{{.Name}}MovingAverageItem{window: make([]{{.Name}}Point, 0, n), pos: 0, cur: 0, sum: 0, n: n}
}

func (f *{{.Name}}MovingAverageItem) AppendItemFastFunc(c Chunk, ordinal int, start, end int, sameInterval bool) {
	// fast path
	col := c.Column(ordinal)
	time := c.Time()[start:end]
	value := col.{{.Name}}Values()[start:end]
	for i := 0; i < len(time); i++ {
	    f.cur += 1
		if len(f.window) == f.n {
			f.sum = f.sum - f.window[f.pos].value + value[i]
			f.window[f.pos] = {{.Name}}Point{time: time[i], value: value[i], isNil: false}
			f.pos = (f.pos + 1) % f.n
			{{- if eq .Name "Integer"}}
			f.value = append(f.value, float64(f.sum)/float64(f.n))
			{{- else}}
			f.value = append(f.value, f.sum/float64(f.n))
			{{- end}}
			f.time = append(f.time, f.window[(f.pos+f.n-1)%f.n].time)
			f.nils = append(f.nils, false)
		} else if len(f.window) == f.n-1 {
			f.sum += value[i]
			f.window = append(f.window, {{.Name}}Point{time: time[i], value: value[i], isNil: false})
			{{- if eq .Name "Integer"}}
			f.value = append(f.value, float64(f.sum)/float64(f.n))
			{{- else}}
			f.value = append(f.value, f.sum/float64(f.n))
			{{- end}}
			f.time = append(f.time, f.window[(f.pos+f.n-1)%f.n].time)
			f.nils = append(f.nils, false)
		} else {
			f.sum += value[i]
			f.window = append(f.window, {{.Name}}Point{time: time[i], value: value[i], isNil: false})
			if(f.cur >= f.n){
			    f.nils = append(f.nils, true)
                f.time = append(f.time, time[0])
                f.value = append(f.value, 0)
			}
		}
	}
	if !sameInterval {
		f.ResetPrev()
	}
}

func (f *{{.Name}}MovingAverageItem) doNullWindow(time []int64, sameInterval bool) {
    if f.cur+1 >= f.n {
        nils := make([]bool, len(time))
        for i := 0; i < len(time); i++ {
            nils[i] = true
        }
        f.nils = append(f.nils, nils...)
        f.value = append(f.value, make([]float64, len(time))...)
        f.time = append(f.time, time...)
    } else {
        windowNeed := f.n - f.cur - 1
        if len(time)>windowNeed{
            nils := make([]bool, len(time)-windowNeed)
            for i := 0; i < len(time)-windowNeed; i++ {
                nils[i] = true
            }
            f.nils = append(f.nils, nils...)
            f.value = append(f.value, make([]float64, len(time)-windowNeed)...)
            f.time = append(f.time, time[windowNeed:]...)
        }
    }
    f.cur += len(time)
    if !sameInterval {
        f.ResetPrev()
    }
}

func (f *{{.Name}}MovingAverageItem) AppendItemSlowFunc(c Chunk, ordinal int, start, end int, sameInterval bool) {
	// slow path
	col := c.Column(ordinal)
	time := c.Time()[start:end]
	vs, ve := col.GetRangeValueIndexV2(start, end)
	if vs == ve {
		f.doNullWindow(time, sameInterval)
		return
	}

	var vos int
	for i := start; i < end; i++ {
	    f.cur += 1
		t := c.TimeByIndex(i)
		if col.IsNilV2(i) {
    		if f.cur>=f.n{
    		    f.time = append(f.time, t)
                f.value = append(f.value, 0)
                f.nils = append(f.nils, true)
    		}
            continue
        }

		v := col.{{.Name}}Value(vs + vos)
		vos++

		if len(f.window) == f.n {
			f.sum = f.sum - f.window[f.pos].value + v
			f.window[f.pos] = {{.Name}}Point{time: t, value: v, isNil: false}
			f.pos = (f.pos + 1) % f.n
			{{- if eq .Name "Integer"}}
			f.value = append(f.value, float64(f.sum)/float64(f.n))
			{{- else}}
			f.value = append(f.value, f.sum/float64(f.n))
			{{- end}}
			f.time = append(f.time, f.window[(f.pos+f.n-1)%f.n].time)
			f.nils = append(f.nils, false)
		} else if len(f.window) == f.n-1 {
			f.sum += v
			f.window = append(f.window, {{.Name}}Point{time: t, value: v, isNil: false})
			{{- if eq .Name "Integer"}}
			f.value = append(f.value, float64(f.sum)/float64(f.n))
			{{- else}}
			f.value = append(f.value, f.sum/float64(f.n))
			{{- end}}
			f.time = append(f.time, f.window[(f.pos+f.n-1)%f.n].time)
			f.nils = append(f.nils, false)
		} else {
			f.sum += v
			f.window = append(f.window, {{.Name}}Point{time: t, value: v, isNil: false})
			if f.cur >= f.n {
                f.nils = append(f.nils, true)
                f.time = append(f.time, t)
                f.value = append(f.value, 0)
            }
		}
	}
	if !sameInterval {
		f.ResetPrev()
	}
}

func (f *{{.Name}}MovingAverageItem) AppendItem(c Chunk, ordinal int, start, end int, sameInterval bool) {
	if c.Column(ordinal).NilCount() == 0 {
		f.AppendItemFastFunc(c, ordinal, start, end, sameInterval)
		return
	}
	f.AppendItemSlowFunc(c, ordinal, start, end, sameInterval)
}

func (f *{{.Name}}MovingAverageItem) Reset() {
	f.time = f.time[:0]
	f.value = f.value[:0]
	f.nils = f.nils[:0]
}

func (f *{{.Name}}MovingAverageItem) Len() int {
	return len(f.time)
}

func (f *{{.Name}}MovingAverageItem) PrevNil() bool {
	return len(f.window) == 0
}

func (f *{{.Name}}MovingAverageItem) ResetPrev() {
    f.window = f.window[:0]
    f.pos = 0
    f.sum = 0
    f.cur = 0
}

func (f *{{.Name}}MovingAverageItem) GetBaseTransData() BaseTransData {
    return BaseTransData{time: f.time, floatValue: f.value, nils:f.nils}
}
{{- end}}
{{end}}

{{range .}}
{{- if and (ne .Name "String") (ne .Name "Boolean")}}
type {{.Name}}CumulativeSumItem struct {
	sum           {{.Type}}
	time          []int64
	value         []{{.Type}}
	nils          []bool
}

func New{{.Name}}CumulativeSumItem() *{{.Name}}CumulativeSumItem {
	return &{{.Name}}CumulativeSumItem{sum: 0}
}

func (f *{{.Name}}CumulativeSumItem) AppendItemFastFunc(c Chunk, ordinal int, start, end int, sameInterval bool) {
	// fast path
	col := c.Column(ordinal)
	time := c.Time()[start:end]
	value := col.{{.Name}}Values()[start:end]

	for i := 0; i < len(time); i++ {
	    f.sum += value[i]
		f.time = append(f.time, time[i])
		f.value = append(f.value, f.sum)
        f.nils = append(f.nils, false)
	}

	if !sameInterval {
		f.sum = 0
	}
}

func (f *{{.Name}}CumulativeSumItem) doNullWindow(time []int64, sameInterval bool){
    f.time = append(f.time, time[:]...)
    f.value = append(f.value, make([]{{.Type}}, len(time))...)
    f.nils = append(f.nils, make([]bool,len(time))...)
    for i := len(f.nils)-1; i >= len(f.nils)-len(time); i--{
        f.nils[i] = true
    }
    if !sameInterval {
        f.sum = 0
    }
}

func (f *{{.Name}}CumulativeSumItem) AppendItemSlowFunc(c Chunk, ordinal int, start, end int, sameInterval bool) {
	// slow path
	col := c.Column(ordinal)
	time := c.Time()[start:end]
	vs, ve := col.GetRangeValueIndexV2(start, end)
	if vs == ve {
		f.doNullWindow(time, sameInterval)
        return
	}

	var vos int
	for i := start; i < end; i++ {
		t := c.TimeByIndex(i)
		if col.IsNilV2(i) {
			f.time = append(f.time, t)
			f.value = append(f.value, 0)
			f.nils = append(f.nils, true)
			continue
		}

		v := col.{{.Name}}Value(vs + vos)
		vos++
		f.sum += v
		f.time = append(f.time, t)
		f.value = append(f.value, f.sum)
		f.nils = append(f.nils, false)
	}

	if !sameInterval {
		f.sum = 0
	}
}

func (f *{{.Name}}CumulativeSumItem) AppendItem(c Chunk, ordinal int, start, end int, sameInterval bool) {
	if c.Column(ordinal).NilCount() == 0 {
		f.AppendItemFastFunc(c, ordinal, start, end, sameInterval)
		return
	}
	f.AppendItemSlowFunc(c, ordinal, start, end, sameInterval)
}

func (f *{{.Name}}CumulativeSumItem) Reset() {
	f.time = f.time[:0]
	f.value = f.value[:0]
	f.nils = f.nils[:0]
}

func (f *{{.Name}}CumulativeSumItem) Len() int {
	return len(f.time)
}

func (f *{{.Name}}CumulativeSumItem) PrevNil() bool {
	return f.sum==0
}

func (f *{{.Name}}CumulativeSumItem) ResetPrev() {
    f.sum = 0
}

func (f *{{.Name}}CumulativeSumItem) GetBaseTransData() BaseTransData {
    return BaseTransData{time: f.time, {{.name}}Value: f.value, nils:f.nils}
}
{{- end}}
{{end}}

{{with $types := .}}
{{range $k := $types}}
{{- if or (eq .Name "Float") (eq .Name "Integer")}}
{{range $v := $types}}
{{- if (eq .Name "Float")}}
type {{$k.Name}}Col{{$v.Name}}TransIterator struct {
	isSingleCall bool
	inOrdinal    int
	outOrdinal   int
	buf          TransItem
}

func New{{$k.Name}}Col{{$v.Name}}TransIterator(
	isSingleCall bool, inOrdinal, outOrdinal int, rowDataType hybridqp.RowDataType, transItem TransItem,
) *{{$k.Name}}Col{{$v.Name}}TransIterator {
	r := &{{$k.Name}}Col{{$v.Name}}TransIterator{
		buf:          transItem,
		isSingleCall: isSingleCall,
		inOrdinal:    inOrdinal,
		outOrdinal:   outOrdinal,
	}
	return r
}

func (r *{{$k.Name}}Col{{$v.Name}}TransIterator) processFirstWindow(
	inChunk, outChunk Chunk, haveMultiInterval, sameInterval bool, start, end, i int,
) {
	if haveMultiInterval {
		r.buf.AppendItem(inChunk, r.inOrdinal, start, end, false)
	} else {
		r.buf.AppendItem(inChunk, r.inOrdinal, start, end, sameInterval)
	}
	if r.buf.Len() > 0 {
		r.appendCurrItem(inChunk, outChunk, i)
	}
	r.buf.Reset()
}

func (r *{{$k.Name}}Col{{$v.Name}}TransIterator) processLastWindow(
	inChunk, outChunk Chunk, start, end, i int,
) {
	r.buf.AppendItem(inChunk, r.inOrdinal, start, end, true)
	if r.buf.Len() > 0 {
		r.appendCurrItem(inChunk, outChunk, i)
	}
	r.buf.Reset()
}

func (r *{{$k.Name}}Col{{$v.Name}}TransIterator) processMiddleWindow(
	inChunk, outChunk Chunk, start, end, i int,
) {
	r.buf.AppendItem(inChunk, r.inOrdinal, start, end, false)
	if r.buf.Len() > 0 {
		r.appendCurrItem(inChunk, outChunk, i)
	}
	r.buf.Reset()
}

func (r *{{$k.Name}}Col{{$v.Name}}TransIterator) appendCurrItem(inChunk, outChunk Chunk, i int) {
    transData := r.buf.GetBaseTransData()
	time := transData.time
	value := transData.{{$v.name}}Value
	nils := transData.nils
	if r.isSingleCall {
		var nilCount int
		for j := range time {
			if nils[j] {
				nilCount++
				continue
			}
			outChunk.AppendTime(time[j])
			outChunk.Column(r.outOrdinal).Append{{$v.Name}}Values(value[j])
			outChunk.Column(r.outOrdinal).AppendNilsV2(true)
		}
		if nilCount == r.buf.Len() {
			return
		}
		idx := outChunk.Len() - r.buf.Len() + nilCount
		outChunk.AppendIntervalIndex(idx)
		outChunk.AppendTagsAndIndex(inChunk.Tags()[i], idx)
		return
	}
	for j := range time {
		if nils[j] {
			outChunk.Column(r.outOrdinal).AppendNil()
			continue
		}
		outChunk.Column(r.outOrdinal).Append{{$v.Name}}Values(value[j])
		outChunk.Column(r.outOrdinal).AppendNilsV2(true)
	}
}

func (r *{{$k.Name}}Col{{$v.Name}}TransIterator) Next(ie *IteratorEndpoint, p *IteratorParams) {
	var end int
	inChunk, outChunk := ie.InputPoint.Chunk, ie.OutputPoint.Chunk
	firstIndex, lastIndex := 0, len(inChunk.TagIndex())-1
	for i, start := range inChunk.TagIndex() {
		if i < lastIndex {
			end = inChunk.TagIndex()[i+1]
		} else {
			end = inChunk.NumberOfRows()
		}

		if i == firstIndex && !r.buf.PrevNil() {
			r.processFirstWindow(inChunk, outChunk, firstIndex != lastIndex, p.sameInterval, start, end, i)
		} else if i == lastIndex && p.sameInterval {
			r.processLastWindow(inChunk, outChunk, start, end, i)
		} else {
			r.processMiddleWindow(inChunk, outChunk, start, end, i)
		}
	}
}
{{end}}
{{- end}}
{{end}}
{{- end}}
{{end}}

type IntegerColIntegerTransIterator struct {
	isSingleCall bool
	inOrdinal    int
	outOrdinal   int
	buf          TransItem
}

func NewIntegerColIntegerTransIterator(
	isSingleCall bool, inOrdinal, outOrdinal int, rowDataType hybridqp.RowDataType, transItem TransItem,
) *IntegerColIntegerTransIterator {
	r := &IntegerColIntegerTransIterator{
		buf:          transItem,
		isSingleCall: isSingleCall,
		inOrdinal:    inOrdinal,
		outOrdinal:   outOrdinal,
	}
	return r
}

func (r *IntegerColIntegerTransIterator) processFirstWindow(
	inChunk, outChunk Chunk, haveMultiInterval, sameInterval bool, start, end, i int,
) {
	if haveMultiInterval {
		r.buf.AppendItem(inChunk, r.inOrdinal, start, end, false)
	} else {
		r.buf.AppendItem(inChunk, r.inOrdinal, start, end, sameInterval)
	}
	if r.buf.Len() > 0 {
		r.appendCurrItem(inChunk, outChunk, i)
	}
	r.buf.Reset()
}

func (r *IntegerColIntegerTransIterator) processLastWindow(
	inChunk, outChunk Chunk, start, end, i int,
) {
	r.buf.AppendItem(inChunk, r.inOrdinal, start, end, true)
	if r.buf.Len() > 0 {
		r.appendCurrItem(inChunk, outChunk, i)
	}
	r.buf.Reset()
}

func (r *IntegerColIntegerTransIterator) processMiddleWindow(
	inChunk, outChunk Chunk, start, end, i int,
) {
	r.buf.AppendItem(inChunk, r.inOrdinal, start, end, false)
	if r.buf.Len() > 0 {
		r.appendCurrItem(inChunk, outChunk, i)
	}
	r.buf.Reset()
}

func (r *IntegerColIntegerTransIterator) appendCurrItem(inChunk, outChunk Chunk, i int) {
	transData := r.buf.GetBaseTransData()
	time := transData.time
	value := transData.integerValue
	nils := transData.nils
	if r.isSingleCall {
		var nilCount int
		for j := range time {
			if nils[j] {
				nilCount++
				continue
			}
			outChunk.AppendTime(time[j])
			outChunk.Column(r.outOrdinal).AppendIntegerValues(value[j])
			outChunk.Column(r.outOrdinal).AppendNilsV2(true)
		}
		if nilCount == r.buf.Len() {
			return
		}
		idx := outChunk.Len() - r.buf.Len() + nilCount
		outChunk.AppendIntervalIndex(idx)
		outChunk.AppendTagsAndIndex(inChunk.Tags()[i], idx)
		return
	}
	for j := range time {
		if nils[j] {
			outChunk.Column(r.outOrdinal).AppendNil()
			continue
		}
		outChunk.Column(r.outOrdinal).AppendIntegerValues(value[j])
		outChunk.Column(r.outOrdinal).AppendNilsV2(true)
	}
}

func (r *IntegerColIntegerTransIterator) Next(ie *IteratorEndpoint, p *IteratorParams) {
	var end int
	inChunk, outChunk := ie.InputPoint.Chunk, ie.OutputPoint.Chunk
	firstIndex, lastIndex := 0, len(inChunk.TagIndex())-1
	for i, start := range inChunk.TagIndex() {
		if i < lastIndex {
			end = inChunk.TagIndex()[i+1]
		} else {
			end = inChunk.NumberOfRows()
		}

		if i == firstIndex && !r.buf.PrevNil() {
			r.processFirstWindow(inChunk, outChunk, firstIndex != lastIndex, p.sameInterval, start, end, i)
		} else if i == lastIndex && p.sameInterval {
			r.processLastWindow(inChunk, outChunk, start, end, i)
		} else {
			r.processMiddleWindow(inChunk, outChunk, start, end, i)
		}
	}
}

{{range .}}
{{- if and (ne .Name "String") (ne .Name "Boolean")}}
type {{.Name}}ColFloatRateMiddleReduce func(c Chunk, ordinal, start, end int) (firstIndex, lastIndex int, firstValue, lastValue {{.Type}}, isNil bool)

type {{.Name}}ColFloatRateFinalReduce func(firstTime, lastTime int64, firstValue, lastValue {{.Type}}, interval *hybridqp.Interval) (v float64, isNil bool)

type {{.Name}}ColFloatRateUpdate func(prevPoints, currPoints [2]*{{.Name}}Point)

type {{.Name}}ColFloatRateMerge func(prevPoints [2]*{{.Name}}Point, interval *hybridqp.Interval) (v float64, isNil bool)

type {{.Name}}ColFloatRateIterator struct {
	isSingleCall bool
	inOrdinal    int
	outOrdinal   int
	interval     *hybridqp.Interval
	fn           {{.Name}}ColFloatRateMiddleReduce
	fv           {{.Name}}ColFloatRateFinalReduce
	fu           {{.Name}}ColFloatRateUpdate
	fm           {{.Name}}ColFloatRateMerge
	prevPoints   [2]*{{.Name}}Point
	currPoints   [2]*{{.Name}}Point
}

func New{{.Name}}ColFloatRateIterator(fn {{.Name}}ColFloatRateMiddleReduce, fv {{.Name}}ColFloatRateFinalReduce,
	fu {{.Name}}ColFloatRateUpdate, fm {{.Name}}ColFloatRateMerge,
	isSingleCall bool, inOrdinal, outOrdinal int, rowDataType hybridqp.RowDataType,
	interval *hybridqp.Interval,
) *{{.Name}}ColFloatRateIterator {
	r := &{{.Name}}ColFloatRateIterator{
		fn:           fn,
		fv:           fv,
		fu:           fu,
		fm:           fm,
		isSingleCall: isSingleCall,
		inOrdinal:    inOrdinal,
		outOrdinal:   outOrdinal,
		interval:     interval,
		prevPoints:   [2]*{{.Name}}Point{new{{.Name}}Point(), new{{.Name}}Point()},
		currPoints:   [2]*{{.Name}}Point{new{{.Name}}Point(), new{{.Name}}Point()},
	}
	return r
}

func (r *{{.Name}}ColFloatRateIterator) mergePrevItem(outChunk Chunk, v float64, isNil bool) {
	if r.isSingleCall && !isNil {
		outChunk.AppendTime(r.prevPoints[0].time)
		outChunk.AppendIntervalIndex(outChunk.Len() - 1)
	}
	if isNil {
		outChunk.Column(r.outOrdinal).AppendNil()
	} else {
		outChunk.Column(r.outOrdinal).AppendNilsV2(true)
		outChunk.Column(r.outOrdinal).AppendFloatValues(v)
	}
}

func (r *{{.Name}}ColFloatRateIterator) doFirstWindowForNull(outChunk Chunk) {
	if r.prevPoints[0].isNil || r.prevPoints[1].isNil {
		outChunk.Column(r.outOrdinal).AppendNil()
	} else {
		v, isNils := r.fm(r.prevPoints, r.interval)
		r.mergePrevItem(outChunk, v, isNils)
	}
	r.prevPoints[0].Reset()
	r.prevPoints[1].Reset()
}

func (r *{{.Name}}ColFloatRateIterator) processNullWindow(outChunk Chunk, sameInterval, onlyOneInterval bool,
	i, firstIndex, lastIndex int) {
	if onlyOneInterval {
		if !sameInterval {
			r.doFirstWindowForNull(outChunk)
		}
	} else {
		if i == firstIndex {
			r.doFirstWindowForNull(outChunk)
		} else if i == lastIndex {
			if !sameInterval {
				outChunk.Column(r.outOrdinal).AppendNil()
			}
		} else {
			outChunk.Column(r.outOrdinal).AppendNil()
		}
	}
}

func (r *{{.Name}}ColFloatRateIterator) processFirstWindow(outChunk Chunk, sameInterval, onlyOneInterval bool) {
	if !onlyOneInterval || !sameInterval {
		if !r.prevPoints[0].isNil && !r.prevPoints[1].isNil {
			v, isNil := r.fm(r.prevPoints, r.interval)
			r.mergePrevItem(outChunk, v, isNil)
		}
		r.prevPoints[0].Reset()
		r.prevPoints[1].Reset()
	}
	r.currPoints[0].Reset()
	r.currPoints[1].Reset()
}

func (r *{{.Name}}ColFloatRateIterator) processLastWindow(inChunk Chunk, fi, si int, fv, sv {{.Type}}) {
	r.prevPoints[0].Set(fi, inChunk.TimeByIndex(fi), fv)
	r.prevPoints[1].Set(si, inChunk.TimeByIndex(si), sv)
}

func (r *{{.Name}}ColFloatRateIterator) processMiddleWindow(inChunk, outChunk Chunk, fi, si int, fv, sv {{.Type}}) {
	v, isNil := r.fv(inChunk.TimeByIndex(fi), inChunk.TimeByIndex(si), fv, sv, r.interval)
	if r.isSingleCall && !isNil {
		outChunk.AppendTime(inChunk.TimeByIndex(fi))
		outChunk.AppendIntervalIndex(outChunk.Len() - 1)
	}
	if isNil {
		outChunk.Column(r.outOrdinal).AppendNil()
	} else {
		outChunk.Column(r.outOrdinal).AppendNilsV2(true)
		outChunk.Column(r.outOrdinal).AppendFloatValues(v)
	}
}

func (r *{{.Name}}ColFloatRateIterator) Next(ie *IteratorEndpoint, p *IteratorParams) {
	var end int
	inChunk, outChunk := ie.InputPoint.Chunk, ie.OutputPoint.Chunk
	firstIndex, lastIndex := 0, len(inChunk.IntervalIndex())-1
	onlyOneInterval := inChunk.IntervalLen() == 1
	for i, start := range inChunk.IntervalIndex() {
		if i < lastIndex {
			end = inChunk.IntervalIndex()[i+1]
		} else {
			end = inChunk.NumberOfRows()
		}

		fi, si, fv, sv, isNil := r.fn(inChunk, r.inOrdinal, start, end)
		if isNil {
			r.processNullWindow(outChunk, p.sameInterval, onlyOneInterval, i, firstIndex, lastIndex)
			continue
		}

		if i == firstIndex && (!r.prevPoints[0].isNil || !r.prevPoints[1].isNil) {
			r.currPoints[0].Set(fi, inChunk.TimeByIndex(fi), fv)
			r.currPoints[1].Set(si, inChunk.TimeByIndex(si), sv)
			r.fu(r.prevPoints, r.currPoints)
			r.processFirstWindow(outChunk, p.sameInterval, onlyOneInterval)
		} else if i == lastIndex && p.sameInterval {
			r.processLastWindow(inChunk, fi, si, fv, sv)
		} else {
			r.processMiddleWindow(inChunk, outChunk, fi, si, fv, sv)
		}
	}
}
{{- end}}
{{end}}

{{range .}}

type {{.Name}}SampleItem struct {
	maxIndex int
	items    []{{.Name}}PointItem
}

func (f *{{.Name}}SampleItem) Reset() {
	f.maxIndex = 0
	f.items = f.items[:0]
}

func (f *{{.Name}}SampleItem) Len() int {
	return len(f.items)
}

func (f *{{.Name}}SampleItem) Less(i, j int) bool {
	if f.items[i].time != f.items[j].time {
        return f.items[i].time < f.items[j].time
    }
    return f.items[i].index < f.items[j].index
}

func (f *{{.Name}}SampleItem) Swap(i, j int) {
	f.items[i], f.items[j] = f.items[j], f.items[i]
}

func (f *{{.Name}}SampleItem) appendForAux(input Chunk, start, end, ordinal int) []int {
	maxIndex := f.maxIndex + 1
	f.appendForFast(input, start, end, ordinal, maxIndex)
	index := make([]int, 0)
	for i := range f.items {
		if idx := f.items[i].index + start - maxIndex; idx >= start {
			index = append(index, idx)
		}
	}
	return index
}

{{end}}


{{range .}}
{{- if and (ne .Name "String")}}
func (f *{{.Name}}SampleItem) appendForFast(input Chunk, start, end, ordinal, maxIndex int) {
	for i := start; i < end; i++ {
		p := New{{.Name}}PointItem(
			input.TimeByIndex(i),
			input.Column(ordinal).{{.Name}}Values()[i])
		p.index = maxIndex + i - start
		if f.Len() == cap(f.items) {
			rnd := rand.Intn(p.index)
			if rnd >= cap(f.items) {
				continue
			}
			if (*p).index > f.maxIndex {
				f.maxIndex = (*p).index
			}
			f.items[rnd] = *p
			continue
		} else {
			if (*p).index > f.maxIndex {
				f.maxIndex = (*p).index
			}
			f.items = append(f.items, *p)
		}
	}
}
{{- end}}
{{end}}

func (f *StringSampleItem) appendForFast(input Chunk, start, end, ordinal, maxIndex int) {
	for i := start; i < end; i++ {
		p := NewStringPointItem(
			input.TimeByIndex(i),
			input.Column(ordinal).StringValue(i))
		p.index = maxIndex + i - start
		if f.Len() == cap(f.items) {
			rnd := rand.Intn(p.index)
			if rnd >= cap(f.items) {
				continue
			}
			if (*p).index > f.maxIndex {
				f.maxIndex = (*p).index
			}
			f.items[rnd] = *p
			continue
		} else {
			if (*p).index > f.maxIndex {
				f.maxIndex = (*p).index
			}
			f.items = append(f.items, *p)
		}
	}
}


{{range .}}

type {{.Name}}Col{{.Name}}SampleIterator struct {
	sampleNum     int
    isSingleCall  bool
    inOrdinal     int
    outOrdinal    int
    prevMaxIndex  int
    buf           *{{.Name}}SampleItem
    auxChunk      Chunk
    auxProcessor  []*AuxProcessor
    windowIndex   []int
    prevBufIndex  []int
    currBufIndex  []int
    interBufIndex []int
}

func New{{.Name}}SampleItem(items []{{.Name}}PointItem) *{{.Name}}SampleItem {
	return &{{.Name}}SampleItem{
	    items: items,
	}
}

func New{{.Name}}Col{{.Name}}SampleIterator(sampleNum int,
	isSingleCall bool, inOrdinal, outOrdinal int, auxProcessor []*AuxProcessor, rowDataType hybridqp.RowDataType,
) *{{.Name}}Col{{.Name}}SampleIterator {
	r := &{{.Name}}Col{{.Name}}SampleIterator{
		buf:          New{{.Name}}SampleItem(make([]{{.Name}}PointItem, 0, sampleNum)),
		sampleNum:    sampleNum,
		isSingleCall: isSingleCall,
		inOrdinal:    inOrdinal,
		outOrdinal:   outOrdinal,
	}
	if isSingleCall && len(auxProcessor) > 0 {
		r.auxProcessor = auxProcessor
		r.auxChunk = NewChunkBuilder(rowDataType).NewChunk("")
	}
	return r
}

func (r *{{.Name}}Col{{.Name}}SampleIterator) reset() {
	r.prevBufIndex = r.prevBufIndex[:0]
	r.currBufIndex = r.currBufIndex[:0]
	r.interBufIndex = r.interBufIndex[:0]
	r.windowIndex = r.windowIndex[:0]
}

func (r *{{.Name}}Col{{.Name}}SampleIterator) updateAuxColBothChunk(inChunk Chunk) {
	clone := r.auxChunk.Clone()
	r.auxChunk.Reset()
	sort.Ints(r.interBufIndex)
	r.currBufIndex = r.currBufIndex[:0]
	for i := range r.prevBufIndex {
		if hybridqp.BinarySearch(r.prevBufIndex[i], r.interBufIndex) {
			r.currBufIndex = append(r.currBufIndex, i)
		}
	}
	r.prevBufIndex = r.prevBufIndex[:0]
	for i := range r.buf.items {
		r.prevBufIndex = append(r.prevBufIndex, r.buf.items[i].index-r.prevMaxIndex)
	}
	hybridqp.SortS1ByS2(r.windowIndex, r.prevBufIndex)
	cs, ws := 0, 0
	for i := range r.buf.items {
		if hybridqp.BinarySearch(r.buf.items[i].index, r.interBufIndex) {
			for j := range r.auxProcessor {
				r.auxProcessor[j].auxHelperFunc(
					clone.Column(r.auxProcessor[j].outOrdinal),
					r.auxChunk.Column(r.auxProcessor[j].outOrdinal),
					r.currBufIndex[cs],
				)
			}
			cs++
		} else {
			for j := range r.auxProcessor {
				r.auxProcessor[j].auxHelperFunc(
					inChunk.Column(r.auxProcessor[j].inOrdinal),
					r.auxChunk.Column(r.auxProcessor[j].outOrdinal),
					r.windowIndex[ws],
				)
			}
			ws++
		}
	}
	clone.Reset()
}

func (r *{{.Name}}Col{{.Name}}SampleIterator) updatePrevItem(
	inChunk Chunk, start, end int,
) {
	if len(r.auxProcessor) == 0 {
		r.buf.appendForFast(inChunk, start, end, r.inOrdinal, r.buf.maxIndex+1)
	} else {
		sort.Sort(r.buf)
		for i := range r.buf.items {
			r.prevBufIndex = append(r.prevBufIndex, r.buf.items[i].index)
		}
		r.prevMaxIndex = r.buf.maxIndex + 1
		r.windowIndex = r.buf.appendForAux(inChunk, start, end, r.inOrdinal)
		for i := range r.buf.items {
			r.currBufIndex = append(r.currBufIndex, r.buf.items[i].index)
		}
		r.interBufIndex = hybridqp.Intersect(r.prevBufIndex, r.currBufIndex)
		sort.Sort(r.buf)
		if !hybridqp.CompareSlice(r.interBufIndex, r.prevBufIndex) {
			r.updateAuxColBothChunk(inChunk)
		} else {
			r.updateAuxColInChunk(inChunk)
		}
	}
	r.reset()
}

func (r *{{.Name}}Col{{.Name}}SampleIterator) updateAuxColInChunk(inChunk Chunk) {
	if len(r.interBufIndex) == 0 {
		r.auxChunk.Reset()
	}
	r.currBufIndex = r.currBufIndex[:0]
	for i := range r.buf.items {
		r.currBufIndex = append(r.currBufIndex, r.buf.items[i].index-r.prevMaxIndex)
	}
	hybridqp.SortS1ByS2(r.windowIndex, r.currBufIndex)
	for j := range r.auxProcessor {
		r.auxProcessor[j].auxHelperFunc(
			inChunk.Column(r.auxProcessor[j].inOrdinal),
			r.auxChunk.Column(r.auxProcessor[j].outOrdinal),
			r.windowIndex...,
		)
	}
}

func (r *{{.Name}}Col{{.Name}}SampleIterator) appendPrevItem(
	inChunk, outChunk Chunk,
) {
	for j := range r.buf.items {
		outChunk.AppendTime(r.buf.items[j].time)
		outChunk.Column(r.outOrdinal).Append{{.Name}}Values(r.buf.items[j].value)
		outChunk.Column(r.outOrdinal).AppendNilsV2(true)
	}
	if len(r.auxProcessor) > 0 {
		for j := range r.buf.items {
			r.windowIndex = append(r.windowIndex, j)
		}
		for j := range r.auxProcessor {
			r.auxProcessor[j].auxHelperFunc(
				r.auxChunk.Column(r.auxProcessor[j].outOrdinal),
				outChunk.Column(r.auxProcessor[j].outOrdinal),
				r.windowIndex...,
			)
		}
		r.windowIndex = r.windowIndex[:0]
		r.auxChunk.Reset()
	}
	outChunk.AppendIntervalIndex(outChunk.Len() - r.buf.Len())
}

func (r *{{.Name}}Col{{.Name}}SampleIterator) processFirstWindow(
	inChunk, outChunk Chunk, sameInterval, haveMultiInterval bool, start, end int,
) {
	r.updatePrevItem(inChunk, start, end)
    if haveMultiInterval || !sameInterval {
        sort.Sort(r.buf)
        if r.buf.Len() > 0 {
            r.appendPrevItem(r.auxChunk, outChunk)
        }
        r.buf.Reset()
    }
}

func (r *{{.Name}}Col{{.Name}}SampleIterator) updateCurrItem(
	inChunk Chunk, start, end int,
) {
	if len(r.auxProcessor) == 0 {
		r.buf.appendForFast(inChunk, start, end, r.inOrdinal, r.buf.maxIndex+1)
	} else {
		sort.Sort(r.buf)
		r.prevMaxIndex = r.buf.maxIndex + 1
		r.windowIndex = r.buf.appendForAux(inChunk, start, end, r.inOrdinal)
		for j := range r.auxProcessor {
			r.auxProcessor[j].auxHelperFunc(
				inChunk.Column(r.auxProcessor[j].inOrdinal),
				r.auxChunk.Column(r.auxProcessor[j].outOrdinal),
				r.windowIndex...,
			)
		}
		r.windowIndex = r.windowIndex[:0]
		r.currBufIndex = r.currBufIndex[:0]
	}
}

func (r *{{.Name}}Col{{.Name}}SampleIterator) processLastWindow(
	inChunk Chunk, start, end int,
) {
	r.updateCurrItem(inChunk, start, end)
}

func (r *{{.Name}}Col{{.Name}}SampleIterator) appendCurrItem(
	inChunk, outChunk Chunk, start int,
) {
	for j := range r.buf.items {
		outChunk.AppendTime(r.buf.items[j].time)
		outChunk.Column(r.outOrdinal).Append{{.Name}}Values(r.buf.items[j].value)
		outChunk.Column(r.outOrdinal).AppendNilsV2(true)
	}
	if len(r.auxProcessor) > 0 {
		for i := range r.buf.items {
			r.currBufIndex = append(r.currBufIndex, r.buf.items[i].index+start-r.prevMaxIndex)
		}
		hybridqp.SortS1ByS2(r.windowIndex, r.currBufIndex)
		for j := range r.auxProcessor {
			r.auxProcessor[j].auxHelperFunc(
				inChunk.Column(r.auxProcessor[j].inOrdinal),
				outChunk.Column(r.auxProcessor[j].outOrdinal),
				r.windowIndex...,
			)
		}
		r.windowIndex = r.windowIndex[:0]
		r.currBufIndex = r.currBufIndex[:0]
	}
	outChunk.AppendIntervalIndex(outChunk.Len() - r.buf.Len())
}


func (r *{{.Name}}Col{{.Name}}SampleIterator) processMiddleWindow(
	inChunk, outChunk Chunk, start, end int,
) {
	if len(r.auxProcessor) == 0 {
        r.buf.appendForFast(inChunk, start, end, r.inOrdinal, r.buf.maxIndex+1)
    } else {
        r.prevMaxIndex = r.buf.maxIndex + 1
        r.windowIndex = r.buf.appendForAux(inChunk, start, end, r.inOrdinal)
    }
    sort.Sort(r.buf)
    if r.buf.Len() > 0 {
        r.appendCurrItem(inChunk, outChunk, start)
    }
    r.buf.Reset()
}

func (r *{{.Name}}Col{{.Name}}SampleIterator) Next(ie *IteratorEndpoint, p *IteratorParams) {
	inChunk, outChunk := ie.InputPoint.Chunk, ie.OutputPoint.Chunk
	if inChunk.Column(r.inOrdinal).IsEmpty() && r.buf.Len() > 0 {
		return
	}
	var end int
	firstIndex, lastIndex := 0, len(inChunk.IntervalIndex())-1
	for i, start := range inChunk.IntervalIndex() {
		if i < lastIndex {
            end = inChunk.IntervalIndex()[i+1]
        } else {
            end = inChunk.NumberOfRows()
        }
        if i == firstIndex && r.buf.Len() > 0 {
            r.processFirstWindow(inChunk, outChunk, p.sameInterval,
                firstIndex != lastIndex, start, end)
        } else if i == lastIndex && p.sameInterval {
            r.processLastWindow(inChunk, start, end)
        } else {
            r.processMiddleWindow(inChunk, outChunk, start, end)
        }
	}
}

{{end}}

{{range .}}
{{- if and (ne .Name "Integer") (ne .Name "Float")}}
type {{.Name}}PointItem struct {
	time  int64
	value {{.Type}}
	index int
}

func New{{.Name}}PointItem(time int64, value {{.Type}}) *{{.Name}}PointItem {
	return &{{.Name}}PointItem{
		time:  time,
		value: value,
	}
}

{{- end}}
{{end}}

{{range .}}
{{- if or (eq .Name "Integer") (eq .Name "Float") (eq .Name "Boolean")}}
type {{.Name}}SlidingWindow struct {
	isNil      bool
	slidingNum int
	points     []*{{.Name}}Point
}

func New{{.Name}}SlidingWindow(slidingNum int) *{{.Name}}SlidingWindow {
	sw := &{{.Name}}SlidingWindow{
		isNil:      true,
		slidingNum: slidingNum,
	}
	for i := 0; i < slidingNum; i++ {
		sw.points = append(sw.points, new{{.Name}}Point())
	}
	return sw
}

func (w *{{.Name}}SlidingWindow) Len() int {
	return w.slidingNum
}

func (w *{{.Name}}SlidingWindow) IsNil() bool {
	return w.isNil
}

func (w *{{.Name}}SlidingWindow) SetPoint(value {{.Type}}, isNil bool, index int) {
	w.points[index].value = value
	w.points[index].isNil = isNil
	if index == w.slidingNum-1 {
		w.isNil = false
	}
}

func (w *{{.Name}}SlidingWindow) Reset() {
	w.isNil = true
}
{{- end}}
{{end}}

{{range .}}
{{- if and (ne .Name "Integer") (ne .Name "String")}}
type {{.Name}}Col{{.Name}}WindowReduce func(c Chunk, ordinal, start, end int) (index int, value {{.Type}}, isNil bool)

type {{.Name}}PointMerge func(prevPoint, currPoint *{{.Name}}Point)

type {{.Name}}WindowMerge func(prevWindow, currWindow *{{.Name}}SlidingWindow, fpm {{.Name}}PointMerge)

type {{.Name}}SlidingWindow{{.Name}}Iterator struct {
	slidingNum int
	inOrdinal  int
	outOrdinal int
	prevWindow *{{.Name}}SlidingWindow
	currWindow *{{.Name}}SlidingWindow
	fwr        {{.Name}}Col{{.Name}}WindowReduce
	fpm        {{.Name}}PointMerge
	fwm        {{.Name}}WindowMerge
}

func New{{.Name}}SlidingWindow{{.Name}}Iterator(
	fwr {{.Name}}Col{{.Name}}WindowReduce,
	fpm {{.Name}}PointMerge,
	fwm {{.Name}}WindowMerge,
	inOrdinal, outOrdinal int, slidingNum int,
) *{{.Name}}SlidingWindow{{.Name}}Iterator {
	r := &{{.Name}}SlidingWindow{{.Name}}Iterator{
		fwr:        fwr,
		fpm:        fpm,
		fwm:        fwm,
		slidingNum: slidingNum,
		inOrdinal:  inOrdinal,
		outOrdinal: outOrdinal,
		prevWindow: New{{.Name}}SlidingWindow(slidingNum),
		currWindow: New{{.Name}}SlidingWindow(slidingNum),
	}
	return r
}

func (r *{{.Name}}SlidingWindow{{.Name}}Iterator) mergePrevWindow(
	outChunk Chunk,
) {
	for i := 0; i < r.slidingNum; i++ {
		if r.prevWindow.points[i].isNil {
			outChunk.Column(r.outOrdinal).AppendNilsV2(false)
		} else {
			outChunk.Column(r.outOrdinal).AppendNilsV2(true)
			outChunk.Column(r.outOrdinal).Append{{.Name}}Values(r.prevWindow.points[i].value)
		}
	}
}

func (r *{{.Name}}SlidingWindow{{.Name}}Iterator) processFirstWindow(
	outChunk Chunk, value {{.Type}}, isNil, sameTag, onlyOneWindow bool, n int,
) {
	r.currWindow.SetPoint(value, isNil, n)
	if n < r.slidingNum-1 {
		return
	}
	r.fwm(r.prevWindow, r.currWindow, r.fpm)
	if !onlyOneWindow || !sameTag {
		r.mergePrevWindow(outChunk)
		r.prevWindow.Reset()
	}
	r.currWindow.Reset()
}

func (r *{{.Name}}SlidingWindow{{.Name}}Iterator) processLastWindow(
	value {{.Type}}, isNil bool, index int,
) {
	r.prevWindow.SetPoint(value, isNil, index)
}

func (r *{{.Name}}SlidingWindow{{.Name}}Iterator) processMiddleWindow(
	outChunk Chunk, value {{.Type}}, isNil bool,
) {
	if isNil {
		outChunk.Column(r.outOrdinal).AppendNilsV2(false)
	} else {
		outChunk.Column(r.outOrdinal).AppendNilsV2(true)
		outChunk.Column(r.outOrdinal).Append{{.Name}}Values(value)
	}
}

func (r *{{.Name}}SlidingWindow{{.Name}}Iterator) Next(ie *IteratorEndpoint, p *IteratorParams) {
	var (
		start, end int
		value {{.Type}}
		isNil bool
	)
	firstIndex, lastIndex := 0, len(p.winIdx)/r.slidingNum-1
	inChunk, outChunk := ie.InputPoint.Chunk, ie.OutputPoint.Chunk
	for i := range p.winIdx {
		m, n := i/r.slidingNum, i%r.slidingNum
		start, end = p.winIdx[i][0], p.winIdx[i][1]
		if start == -1 || end == -1 || start >= end {
			value, isNil = {{.Nil}}, true
		} else {
			_, value, isNil = r.fwr(inChunk, r.inOrdinal, start, end)
		}
		if m == firstIndex && !r.prevWindow.IsNil() {
			r.processFirstWindow(outChunk, value, isNil,
				p.sameTag, firstIndex == lastIndex, n)
		} else if m == lastIndex && p.sameTag {
			r.processLastWindow(value, isNil, n)
		} else {
			r.processMiddleWindow(outChunk, value, isNil)
		}
	}
}
{{- end}}
{{end}}

type IntegerPointMerge func(prevPoint, currPoint *IntegerPoint)

type IntegerWindowMerge func(prevWindow, currWindow *IntegerSlidingWindow, fpm IntegerPointMerge)

{{range .}}
{{- if or (eq .Name "Integer") (eq .Name "Boolean")}}
type {{.Name}}ColIntegerWindowReduce func(c Chunk, ordinal, start, end int) (index int, value int64, isNil bool)

type {{.Name}}SlidingWindowIntegerIterator struct {
	slidingNum int
	inOrdinal  int
	outOrdinal int
	prevWindow *IntegerSlidingWindow
	currWindow *IntegerSlidingWindow
	fwr        {{.Name}}ColIntegerWindowReduce
	fpm        IntegerPointMerge
	fwm        IntegerWindowMerge
}

func New{{.Name}}SlidingWindowIntegerIterator(
	fwr {{.Name}}ColIntegerWindowReduce,
	fpm IntegerPointMerge,
	fwm IntegerWindowMerge,
	inOrdinal, outOrdinal int, slidingNum int,
) *{{.Name}}SlidingWindowIntegerIterator {
	r := &{{.Name}}SlidingWindowIntegerIterator{
		fwr:        fwr,
		fpm:        fpm,
		fwm:        fwm,
		slidingNum: slidingNum,
		inOrdinal:  inOrdinal,
		outOrdinal: outOrdinal,
		prevWindow: NewIntegerSlidingWindow(slidingNum),
		currWindow: NewIntegerSlidingWindow(slidingNum),
	}
	return r
}

func (r *{{.Name}}SlidingWindowIntegerIterator) mergePrevWindow(
	outChunk Chunk,
) {
	for i := 0; i < r.slidingNum; i++ {
		if r.prevWindow.points[i].isNil {
			outChunk.Column(r.outOrdinal).AppendNilsV2(false)
		} else {
			outChunk.Column(r.outOrdinal).AppendNilsV2(true)
			outChunk.Column(r.outOrdinal).AppendIntegerValues(r.prevWindow.points[i].value)
		}
	}
}

func (r *{{.Name}}SlidingWindowIntegerIterator) processFirstWindow(
	outChunk Chunk, value int64, isNil, sameTag, onlyOneWindow bool, n int,
) {
	r.currWindow.SetPoint(value, isNil, n)
	if n < r.slidingNum-1 {
		return
	}
	r.fwm(r.prevWindow, r.currWindow, r.fpm)
	if !onlyOneWindow || !sameTag {
		r.mergePrevWindow(outChunk)
		r.prevWindow.Reset()
	}
	r.currWindow.Reset()
}

func (r *{{.Name}}SlidingWindowIntegerIterator) processLastWindow(
	value int64, isNil bool, index int,
) {
	r.prevWindow.SetPoint(value, isNil, index)
}

func (r *{{.Name}}SlidingWindowIntegerIterator) processMiddleWindow(
	outChunk Chunk, value int64, isNil bool,
) {
	if isNil {
		outChunk.Column(r.outOrdinal).AppendNilsV2(false)
	} else {
		outChunk.Column(r.outOrdinal).AppendNilsV2(true)
		outChunk.Column(r.outOrdinal).AppendIntegerValues(value)
	}
}

func (r *{{.Name}}SlidingWindowIntegerIterator) Next(ie *IteratorEndpoint, p *IteratorParams) {
	var (
		start, end int
		value int64
		isNil bool
	)
	firstIndex, lastIndex := 0, len(p.winIdx)/r.slidingNum-1
	inChunk, outChunk := ie.InputPoint.Chunk, ie.OutputPoint.Chunk
	for i := range p.winIdx {
		m, n := i/r.slidingNum, i%r.slidingNum
		start, end = p.winIdx[i][0], p.winIdx[i][1]
		if start == -1 || end == -1 || start >= end {
			value, isNil = 0, true
		} else {
			_, value, isNil = r.fwr(inChunk, r.inOrdinal, start, end)
		}
		if m == firstIndex && !r.prevWindow.IsNil() {
			r.processFirstWindow(outChunk, value, isNil,
				p.sameTag, firstIndex == lastIndex, n)
		} else if m == lastIndex && p.sameTag {
			r.processLastWindow(value, isNil, n)
		} else {
			r.processMiddleWindow(outChunk, value, isNil)
		}
	}
}
{{- end}}
{{end}}


type OGSketchItem interface {
	UpdateCluster(inChunk Chunk, start, end int)
	WriteResult(outChunk Chunk, time int64)
	IsNil() bool
	Reset()
}


{{range .}}
{{- if and (ne .Name "Boolean") (ne .Name "String")}}
type {{.Name}}OGSketchInsertItem struct {
	isSingleCall bool
	inOrdinal    int
	outOrdinal   int
	clusterNum   int
	percentile   float64
	sketch       OGSketch
	clusters     ClusterSet
}

func New{{.Name}}OGSketchInsertIem(isSingleCall bool, inOrdinal, outOrdinal, clusterNum int, percentile float64) *{{.Name}}OGSketchInsertItem {
	return &{{.Name}}OGSketchInsertItem{
		isSingleCall: isSingleCall,
		inOrdinal:    inOrdinal,
		outOrdinal:   outOrdinal,
		clusterNum:   clusterNum,
		percentile:   percentile,
		sketch:       NewOGSketchImpl(float64(clusterNum)),
	}
}

func (o *{{.Name}}OGSketchInsertItem) UpdateCluster(inChunk Chunk, start, end int) {
	{{- if eq .Name "Float"}}
	o.sketch.InsertPoints(inChunk.Column(o.inOrdinal).{{.Name}}Values()[start:end]...)
	{{- else}}
	values := inChunk.Column(o.inOrdinal).{{.Name}}Values()[start:end]
	for i := range values {
		o.sketch.InsertPoints(float64(values[i]))
	}
	{{- end}}
}

func (o *{{.Name}}OGSketchInsertItem) WriteResult(outChunk Chunk, time int64) {
	o.clusters = o.sketch.Clusters()
	clusterNum := len(o.clusters)
	if o.isSingleCall {
		for i := 0; i < clusterNum; i++ {
			outChunk.AppendTime(time)
		}
		outChunk.AppendIntervalIndex(outChunk.Len() - clusterNum)
	}

	for i := 0; i < clusterNum; i++ {
		outChunk.Column(o.outOrdinal).AppendFloatTuples(floatTuple{values: []float64{o.clusters[i].Mean, o.clusters[i].Weight}})
	}
	outChunk.Column(o.outOrdinal).AppendManyNotNil(clusterNum)

	if !o.isSingleCall && o.clusterNum > clusterNum {
    	outChunk.Column(o.outOrdinal).AppendManyNil(o.clusterNum - clusterNum)
    }
}

func (o *{{.Name}}OGSketchInsertItem) IsNil() bool {
	return o.sketch.Len() == 0
}

func (o *{{.Name}}OGSketchInsertItem) Reset() {
	o.sketch.Reset()
}

type {{.Name}}OGSketchPercentileItem struct {
	isSingleCall bool
	inOrdinal    int
	outOrdinal   int
	clusterNum   int
	percentile   float64
	sketch       OGSketch
}

func New{{.Name}}OGSketchPercentileItem(isSingleCall bool, inOrdinal, outOrdinal, clusterNum int, percentile float64) *{{.Name}}OGSketchPercentileItem {
	return &{{.Name}}OGSketchPercentileItem{
		isSingleCall: isSingleCall,
		inOrdinal:    inOrdinal,
		outOrdinal:   outOrdinal,
		clusterNum:   clusterNum,
		percentile:   percentile,
		sketch:       NewOGSketchImpl(float64(clusterNum)),
	}
}

func (o *{{.Name}}OGSketchPercentileItem) UpdateCluster(inChunk Chunk, start, end int) {
	tuples := inChunk.Column(o.inOrdinal).FloatTuples()[start:end]
	o.sketch.InsertClusters(tuples...)

}

func (o *{{.Name}}OGSketchPercentileItem) WriteResult(outChunk Chunk, time int64) {
	value := o.sketch.Percentile(o.percentile)
	if o.isSingleCall {
		outChunk.AppendTime(time)
		outChunk.AppendIntervalIndex(outChunk.Len() - 1)
	}
	{{- if eq .Name "Float"}}
	outChunk.Column(o.outOrdinal).Append{{.Name}}Values(value)
	{{- else}}
	outChunk.Column(o.outOrdinal).Append{{.Name}}Values(int64(value))
	{{- end}}
	outChunk.Column(o.outOrdinal).AppendNilsV2(true)
}

func (o *{{.Name}}OGSketchPercentileItem) IsNil() bool {
	return o.sketch.Len() == 0
}

func (o *{{.Name}}OGSketchPercentileItem) Reset() {
	o.sketch.Reset()
}

type {{.Name}}PercentileApproxItem struct {
	isSingleCall bool
	inOrdinal    int
	outOrdinal   int
	clusterNum   int
	percentile   float64
	sketch       OGSketch
}

func New{{.Name}}PercentileApproxItem(isSingleCall bool, inOrdinal, outOrdinal, clusterNum int, percentile float64) *{{.Name}}PercentileApproxItem {
	return &{{.Name}}PercentileApproxItem{
		isSingleCall: isSingleCall,
		inOrdinal:    inOrdinal,
		outOrdinal:   outOrdinal,
		clusterNum:   clusterNum,
		percentile:   percentile,
		sketch:       NewOGSketchImpl(float64(clusterNum)),
	}
}

func (o *{{.Name}}PercentileApproxItem) UpdateCluster(inChunk Chunk, start, end int) {
    {{- if eq .Name "Float"}}
    o.sketch.InsertPoints(inChunk.Column(o.inOrdinal).{{.Name}}Values()[start:end]...)
    {{- else}}
	values := inChunk.Column(o.inOrdinal).{{.Name}}Values()[start:end]
	for i := range values {
		o.sketch.InsertPoints(float64(values[i]))
	}
    {{- end}}
}

func (o *{{.Name}}PercentileApproxItem) WriteResult(outChunk Chunk, time int64) {
	value := o.sketch.Percentile(o.percentile)
	if o.isSingleCall {
		outChunk.AppendTime(time)
		outChunk.AppendIntervalIndex(outChunk.Len() - 1)
	}
	{{- if eq .Name "Float"}}
	outChunk.Column(o.outOrdinal).Append{{.Name}}Values(value)
	{{- else}}
	outChunk.Column(o.outOrdinal).Append{{.Name}}Values(int64(value))
	{{- end}}
	outChunk.Column(o.outOrdinal).AppendNilsV2(true)
}

func (o *{{.Name}}PercentileApproxItem) IsNil() bool {
	return o.sketch.Len() == 0
}

func (o *{{.Name}}PercentileApproxItem) Reset() {
	o.sketch.Reset()
}
{{- end}}
{{end}}


type OGSketchMergeItem struct {
	isSingleCall bool
	inOrdinal    int
	outOrdinal   int
	clusterNum   int
	percentile   float64
	sketch       OGSketch
	clusters     ClusterSet
}

func NewOGSketchMergeItem(isSingleCall bool, inOrdinal, outOrdinal, clusterNum int, percentile float64) *OGSketchMergeItem {
	return &OGSketchMergeItem{
		isSingleCall: isSingleCall,
		inOrdinal:    inOrdinal,
		outOrdinal:   outOrdinal,
		clusterNum:   clusterNum,
		percentile:   percentile,
		sketch:       NewOGSketchImpl(float64(clusterNum)),
	}
}

func (o *OGSketchMergeItem) UpdateCluster(inChunk Chunk, start, end int) {
	tuples := inChunk.Column(o.inOrdinal).FloatTuples()[start:end]
	o.sketch.InsertClusters(tuples...)
}

func (o *OGSketchMergeItem) WriteResult(outChunk Chunk, time int64) {
	o.clusters = o.sketch.Clusters()
	clusterNum := len(o.clusters)
	if o.isSingleCall {
		for i := 0; i < clusterNum; i++ {
			outChunk.AppendTime(time)
		}
		outChunk.AppendIntervalIndex(outChunk.Len() - clusterNum)
	}

	for i := 0; i < clusterNum; i++ {
		outChunk.Column(o.outOrdinal).AppendFloatTuples(floatTuple{values: []float64{o.clusters[i].Mean, o.clusters[i].Weight}})
	}
	outChunk.Column(o.outOrdinal).AppendManyNotNil(clusterNum)

	if !o.isSingleCall && o.clusterNum > clusterNum {
    	outChunk.Column(o.outOrdinal).AppendManyNil(o.clusterNum - clusterNum)
    }
}

func (o *OGSketchMergeItem) IsNil() bool {
	return o.sketch.Len() == 0
}

func (o *OGSketchMergeItem) Reset() {
	o.sketch.Reset()
}

type OGSketchIterator struct {
	isSingleCall bool
	inOrdinal    int
	outOrdinal   int
	clusterNum   int
	opt          *query.ProcessorOptions
	sketch       OGSketchItem
}

func NewOGSketchIterator(
	isSingleCall bool, inOrdinal, outOrdinal int, clusterNum int, opt *query.ProcessorOptions, sketch OGSketchItem,
) *OGSketchIterator {
	r := &OGSketchIterator{
		isSingleCall: isSingleCall,
		inOrdinal:    inOrdinal,
		outOrdinal:   outOrdinal,
		clusterNum:   clusterNum,
		opt:          opt,
		sketch:       sketch,
	}
	return r
}

func (r *OGSketchIterator) processFirstWindow(
	inChunk, outChunk Chunk, sameInterval, haveMultiInterval bool, start, end int, time int64,
) {
	r.sketch.UpdateCluster(inChunk, start, end)
	if haveMultiInterval || !sameInterval {
		r.sketch.WriteResult(outChunk, time)
		r.sketch.Reset()
	}
}

func (r *OGSketchIterator) processLastWindow(
	inChunk Chunk, start, end int,
) {
	r.sketch.UpdateCluster(inChunk, start, end)
}

func (r *OGSketchIterator) processMiddleWindow(
	inChunk, outChunk Chunk, start, end int, time int64,
) {
	r.sketch.UpdateCluster(inChunk, start, end)
	r.sketch.WriteResult(outChunk, time)
	r.sketch.Reset()
}

func (r *OGSketchIterator) Next(ie *IteratorEndpoint, p *IteratorParams) {
	var end int
	inChunk, outChunk := ie.InputPoint.Chunk, ie.OutputPoint.Chunk
	firstIndex, lastIndex := 0, len(inChunk.IntervalIndex())-1
	for i, start := range inChunk.IntervalIndex() {
		if i < lastIndex {
			end = inChunk.IntervalIndex()[i+1]
		} else {
			end = inChunk.NumberOfRows()
		}
		var time int64
		if r.opt.Interval.IsZero() {
			time = hybridqp.MaxInt64(r.opt.StartTime, 0)
		} else {
			time, _ = r.opt.Window(inChunk.TimeByIndex(start))
		}
		start, end = inChunk.Column(r.inOrdinal).GetRangeValueIndexV2(start, end)
		if !r.isSingleCall {
			if start == end && r.sketch.IsNil() && (i < lastIndex || (i == lastIndex && !p.sameInterval)) {
				outChunk.Column(r.outOrdinal).AppendManyNil(r.clusterNum)
				continue
			}
		}
		if i == firstIndex && !r.sketch.IsNil() {
			r.processFirstWindow(inChunk, outChunk, p.sameInterval, firstIndex != lastIndex, start, end, time)
		} else if i == lastIndex && p.sameInterval {
			r.processLastWindow(inChunk, start, end)
		} else {
			r.processMiddleWindow(inChunk, outChunk, start, end, time)
		}
	}
}