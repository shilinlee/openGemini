// Code generated by tmpl; DO NOT EDIT.
// https://github.com/benbjohnson/tmpl
//
// Source: agg_func.gen.go.tmpl

/*
Copyright 2022 Huawei Cloud Computing Technologies Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package executor

import (
	"bytes"
	"math"
	"sort"

	"github.com/openGemini/openGemini/engine/hybridqp"
)

func NewFloatMedianReduce(floatSliceItem *FloatSliceItem) (int, int64, float64, bool) {
	length := len(floatSliceItem.value)
	if length == 0 {
		return -1, 0, 0, true
	}
	if length == 1 {
		return -1, floatSliceItem.time[0], float64(floatSliceItem.value[0]), false
	}

	sort.Stable(floatSliceItem)

	if length%2 == 0 {
		lowvalue, highvalue := floatSliceItem.value[length/2-1], floatSliceItem.value[length/2]
		return -1, floatSliceItem.time[length/2-1], float64(lowvalue) + float64(highvalue-lowvalue)/2, false
	}
	return -1, floatSliceItem.time[length/2], float64(floatSliceItem.value[length/2]), false
}

func NewIntegerMedianReduce(integerSliceItem *IntegerSliceItem) (int, int64, float64, bool) {
	length := len(integerSliceItem.value)
	if length == 0 {
		return -1, 0, 0, true
	}
	if length == 1 {
		return -1, integerSliceItem.time[0], float64(integerSliceItem.value[0]), false
	}

	sort.Stable(integerSliceItem)

	if length%2 == 0 {
		lowvalue, highvalue := integerSliceItem.value[length/2-1], integerSliceItem.value[length/2]
		return -1, integerSliceItem.time[length/2-1], float64(lowvalue) + float64(highvalue-lowvalue)/2, false
	}
	return -1, integerSliceItem.time[length/2], float64(integerSliceItem.value[length/2]), false
}

func NewFloatModeReduce(FloatSliceItem *FloatSliceItem) (int, int64, float64, bool) {
	length := len(FloatSliceItem.value)
	start := 0
	end := length - 1
	if length == 0 {
		return 0, 0, 0, true
	}

	sort.Stable(FloatSliceItem)
	curri := start
	currFreq := 0
	currValue := FloatSliceItem.value[start]
	modei := start
	modeFreq := 0
	for i := start; i <= end; i++ {
		if FloatSliceItem.value[i] != currValue {
			currFreq = 1
			currValue = FloatSliceItem.value[i]
			curri = i
			continue
		}
		currFreq++
		if modeFreq > currFreq || (modeFreq == currFreq && FloatSliceItem.time[curri] > FloatSliceItem.time[modei]) {
			continue
		}
		modeFreq = currFreq
		modei = curri
	}
	return modei, 0, 0, false
}

func NewIntegerModeReduce(IntegerSliceItem *IntegerSliceItem) (int, int64, float64, bool) {
	length := len(IntegerSliceItem.value)
	start := 0
	end := length - 1
	if length == 0 {
		return 0, 0, 0, true
	}

	sort.Stable(IntegerSliceItem)
	curri := start
	currFreq := 0
	currValue := IntegerSliceItem.value[start]
	modei := start
	modeFreq := 0
	for i := start; i <= end; i++ {
		if IntegerSliceItem.value[i] != currValue {
			currFreq = 1
			currValue = IntegerSliceItem.value[i]
			curri = i
			continue
		}
		currFreq++
		if modeFreq > currFreq || (modeFreq == currFreq && IntegerSliceItem.time[curri] > IntegerSliceItem.time[modei]) {
			continue
		}
		modeFreq = currFreq
		modei = curri
	}
	return modei, 0, 0, false
}

func NewStringModeReduce(StringSliceItem *StringSliceItem) (int, int64, float64, bool) {
	length := len(StringSliceItem.value)
	start := 0
	end := length - 1
	if length == 0 {
		return 0, 0, 0, true
	}

	sort.Stable(StringSliceItem)
	curri := start
	currFreq := 0
	currValue := StringSliceItem.value[start]
	modei := start
	modeFreq := 0
	for i := start; i <= end; i++ {
		if StringSliceItem.value[i] != currValue {
			currFreq = 1
			currValue = StringSliceItem.value[i]
			curri = i
			continue
		}
		currFreq++
		if modeFreq > currFreq || (modeFreq == currFreq && StringSliceItem.time[curri] > StringSliceItem.time[modei]) {
			continue
		}
		modeFreq = currFreq
		modei = curri
	}
	return modei, 0, 0, false
}

func NewBooleanModeReduce(BooleanSliceItem *BooleanSliceItem) (int, int64, float64, bool) {
	length := len(BooleanSliceItem.value)
	if length == 0 {
		return 0, 0, 0, true
	}
	if length == 1 {
		return 0, 0, 0, false
	}

	truei := -1
	TrueFreq := 0
	falsei := -1
	FalseFreq := 0
	for i := 0; i < length; i++ {
		if BooleanSliceItem.value[i] {
			if truei == -1 {
				truei = i
			}
			TrueFreq++
		} else {
			if falsei == -1 {
				falsei = i
			}
			FalseFreq++
		}
	}
	if TrueFreq >= FalseFreq {
		return truei, 0, 0, false
	}
	return falsei, 0, 0, false
}

func FloatCountReduce(c Chunk, ordinal, start, end int) (int, int64, bool) {
	var count int64
	if c.Column(ordinal).NilCount() == 0 {
		// fast path
		count = int64(end - start)
		return start, count, count == 0
	}

	// slow path
	vs, ve := c.Column(ordinal).GetRangeValueIndexV2(start, end)
	count = int64(ve - vs)
	return start, count, count == 0
}

func IntegerCountReduce(c Chunk, ordinal, start, end int) (int, int64, bool) {
	var count int64
	if c.Column(ordinal).NilCount() == 0 {
		// fast path
		count = int64(end - start)
		return start, count, count == 0
	}

	// slow path
	vs, ve := c.Column(ordinal).GetRangeValueIndexV2(start, end)
	count = int64(ve - vs)
	return start, count, count == 0
}

func StringCountReduce(c Chunk, ordinal, start, end int) (int, int64, bool) {
	var count int64
	if c.Column(ordinal).NilCount() == 0 {
		// fast path
		count = int64(end - start)
		return start, count, count == 0
	}

	// slow path
	vs, ve := c.Column(ordinal).GetRangeValueIndexV2(start, end)
	count = int64(ve - vs)
	return start, count, count == 0
}

func BooleanCountReduce(c Chunk, ordinal, start, end int) (int, int64, bool) {
	var count int64
	if c.Column(ordinal).NilCount() == 0 {
		// fast path
		count = int64(end - start)
		return start, count, count == 0
	}

	// slow path
	vs, ve := c.Column(ordinal).GetRangeValueIndexV2(start, end)
	count = int64(ve - vs)
	return start, count, count == 0
}

func IntegerCountMerge(prevPoint, currPoint *IntegerPoint) {
	if currPoint.isNil {
		return
	}
	if prevPoint.isNil {
		prevPoint.Assign(currPoint)
		prevPoint.isNil = false
		return
	}
	prevPoint.value += currPoint.value
}

func FloatSumReduce(c Chunk, ordinal, start, end int) (int, float64, bool) {
	var sum float64
	if c.Column(ordinal).NilCount() == 0 {
		// fast path
		for i := start; i < end; i++ {
			sum += c.Column(ordinal).FloatValue(i)
		}
		return start, sum, false
	}

	// slow path
	vs, ve := c.Column(ordinal).GetRangeValueIndexV2(start, end)
	if vs == ve {
		return start, 0, true
	}
	for i := vs; i < ve; i++ {
		sum += c.Column(ordinal).FloatValue(i)
	}
	return start, sum, false
}

func FloatSumMerge(prevPoint, currPoint *FloatPoint) {
	if currPoint.isNil {
		return
	}
	if prevPoint.isNil {
		prevPoint.Assign(currPoint)
		prevPoint.isNil = false
		return
	}
	prevPoint.value += currPoint.value
}

func IntegerSumReduce(c Chunk, ordinal, start, end int) (int, int64, bool) {
	var sum int64
	if c.Column(ordinal).NilCount() == 0 {
		// fast path
		for i := start; i < end; i++ {
			sum += c.Column(ordinal).IntegerValue(i)
		}
		return start, sum, false
	}

	// slow path
	vs, ve := c.Column(ordinal).GetRangeValueIndexV2(start, end)
	if vs == ve {
		return start, 0, true
	}
	for i := vs; i < ve; i++ {
		sum += c.Column(ordinal).IntegerValue(i)
	}
	return start, sum, false
}

func IntegerSumMerge(prevPoint, currPoint *IntegerPoint) {
	if currPoint.isNil {
		return
	}
	if prevPoint.isNil {
		prevPoint.Assign(currPoint)
		prevPoint.isNil = false
		return
	}
	prevPoint.value += currPoint.value
}

func FloatMinReduce(c Chunk, ordinal, start, end int) (int, float64, bool) {
	if c.Column(ordinal).NilCount() == 0 {
		// fast path
		minValue, minIndex := c.Column(ordinal).FloatValue(start), start
		for i := start; i < end; i++ {
			v := c.Column(ordinal).FloatValue(i)
			if v < minValue || (v == minValue && c.TimeByIndex(i) < c.TimeByIndex(minIndex)) {
				minIndex = i
				minValue = v
			}
		}
		return minIndex, minValue, false
	}

	// slow path
	vs, ve := c.Column(ordinal).GetRangeValueIndexV2(start, end)
	if vs == ve {
		return start, 0, true
	}
	minValue, minIndex := c.Column(ordinal).FloatValue(vs), c.Column(ordinal).GetTimeIndex(vs)
	for i := vs; i < ve; i++ {
		v, index := c.Column(ordinal).FloatValue(i), c.Column(ordinal).GetTimeIndex(i)
		if v < minValue || (v == minValue && c.TimeByIndex(index) < c.TimeByIndex(minIndex)) {
			minIndex = index
			minValue = v
		}
	}
	return minIndex, minValue, false
}

func FloatMinMerge(prevPoint, currPoint *FloatPoint) {
	if currPoint.isNil {
		return
	}
	if prevPoint.isNil || (currPoint.value < prevPoint.value) ||
		(currPoint.value == prevPoint.value && currPoint.time < prevPoint.time) {
		prevPoint.Assign(currPoint)
		prevPoint.isNil = false
	}
}

func IntegerMinReduce(c Chunk, ordinal, start, end int) (int, int64, bool) {
	if c.Column(ordinal).NilCount() == 0 {
		// fast path
		minValue, minIndex := c.Column(ordinal).IntegerValue(start), start
		for i := start; i < end; i++ {
			v := c.Column(ordinal).IntegerValue(i)
			if v < minValue || (v == minValue && c.TimeByIndex(i) < c.TimeByIndex(minIndex)) {
				minIndex = i
				minValue = v
			}
		}
		return minIndex, minValue, false
	}

	// slow path
	vs, ve := c.Column(ordinal).GetRangeValueIndexV2(start, end)
	if vs == ve {
		return start, 0, true
	}
	minValue, minIndex := c.Column(ordinal).IntegerValue(vs), c.Column(ordinal).GetTimeIndex(vs)
	for i := vs; i < ve; i++ {
		v, index := c.Column(ordinal).IntegerValue(i), c.Column(ordinal).GetTimeIndex(i)
		if v < minValue || (v == minValue && c.TimeByIndex(index) < c.TimeByIndex(minIndex)) {
			minIndex = index
			minValue = v
		}
	}
	return minIndex, minValue, false
}

func IntegerMinMerge(prevPoint, currPoint *IntegerPoint) {
	if currPoint.isNil {
		return
	}
	if prevPoint.isNil || (currPoint.value < prevPoint.value) ||
		(currPoint.value == prevPoint.value && currPoint.time < prevPoint.time) {
		prevPoint.Assign(currPoint)
		prevPoint.isNil = false
	}
}

func BooleanMinReduce(c Chunk, ordinal, start, end int) (int, bool, bool) {
	if c.Column(ordinal).NilCount() == 0 {
		// fast path
		minValue, minIndex := c.Column(ordinal).BooleanValue(start), start
		for i := start; i < end; i++ {
			v := c.Column(ordinal).BooleanValue(i)
			if (v != minValue && !v) || (v == minValue && c.TimeByIndex(i) < c.TimeByIndex(minIndex)) {
				minIndex = i
				minValue = v
			}
		}
		return minIndex, minValue, false
	}

	// slow path
	vs, ve := c.Column(ordinal).GetRangeValueIndexV2(start, end)
	if vs == ve {
		return start, false, true
	}
	minValue, minIndex := c.Column(ordinal).BooleanValue(vs), c.Column(ordinal).GetTimeIndex(vs)
	for i := vs; i < ve; i++ {
		v, index := c.Column(ordinal).BooleanValue(i), c.Column(ordinal).GetTimeIndex(i)
		if (v != minValue && !v) || (v == minValue && c.TimeByIndex(index) < c.TimeByIndex(minIndex)) {
			minIndex = index
			minValue = v
		}
	}
	return minIndex, minValue, false
}

func BooleanMinMerge(prevPoint, currPoint *BooleanPoint) {
	if currPoint.isNil {
		return
	}
	if prevPoint.isNil || (currPoint.value != prevPoint.value && !currPoint.value) ||
		(currPoint.value == prevPoint.value && currPoint.time < prevPoint.time) {
		prevPoint.Assign(currPoint)
		prevPoint.isNil = false
	}
}

func FloatMaxReduce(c Chunk, ordinal, start, end int) (int, float64, bool) {
	if c.Column(ordinal).NilCount() == 0 {
		// fast path
		maxValue, maxIndex := c.Column(ordinal).FloatValue(start), start
		for i := start; i < end; i++ {
			v := c.Column(ordinal).FloatValue(i)
			if v > maxValue || (v == maxValue && c.TimeByIndex(i) < c.TimeByIndex(maxIndex)) {
				maxIndex = i
				maxValue = v
			}
		}
		return maxIndex, maxValue, false
	}

	// slow path
	vs, ve := c.Column(ordinal).GetRangeValueIndexV2(start, end)
	if vs == ve {
		return start, 0, true
	}
	maxValue, maxIndex := c.Column(ordinal).FloatValue(vs), c.Column(ordinal).GetTimeIndex(vs)
	for i := vs; i < ve; i++ {
		v, index := c.Column(ordinal).FloatValue(i), c.Column(ordinal).GetTimeIndex(i)
		if v > maxValue || (v == maxValue && c.TimeByIndex(index) < c.TimeByIndex(maxIndex)) {
			maxIndex = index
			maxValue = v
		}
	}
	return maxIndex, maxValue, false
}

func FloatMaxMerge(prevPoint, currPoint *FloatPoint) {
	if currPoint.isNil {
		return
	}
	if prevPoint.isNil || (currPoint.value > prevPoint.value) ||
		(currPoint.value == prevPoint.value && currPoint.time < prevPoint.time) {
		prevPoint.Assign(currPoint)
		prevPoint.isNil = false
	}
}

func IntegerMaxReduce(c Chunk, ordinal, start, end int) (int, int64, bool) {
	if c.Column(ordinal).NilCount() == 0 {
		// fast path
		maxValue, maxIndex := c.Column(ordinal).IntegerValue(start), start
		for i := start; i < end; i++ {
			v := c.Column(ordinal).IntegerValue(i)
			if v > maxValue || (v == maxValue && c.TimeByIndex(i) < c.TimeByIndex(maxIndex)) {
				maxIndex = i
				maxValue = v
			}
		}
		return maxIndex, maxValue, false
	}

	// slow path
	vs, ve := c.Column(ordinal).GetRangeValueIndexV2(start, end)
	if vs == ve {
		return start, 0, true
	}
	maxValue, maxIndex := c.Column(ordinal).IntegerValue(vs), c.Column(ordinal).GetTimeIndex(vs)
	for i := vs; i < ve; i++ {
		v, index := c.Column(ordinal).IntegerValue(i), c.Column(ordinal).GetTimeIndex(i)
		if v > maxValue || (v == maxValue && c.TimeByIndex(index) < c.TimeByIndex(maxIndex)) {
			maxIndex = index
			maxValue = v
		}
	}
	return maxIndex, maxValue, false
}

func IntegerMaxMerge(prevPoint, currPoint *IntegerPoint) {
	if currPoint.isNil {
		return
	}
	if prevPoint.isNil || (currPoint.value > prevPoint.value) ||
		(currPoint.value == prevPoint.value && currPoint.time < prevPoint.time) {
		prevPoint.Assign(currPoint)
		prevPoint.isNil = false
	}
}

func BooleanMaxReduce(c Chunk, ordinal, start, end int) (int, bool, bool) {
	if c.Column(ordinal).NilCount() == 0 {
		// fast path
		maxValue, maxIndex := c.Column(ordinal).BooleanValue(start), start
		for i := start; i < end; i++ {
			v := c.Column(ordinal).BooleanValue(i)
			if (v != maxValue && v) || (v == maxValue && c.TimeByIndex(i) < c.TimeByIndex(maxIndex)) {
				maxIndex = i
				maxValue = v
			}
		}
		return maxIndex, maxValue, false
	}

	// slow path
	vs, ve := c.Column(ordinal).GetRangeValueIndexV2(start, end)
	if vs == ve {
		return start, false, true
	}
	maxValue, maxIndex := c.Column(ordinal).BooleanValue(vs), c.Column(ordinal).GetTimeIndex(vs)
	for i := vs; i < ve; i++ {
		v, index := c.Column(ordinal).BooleanValue(i), c.Column(ordinal).GetTimeIndex(i)
		if (v != maxValue && v) || (v == maxValue && c.TimeByIndex(index) < c.TimeByIndex(maxIndex)) {
			maxIndex = index
			maxValue = v
		}
	}
	return maxIndex, maxValue, false
}

func BooleanMaxMerge(prevPoint, currPoint *BooleanPoint) {
	if currPoint.isNil {
		return
	}
	if prevPoint.isNil || (currPoint.value != prevPoint.value && currPoint.value) ||
		(currPoint.value == prevPoint.value && currPoint.time < prevPoint.time) {
		prevPoint.Assign(currPoint)
		prevPoint.isNil = false
	}
}

func FloatFirstReduce(c Chunk, ordinal, start, end int) (int, float64, bool) {
	if c.Column(ordinal).NilCount() == 0 {
		// fast path
		firstValue, firstIndex := c.Column(ordinal).FloatValue(start), start
		for i := start; i < end; i++ {
			v := c.Column(ordinal).FloatValue(i)
			if c.TimeByIndex(i) < c.TimeByIndex(firstIndex) ||
				(c.TimeByIndex(i) == c.TimeByIndex(firstIndex) && v > firstValue) {
				firstIndex = i
				firstValue = v
			}
		}
		return firstIndex, firstValue, false
	}

	// slow path
	vs, ve := c.Column(ordinal).GetRangeValueIndexV2(start, end)
	if vs == ve {
		return start, 0, true
	}
	firstValue, firstIndex := c.Column(ordinal).FloatValue(vs), int(c.Column(ordinal).GetTimeIndex(vs))
	for i := vs; i < ve; i++ {
		v, index := c.Column(ordinal).FloatValue(i), int(c.Column(ordinal).GetTimeIndex(i))
		if c.TimeByIndex(index) < c.TimeByIndex(firstIndex) ||
			(c.TimeByIndex(index) == c.TimeByIndex(firstIndex) && v > firstValue) {
			firstIndex = index
			firstValue = v
		}
	}
	return firstIndex, firstValue, false
}

func FloatFirstMerge(prevPoint, currPoint *FloatPoint) {
	if prevPoint.isNil || (currPoint.time < prevPoint.time) ||
		(currPoint.time == prevPoint.time && currPoint.value > prevPoint.value) {
		prevPoint.Assign(currPoint)
	}
}

func IntegerFirstReduce(c Chunk, ordinal, start, end int) (int, int64, bool) {
	if c.Column(ordinal).NilCount() == 0 {
		// fast path
		firstValue, firstIndex := c.Column(ordinal).IntegerValue(start), start
		for i := start; i < end; i++ {
			v := c.Column(ordinal).IntegerValue(i)
			if c.TimeByIndex(i) < c.TimeByIndex(firstIndex) ||
				(c.TimeByIndex(i) == c.TimeByIndex(firstIndex) && v > firstValue) {
				firstIndex = i
				firstValue = v
			}
		}
		return firstIndex, firstValue, false
	}

	// slow path
	vs, ve := c.Column(ordinal).GetRangeValueIndexV2(start, end)
	if vs == ve {
		return start, 0, true
	}
	firstValue, firstIndex := c.Column(ordinal).IntegerValue(vs), int(c.Column(ordinal).GetTimeIndex(vs))
	for i := vs; i < ve; i++ {
		v, index := c.Column(ordinal).IntegerValue(i), int(c.Column(ordinal).GetTimeIndex(i))
		if c.TimeByIndex(index) < c.TimeByIndex(firstIndex) ||
			(c.TimeByIndex(index) == c.TimeByIndex(firstIndex) && v > firstValue) {
			firstIndex = index
			firstValue = v
		}
	}
	return firstIndex, firstValue, false
}

func IntegerFirstMerge(prevPoint, currPoint *IntegerPoint) {
	if prevPoint.isNil || (currPoint.time < prevPoint.time) ||
		(currPoint.time == prevPoint.time && currPoint.value > prevPoint.value) {
		prevPoint.Assign(currPoint)
	}
}

func StringFirstReduce(c Chunk, ordinal, start, end int) (int, string, bool) {
	if c.Column(ordinal).NilCount() == 0 {
		// fast path
		firstValue, firstIndex := c.Column(ordinal).StringValue(start), start
		for i := start; i < end; i++ {
			v := c.Column(ordinal).StringValue(i)
			if c.TimeByIndex(i) < c.TimeByIndex(firstIndex) ||
				(c.TimeByIndex(i) == c.TimeByIndex(firstIndex) && v > firstValue) {
				firstIndex = i
				firstValue = v
			}
		}
		return firstIndex, firstValue, false
	}

	// slow path
	vs, ve := c.Column(ordinal).GetRangeValueIndexV2(start, end)
	if vs == ve {
		return start, "", true
	}
	firstValue, firstIndex := c.Column(ordinal).StringValue(vs), int(c.Column(ordinal).GetTimeIndex(vs))
	for i := vs; i < ve; i++ {
		v, index := c.Column(ordinal).StringValue(i), int(c.Column(ordinal).GetTimeIndex(i))
		if c.TimeByIndex(index) < c.TimeByIndex(firstIndex) ||
			(c.TimeByIndex(index) == c.TimeByIndex(firstIndex) && v > firstValue) {
			firstIndex = index
			firstValue = v
		}
	}
	return firstIndex, firstValue, false
}

func StringFirstMerge(prevPoint, currPoint *StringPoint) {
	if prevPoint.isNil || (currPoint.time < prevPoint.time) ||
		(currPoint.time == prevPoint.time && bytes.Compare(currPoint.value, prevPoint.value) > 0) {
		prevPoint.Assign(currPoint)
	}
}

func BooleanFirstReduce(c Chunk, ordinal, start, end int) (int, bool, bool) {
	if c.Column(ordinal).NilCount() == 0 {
		// fast path
		firstValue, firstIndex := c.Column(ordinal).BooleanValue(start), start
		for i := start; i < end; i++ {
			v := c.Column(ordinal).BooleanValue(i)
			if c.TimeByIndex(i) < c.TimeByIndex(firstIndex) ||
				(c.TimeByIndex(i) == c.TimeByIndex(firstIndex) && !v && firstValue) {
				firstIndex = i
				firstValue = v
			}
		}
		return firstIndex, firstValue, false
	}

	// slow path
	vs, ve := c.Column(ordinal).GetRangeValueIndexV2(start, end)
	if vs == ve {
		return start, false, true
	}
	firstValue, firstIndex := c.Column(ordinal).BooleanValue(vs), int(c.Column(ordinal).GetTimeIndex(vs))
	for i := vs; i < ve; i++ {
		v, index := c.Column(ordinal).BooleanValue(i), int(c.Column(ordinal).GetTimeIndex(i))
		if c.TimeByIndex(index) < c.TimeByIndex(firstIndex) ||
			(c.TimeByIndex(index) == c.TimeByIndex(firstIndex) && !v && firstValue) {
			firstIndex = index
			firstValue = v
		}
	}
	return firstIndex, firstValue, false
}

func BooleanFirstMerge(prevPoint, currPoint *BooleanPoint) {
	if prevPoint.isNil || (currPoint.time < prevPoint.time) ||
		(currPoint.time == prevPoint.time && !currPoint.value && prevPoint.value) {
		prevPoint.Assign(currPoint)
	}
}

func FloatLastReduce(c Chunk, ordinal, start, end int) (int, float64, bool) {
	if c.Column(ordinal).NilCount() == 0 {
		// fast path
		lastValue, lastIndex := c.Column(ordinal).FloatValue(start), start
		for i := start; i < end; i++ {
			v := c.Column(ordinal).FloatValue(i)
			if c.TimeByIndex(i) > c.TimeByIndex(lastIndex) ||
				(c.TimeByIndex(i) == c.TimeByIndex(lastIndex) && v > lastValue) {
				lastIndex = i
				lastValue = v
			}
		}
		return lastIndex, lastValue, false
	}

	// slow path
	vs, ve := c.Column(ordinal).GetRangeValueIndexV2(start, end)
	if vs == ve {
		return start, 0, true
	}
	lastValue, lastIndex := c.Column(ordinal).FloatValue(vs), c.Column(ordinal).GetTimeIndex(vs)
	for i := vs; i < ve; i++ {
		v, index := c.Column(ordinal).FloatValue(i), c.Column(ordinal).GetTimeIndex(i)
		if c.TimeByIndex(index) > c.TimeByIndex(lastIndex) ||
			(c.TimeByIndex(index) == c.TimeByIndex(lastIndex) && v > lastValue) {
			lastIndex = index
			lastValue = v
		}
	}
	return lastIndex, lastValue, false
}

func FloatLastMerge(prevPoint, currPoint *FloatPoint) {
	if prevPoint.isNil || (currPoint.time > prevPoint.time) ||
		(currPoint.time == prevPoint.time && currPoint.value > prevPoint.value) {
		prevPoint.Assign(currPoint)
	}
}

func IntegerLastReduce(c Chunk, ordinal, start, end int) (int, int64, bool) {
	if c.Column(ordinal).NilCount() == 0 {
		// fast path
		lastValue, lastIndex := c.Column(ordinal).IntegerValue(start), start
		for i := start; i < end; i++ {
			v := c.Column(ordinal).IntegerValue(i)
			if c.TimeByIndex(i) > c.TimeByIndex(lastIndex) ||
				(c.TimeByIndex(i) == c.TimeByIndex(lastIndex) && v > lastValue) {
				lastIndex = i
				lastValue = v
			}
		}
		return lastIndex, lastValue, false
	}

	// slow path
	vs, ve := c.Column(ordinal).GetRangeValueIndexV2(start, end)
	if vs == ve {
		return start, 0, true
	}
	lastValue, lastIndex := c.Column(ordinal).IntegerValue(vs), c.Column(ordinal).GetTimeIndex(vs)
	for i := vs; i < ve; i++ {
		v, index := c.Column(ordinal).IntegerValue(i), c.Column(ordinal).GetTimeIndex(i)
		if c.TimeByIndex(index) > c.TimeByIndex(lastIndex) ||
			(c.TimeByIndex(index) == c.TimeByIndex(lastIndex) && v > lastValue) {
			lastIndex = index
			lastValue = v
		}
	}
	return lastIndex, lastValue, false
}

func IntegerLastMerge(prevPoint, currPoint *IntegerPoint) {
	if prevPoint.isNil || (currPoint.time > prevPoint.time) ||
		(currPoint.time == prevPoint.time && currPoint.value > prevPoint.value) {
		prevPoint.Assign(currPoint)
	}
}

func StringLastReduce(c Chunk, ordinal, start, end int) (int, string, bool) {
	if c.Column(ordinal).NilCount() == 0 {
		// fast path
		lastValue, lastIndex := c.Column(ordinal).StringValue(start), start
		for i := start; i < end; i++ {
			v := c.Column(ordinal).StringValue(i)
			if c.TimeByIndex(i) > c.TimeByIndex(lastIndex) ||
				(c.TimeByIndex(i) == c.TimeByIndex(lastIndex) && v > lastValue) {
				lastIndex = i
				lastValue = v
			}
		}
		return lastIndex, lastValue, false
	}

	// slow path
	vs, ve := c.Column(ordinal).GetRangeValueIndexV2(start, end)
	if vs == ve {
		return start, "", true
	}
	lastValue, lastIndex := c.Column(ordinal).StringValue(vs), c.Column(ordinal).GetTimeIndex(vs)
	for i := vs; i < ve; i++ {
		v, index := c.Column(ordinal).StringValue(i), c.Column(ordinal).GetTimeIndex(i)
		if c.TimeByIndex(index) > c.TimeByIndex(lastIndex) ||
			(c.TimeByIndex(index) == c.TimeByIndex(lastIndex) && v > lastValue) {
			lastIndex = index
			lastValue = v
		}
	}
	return lastIndex, lastValue, false
}

func StringLastMerge(prevPoint, currPoint *StringPoint) {
	if prevPoint.isNil || (currPoint.time > prevPoint.time) ||
		(currPoint.time == prevPoint.time && bytes.Compare(currPoint.value, prevPoint.value) > 0) {
		prevPoint.Assign(currPoint)
	}
}

func BooleanLastReduce(c Chunk, ordinal, start, end int) (int, bool, bool) {
	if c.Column(ordinal).NilCount() == 0 {
		// fast path
		lastValue, lastIndex := c.Column(ordinal).BooleanValue(start), start
		for i := start; i < end; i++ {
			v := c.Column(ordinal).BooleanValue(i)
			if c.TimeByIndex(i) > c.TimeByIndex(lastIndex) ||
				(c.TimeByIndex(i) == c.TimeByIndex(lastIndex) && v && !lastValue) {
				lastIndex = i
				lastValue = v
			}
		}
		return lastIndex, lastValue, false
	}

	// slow path
	vs, ve := c.Column(ordinal).GetRangeValueIndexV2(start, end)
	if vs == ve {
		return start, false, true
	}
	lastValue, lastIndex := c.Column(ordinal).BooleanValue(vs), c.Column(ordinal).GetTimeIndex(vs)
	for i := vs; i < ve; i++ {
		v, index := c.Column(ordinal).BooleanValue(i), c.Column(ordinal).GetTimeIndex(i)
		if c.TimeByIndex(index) > c.TimeByIndex(lastIndex) ||
			(c.TimeByIndex(index) == c.TimeByIndex(lastIndex) && v && !lastValue) {
			lastIndex = index
			lastValue = v
		}
	}
	return lastIndex, lastValue, false
}

func BooleanLastMerge(prevPoint, currPoint *BooleanPoint) {
	if prevPoint.isNil || (currPoint.time > prevPoint.time) ||
		(currPoint.time == prevPoint.time && currPoint.value && !prevPoint.value) {
		prevPoint.Assign(currPoint)
	}
}

func FloatFirstTimeColFastReduce(c Chunk, ordinal, start, end int) (int, float64, bool) {
	// fast path
	firstValue, firstIndex := c.Column(ordinal).FloatValue(start), start
	// column time is not initialized in the subquery
	if len(c.Column(ordinal).ColumnTimes()) == 0 {
		for i := start; i < end; i++ {
			v := c.Column(ordinal).FloatValue(i)
			if c.TimeByIndex(i) < c.TimeByIndex(firstIndex) ||
				(c.TimeByIndex(i) == c.TimeByIndex(firstIndex) && v > firstValue) {
				firstIndex = i
				firstValue = v
			}
		}
		return firstIndex, firstValue, false
	}
	// column time is initialized
	for i := start; i < end; i++ {
		v := c.Column(ordinal).FloatValue(i)
		if c.Column(ordinal).ColumnTime(i) < c.Column(ordinal).ColumnTime(firstIndex) ||
			(c.Column(ordinal).ColumnTime(i) == c.Column(ordinal).ColumnTime(firstIndex) && v > firstValue) {
			firstIndex = i
			firstValue = v
		}
	}
	return firstIndex, firstValue, false
}

func FloatFirstTimeColSlowReduce(c Chunk, ordinal, start, end int) (int, float64, bool) {
	// slow path
	vs, ve := c.Column(ordinal).GetRangeValueIndexV2(start, end)
	if vs == ve {
		return start, 0, true
	}
	// column time is not initialized in the subquery
	if len(c.Column(ordinal).ColumnTimes()) == 0 {
		firstValue, firstIndex := c.Column(ordinal).FloatValue(vs), c.Column(ordinal).GetTimeIndex(vs)
		for i := start; i < end; i++ {
			if c.Column(ordinal).IsNilV2(i) {
				continue
			}
			v := c.Column(ordinal).FloatValue(c.Column(ordinal).GetValueIndexV2(i))
			if c.TimeByIndex(i) < c.TimeByIndex(firstIndex) ||
				(c.TimeByIndex(i) == c.TimeByIndex(firstIndex) && v > firstValue) {
				firstIndex = i
				firstValue = v
			}
		}
		return firstIndex, firstValue, false
	}
	// column time is initialized
	firstValue, firstIndex := c.Column(ordinal).FloatValue(vs), vs
	for i := vs; i < ve; i++ {
		v := c.Column(ordinal).FloatValue(i)
		if c.Column(ordinal).ColumnTime(i) < c.Column(ordinal).ColumnTime(firstIndex) ||
			(c.Column(ordinal).ColumnTime(i) == c.Column(ordinal).ColumnTime(firstIndex) && v > firstValue) {
			firstIndex = i
			firstValue = v
		}
	}
	return firstIndex, firstValue, false
}

func FloatFirstTimeColReduce(c Chunk, ordinal, start, end int) (int, float64, bool) {
	if c.Column(ordinal).NilCount() == 0 {
		return FloatFirstTimeColFastReduce(c, ordinal, start, end)
	}
	return FloatFirstTimeColSlowReduce(c, ordinal, start, end)
}

func FloatFirstTimeColMerge(prevPoint, currPoint *FloatPoint) {
	if prevPoint.isNil || (currPoint.time < prevPoint.time) ||
		(currPoint.time == prevPoint.time && currPoint.value > prevPoint.value) {
		prevPoint.Assign(currPoint)
	}
}

func IntegerFirstTimeColFastReduce(c Chunk, ordinal, start, end int) (int, int64, bool) {
	// fast path
	firstValue, firstIndex := c.Column(ordinal).IntegerValue(start), start
	// column time is not initialized in the subquery
	if len(c.Column(ordinal).ColumnTimes()) == 0 {
		for i := start; i < end; i++ {
			v := c.Column(ordinal).IntegerValue(i)
			if c.TimeByIndex(i) < c.TimeByIndex(firstIndex) ||
				(c.TimeByIndex(i) == c.TimeByIndex(firstIndex) && v > firstValue) {
				firstIndex = i
				firstValue = v
			}
		}
		return firstIndex, firstValue, false
	}
	// column time is initialized
	for i := start; i < end; i++ {
		v := c.Column(ordinal).IntegerValue(i)
		if c.Column(ordinal).ColumnTime(i) < c.Column(ordinal).ColumnTime(firstIndex) ||
			(c.Column(ordinal).ColumnTime(i) == c.Column(ordinal).ColumnTime(firstIndex) && v > firstValue) {
			firstIndex = i
			firstValue = v
		}
	}
	return firstIndex, firstValue, false
}

func IntegerFirstTimeColSlowReduce(c Chunk, ordinal, start, end int) (int, int64, bool) {
	// slow path
	vs, ve := c.Column(ordinal).GetRangeValueIndexV2(start, end)
	if vs == ve {
		return start, 0, true
	}
	// column time is not initialized in the subquery
	if len(c.Column(ordinal).ColumnTimes()) == 0 {
		firstValue, firstIndex := c.Column(ordinal).IntegerValue(vs), c.Column(ordinal).GetTimeIndex(vs)
		for i := start; i < end; i++ {
			if c.Column(ordinal).IsNilV2(i) {
				continue
			}
			v := c.Column(ordinal).IntegerValue(c.Column(ordinal).GetValueIndexV2(i))
			if c.TimeByIndex(i) < c.TimeByIndex(firstIndex) ||
				(c.TimeByIndex(i) == c.TimeByIndex(firstIndex) && v > firstValue) {
				firstIndex = i
				firstValue = v
			}
		}
		return firstIndex, firstValue, false
	}
	// column time is initialized
	firstValue, firstIndex := c.Column(ordinal).IntegerValue(vs), vs
	for i := vs; i < ve; i++ {
		v := c.Column(ordinal).IntegerValue(i)
		if c.Column(ordinal).ColumnTime(i) < c.Column(ordinal).ColumnTime(firstIndex) ||
			(c.Column(ordinal).ColumnTime(i) == c.Column(ordinal).ColumnTime(firstIndex) && v > firstValue) {
			firstIndex = i
			firstValue = v
		}
	}
	return firstIndex, firstValue, false
}

func IntegerFirstTimeColReduce(c Chunk, ordinal, start, end int) (int, int64, bool) {
	if c.Column(ordinal).NilCount() == 0 {
		return IntegerFirstTimeColFastReduce(c, ordinal, start, end)
	}
	return IntegerFirstTimeColSlowReduce(c, ordinal, start, end)
}

func IntegerFirstTimeColMerge(prevPoint, currPoint *IntegerPoint) {
	if prevPoint.isNil || (currPoint.time < prevPoint.time) ||
		(currPoint.time == prevPoint.time && currPoint.value > prevPoint.value) {
		prevPoint.Assign(currPoint)
	}
}

func StringFirstTimeColFastReduce(c Chunk, ordinal, start, end int) (int, string, bool) {
	// fast path
	firstValue, firstIndex := c.Column(ordinal).StringValue(start), start
	// column time is not initialized in the subquery
	if len(c.Column(ordinal).ColumnTimes()) == 0 {
		for i := start; i < end; i++ {
			v := c.Column(ordinal).StringValue(i)
			if c.TimeByIndex(i) < c.TimeByIndex(firstIndex) ||
				(c.TimeByIndex(i) == c.TimeByIndex(firstIndex) && v > firstValue) {
				firstIndex = i
				firstValue = v
			}
		}
		return firstIndex, firstValue, false
	}
	// column time is initialized
	for i := start; i < end; i++ {
		v := c.Column(ordinal).StringValue(i)
		if c.Column(ordinal).ColumnTime(i) < c.Column(ordinal).ColumnTime(firstIndex) ||
			(c.Column(ordinal).ColumnTime(i) == c.Column(ordinal).ColumnTime(firstIndex) && v > firstValue) {
			firstIndex = i
			firstValue = v
		}
	}
	return firstIndex, firstValue, false
}

func StringFirstTimeColSlowReduce(c Chunk, ordinal, start, end int) (int, string, bool) {
	// slow path
	vs, ve := c.Column(ordinal).GetRangeValueIndexV2(start, end)
	if vs == ve {
		return start, "", true
	}
	// column time is not initialized in the subquery
	if len(c.Column(ordinal).ColumnTimes()) == 0 {
		firstValue, firstIndex := c.Column(ordinal).StringValue(vs), c.Column(ordinal).GetTimeIndex(vs)
		for i := start; i < end; i++ {
			if c.Column(ordinal).IsNilV2(i) {
				continue
			}
			v := c.Column(ordinal).StringValue(c.Column(ordinal).GetValueIndexV2(i))
			if c.TimeByIndex(i) < c.TimeByIndex(firstIndex) ||
				(c.TimeByIndex(i) == c.TimeByIndex(firstIndex) && v > firstValue) {
				firstIndex = i
				firstValue = v
			}
		}
		return firstIndex, firstValue, false
	}
	// column time is initialized
	firstValue, firstIndex := c.Column(ordinal).StringValue(vs), vs
	for i := vs; i < ve; i++ {
		v := c.Column(ordinal).StringValue(i)
		if c.Column(ordinal).ColumnTime(i) < c.Column(ordinal).ColumnTime(firstIndex) ||
			(c.Column(ordinal).ColumnTime(i) == c.Column(ordinal).ColumnTime(firstIndex) && v > firstValue) {
			firstIndex = i
			firstValue = v
		}
	}
	return firstIndex, firstValue, false
}

func StringFirstTimeColReduce(c Chunk, ordinal, start, end int) (int, string, bool) {
	if c.Column(ordinal).NilCount() == 0 {
		return StringFirstTimeColFastReduce(c, ordinal, start, end)
	}
	return StringFirstTimeColSlowReduce(c, ordinal, start, end)
}

func StringFirstTimeColMerge(prevPoint, currPoint *StringPoint) {
	if prevPoint.isNil || (currPoint.time < prevPoint.time) ||
		(currPoint.time == prevPoint.time && bytes.Compare(currPoint.value, prevPoint.value) > 0) {
		prevPoint.Assign(currPoint)
	}
}

func BooleanFirstTimeColFastReduce(c Chunk, ordinal, start, end int) (int, bool, bool) {
	// fast path
	firstValue, firstIndex := c.Column(ordinal).BooleanValue(start), start
	// column time is not initialized in the subquery
	if len(c.Column(ordinal).ColumnTimes()) == 0 {
		for i := start; i < end; i++ {
			v := c.Column(ordinal).BooleanValue(i)
			if c.TimeByIndex(i) < c.TimeByIndex(firstIndex) ||
				(c.TimeByIndex(i) == c.TimeByIndex(firstIndex) && !v && firstValue) {
				firstIndex = i
				firstValue = v
			}
		}
		return firstIndex, firstValue, false
	}
	for i := start; i < end; i++ {
		v := c.Column(ordinal).BooleanValue(i)
		if c.Column(ordinal).ColumnTime(i) < c.Column(ordinal).ColumnTime(firstIndex) ||
			(c.Column(ordinal).ColumnTime(i) == c.Column(ordinal).ColumnTime(firstIndex) && !v && firstValue) {
			firstIndex = i
			firstValue = v
		}
	}
	return firstIndex, firstValue, false
}

func BooleanFirstTimeColSlowReduce(c Chunk, ordinal, start, end int) (int, bool, bool) {
	// slow path
	vs, ve := c.Column(ordinal).GetRangeValueIndexV2(start, end)
	if vs == ve {
		return start, false, true
	}
	// column time is not initialized in the subquery
	if len(c.Column(ordinal).ColumnTimes()) == 0 {
		firstValue, firstIndex := c.Column(ordinal).BooleanValue(vs), c.Column(ordinal).GetTimeIndex(vs)
		for i := start; i < end; i++ {
			if c.Column(ordinal).IsNilV2(i) {
				continue
			}
			v := c.Column(ordinal).BooleanValue(c.Column(ordinal).GetValueIndexV2(i))
			if c.TimeByIndex(i) < c.TimeByIndex(firstIndex) ||
				(c.TimeByIndex(i) == c.TimeByIndex(firstIndex) && !v && firstValue) {
				firstIndex = i
				firstValue = v
			}
		}
		return firstIndex, firstValue, false
	}
	// column time is initialized
	firstValue, firstIndex := c.Column(ordinal).BooleanValue(vs), vs
	for i := vs; i < ve; i++ {
		v := c.Column(ordinal).BooleanValue(i)
		if c.Column(ordinal).ColumnTime(i) < c.Column(ordinal).ColumnTime(firstIndex) ||
			(c.Column(ordinal).ColumnTime(i) == c.Column(ordinal).ColumnTime(firstIndex) && !v && firstValue) {
			firstIndex = i
			firstValue = v
		}
	}
	return firstIndex, firstValue, false
}

func BooleanFirstTimeColReduce(c Chunk, ordinal, start, end int) (int, bool, bool) {
	if c.Column(ordinal).NilCount() == 0 {
		return BooleanFirstTimeColFastReduce(c, ordinal, start, end)
	}
	return BooleanFirstTimeColSlowReduce(c, ordinal, start, end)
}

func BooleanFirstTimeColMerge(prevPoint, currPoint *BooleanPoint) {
	if prevPoint.isNil || (currPoint.time < prevPoint.time) ||
		(currPoint.time == prevPoint.time && !currPoint.value && prevPoint.value) {
		prevPoint.Assign(currPoint)
	}
}

func FloatLastTimeColFastReduce(c Chunk, ordinal, start, end int) (int, float64, bool) {
	// fast path
	lastValue, lastIndex := c.Column(ordinal).FloatValue(start), start
	// column time is not initialized in the subquery
	if len(c.Column(ordinal).ColumnTimes()) == 0 {
		for i := start; i < end; i++ {
			v := c.Column(ordinal).FloatValue(i)
			if c.TimeByIndex(i) > c.TimeByIndex(lastIndex) ||
				(c.TimeByIndex(i) == c.TimeByIndex(lastIndex) && v > lastValue) {
				lastIndex = i
				lastValue = v
			}
		}
		return lastIndex, lastValue, false
	}
	// column time is initialized
	for i := start; i < end; i++ {
		v := c.Column(ordinal).FloatValue(i)
		if c.Column(ordinal).ColumnTime(i) > c.Column(ordinal).ColumnTime(lastIndex) ||
			(c.Column(ordinal).ColumnTime(i) == c.Column(ordinal).ColumnTime(lastIndex) && v > lastValue) {
			lastIndex = i
			lastValue = v
		}
	}
	return lastIndex, lastValue, false
}

func FloatLastTimeColSlowReduce(c Chunk, ordinal, start, end int) (int, float64, bool) {
	// slow path
	vs, ve := c.Column(ordinal).GetRangeValueIndexV2(start, end)
	if vs == ve {
		return start, 0, true
	}
	// column time is not initialized in the subquery
	if len(c.Column(ordinal).ColumnTimes()) == 0 {
		lastValue, lastIndex := c.Column(ordinal).FloatValue(vs), c.Column(ordinal).GetTimeIndex(vs)
		for i := start; i < end; i++ {
			if c.Column(ordinal).IsNilV2(i) {
				continue
			}
			v := c.Column(ordinal).FloatValue(c.Column(ordinal).GetValueIndexV2(i))
			if c.TimeByIndex(i) > c.TimeByIndex(lastIndex) ||
				(c.TimeByIndex(i) == c.TimeByIndex(lastIndex) && v > lastValue) {
				lastIndex = i
				lastValue = v
			}
		}
		return lastIndex, lastValue, false
	}
	// column time is initialized
	lastValue, lastIndex := c.Column(ordinal).FloatValue(vs), vs
	for i := vs; i < ve; i++ {
		v := c.Column(ordinal).FloatValue(i)
		if c.Column(ordinal).ColumnTime(i) > c.Column(ordinal).ColumnTime(lastIndex) ||
			(c.Column(ordinal).ColumnTime(i) == c.Column(ordinal).ColumnTime(lastIndex) && v > lastValue) {
			lastIndex = i
			lastValue = v
		}
	}
	return lastIndex, lastValue, false
}

func FloatLastTimeColReduce(c Chunk, ordinal, start, end int) (int, float64, bool) {
	if c.Column(ordinal).NilCount() == 0 {
		return FloatLastTimeColFastReduce(c, ordinal, start, end)
	}
	return FloatLastTimeColSlowReduce(c, ordinal, start, end)
}

func FloatLastTimeColMerge(prevPoint, currPoint *FloatPoint) {
	if prevPoint.isNil || (currPoint.time > prevPoint.time) ||
		(currPoint.time == prevPoint.time && currPoint.value > prevPoint.value) {
		prevPoint.Assign(currPoint)
	}
}

func IntegerLastTimeColFastReduce(c Chunk, ordinal, start, end int) (int, int64, bool) {
	// fast path
	lastValue, lastIndex := c.Column(ordinal).IntegerValue(start), start
	// column time is not initialized in the subquery
	if len(c.Column(ordinal).ColumnTimes()) == 0 {
		for i := start; i < end; i++ {
			v := c.Column(ordinal).IntegerValue(i)
			if c.TimeByIndex(i) > c.TimeByIndex(lastIndex) ||
				(c.TimeByIndex(i) == c.TimeByIndex(lastIndex) && v > lastValue) {
				lastIndex = i
				lastValue = v
			}
		}
		return lastIndex, lastValue, false
	}
	// column time is initialized
	for i := start; i < end; i++ {
		v := c.Column(ordinal).IntegerValue(i)
		if c.Column(ordinal).ColumnTime(i) > c.Column(ordinal).ColumnTime(lastIndex) ||
			(c.Column(ordinal).ColumnTime(i) == c.Column(ordinal).ColumnTime(lastIndex) && v > lastValue) {
			lastIndex = i
			lastValue = v
		}
	}
	return lastIndex, lastValue, false
}

func IntegerLastTimeColSlowReduce(c Chunk, ordinal, start, end int) (int, int64, bool) {
	// slow path
	vs, ve := c.Column(ordinal).GetRangeValueIndexV2(start, end)
	if vs == ve {
		return start, 0, true
	}
	// column time is not initialized in the subquery
	if len(c.Column(ordinal).ColumnTimes()) == 0 {
		lastValue, lastIndex := c.Column(ordinal).IntegerValue(vs), c.Column(ordinal).GetTimeIndex(vs)
		for i := start; i < end; i++ {
			if c.Column(ordinal).IsNilV2(i) {
				continue
			}
			v := c.Column(ordinal).IntegerValue(c.Column(ordinal).GetValueIndexV2(i))
			if c.TimeByIndex(i) > c.TimeByIndex(lastIndex) ||
				(c.TimeByIndex(i) == c.TimeByIndex(lastIndex) && v > lastValue) {
				lastIndex = i
				lastValue = v
			}
		}
		return lastIndex, lastValue, false
	}
	// column time is initialized
	lastValue, lastIndex := c.Column(ordinal).IntegerValue(vs), vs
	for i := vs; i < ve; i++ {
		v := c.Column(ordinal).IntegerValue(i)
		if c.Column(ordinal).ColumnTime(i) > c.Column(ordinal).ColumnTime(lastIndex) ||
			(c.Column(ordinal).ColumnTime(i) == c.Column(ordinal).ColumnTime(lastIndex) && v > lastValue) {
			lastIndex = i
			lastValue = v
		}
	}
	return lastIndex, lastValue, false
}

func IntegerLastTimeColReduce(c Chunk, ordinal, start, end int) (int, int64, bool) {
	if c.Column(ordinal).NilCount() == 0 {
		return IntegerLastTimeColFastReduce(c, ordinal, start, end)
	}
	return IntegerLastTimeColSlowReduce(c, ordinal, start, end)
}

func IntegerLastTimeColMerge(prevPoint, currPoint *IntegerPoint) {
	if prevPoint.isNil || (currPoint.time > prevPoint.time) ||
		(currPoint.time == prevPoint.time && currPoint.value > prevPoint.value) {
		prevPoint.Assign(currPoint)
	}
}

func StringLastTimeColFastReduce(c Chunk, ordinal, start, end int) (int, string, bool) {
	// fast path
	lastValue, lastIndex := c.Column(ordinal).StringValue(start), start
	// column time is not initialized in the subquery
	if len(c.Column(ordinal).ColumnTimes()) == 0 {
		for i := start; i < end; i++ {
			v := c.Column(ordinal).StringValue(i)
			if c.TimeByIndex(i) > c.TimeByIndex(lastIndex) ||
				(c.TimeByIndex(i) == c.TimeByIndex(lastIndex) && v > lastValue) {
				lastIndex = i
				lastValue = v
			}
		}
		return lastIndex, lastValue, false
	}
	// column time is initialized
	for i := start; i < end; i++ {
		v := c.Column(ordinal).StringValue(i)
		if c.Column(ordinal).ColumnTime(i) > c.Column(ordinal).ColumnTime(lastIndex) ||
			(c.Column(ordinal).ColumnTime(i) == c.Column(ordinal).ColumnTime(lastIndex) && v > lastValue) {
			lastIndex = i
			lastValue = v
		}
	}
	return lastIndex, lastValue, false
}

func StringLastTimeColSlowReduce(c Chunk, ordinal, start, end int) (int, string, bool) {
	// slow path
	vs, ve := c.Column(ordinal).GetRangeValueIndexV2(start, end)
	if vs == ve {
		return start, "", true
	}
	// column time is not initialized in the subquery
	if len(c.Column(ordinal).ColumnTimes()) == 0 {
		lastValue, lastIndex := c.Column(ordinal).StringValue(vs), c.Column(ordinal).GetTimeIndex(vs)
		for i := start; i < end; i++ {
			if c.Column(ordinal).IsNilV2(i) {
				continue
			}
			v := c.Column(ordinal).StringValue(c.Column(ordinal).GetValueIndexV2(i))
			if c.TimeByIndex(i) > c.TimeByIndex(lastIndex) ||
				(c.TimeByIndex(i) == c.TimeByIndex(lastIndex) && v > lastValue) {
				lastIndex = i
				lastValue = v
			}
		}
		return lastIndex, lastValue, false
	}
	// column time is initialized
	lastValue, lastIndex := c.Column(ordinal).StringValue(vs), vs
	for i := vs; i < ve; i++ {
		v := c.Column(ordinal).StringValue(i)
		if c.Column(ordinal).ColumnTime(i) > c.Column(ordinal).ColumnTime(lastIndex) ||
			(c.Column(ordinal).ColumnTime(i) == c.Column(ordinal).ColumnTime(lastIndex) && v > lastValue) {
			lastIndex = i
			lastValue = v
		}
	}
	return lastIndex, lastValue, false
}

func StringLastTimeColReduce(c Chunk, ordinal, start, end int) (int, string, bool) {
	if c.Column(ordinal).NilCount() == 0 {
		return StringLastTimeColFastReduce(c, ordinal, start, end)
	}
	return StringLastTimeColSlowReduce(c, ordinal, start, end)
}

func StringLastTimeColMerge(prevPoint, currPoint *StringPoint) {
	if prevPoint.isNil || (currPoint.time > prevPoint.time) ||
		(currPoint.time == prevPoint.time && bytes.Compare(currPoint.value, prevPoint.value) > 0) {
		prevPoint.Assign(currPoint)
	}
}

func BooleanLastTimeColFastReduce(c Chunk, ordinal, start, end int) (int, bool, bool) {
	// fast path
	lastValue, lastIndex := c.Column(ordinal).BooleanValue(start), start
	// column time is not initialized in the subquery
	if len(c.Column(ordinal).ColumnTimes()) == 0 {
		for i := start; i < end; i++ {
			v := c.Column(ordinal).BooleanValue(i)
			if c.TimeByIndex(i) > c.TimeByIndex(lastIndex) ||
				(c.TimeByIndex(i) == c.TimeByIndex(lastIndex) && v && !lastValue) {
				lastIndex = i
				lastValue = v
			}
		}
		return lastIndex, lastValue, false
	}
	// column time is initialized
	for i := start; i < end; i++ {
		v := c.Column(ordinal).BooleanValue(i)
		if c.Column(ordinal).ColumnTime(i) > c.Column(ordinal).ColumnTime(lastIndex) ||
			(c.Column(ordinal).ColumnTime(i) == c.Column(ordinal).ColumnTime(lastIndex) && v && !lastValue) {
			lastIndex = i
			lastValue = v
		}
	}
	return lastIndex, lastValue, false
}

func BooleanLastTimeColSlowReduce(c Chunk, ordinal, start, end int) (int, bool, bool) {
	// slow path
	vs, ve := c.Column(ordinal).GetRangeValueIndexV2(start, end)
	if vs == ve {
		return start, false, true
	}
	// column time is not initialized in the subquery
	if len(c.Column(ordinal).ColumnTimes()) == 0 {
		lastValue, lastIndex := c.Column(ordinal).BooleanValue(vs), c.Column(ordinal).GetTimeIndex(vs)
		for i := start; i < end; i++ {
			if c.Column(ordinal).IsNilV2(i) {
				continue
			}
			v := c.Column(ordinal).BooleanValue(c.Column(ordinal).GetValueIndexV2(i))
			if c.TimeByIndex(i) > c.TimeByIndex(lastIndex) ||
				(c.TimeByIndex(i) == c.TimeByIndex(lastIndex) && v && !lastValue) {
				lastIndex = i
				lastValue = v
			}
		}
		return lastIndex, lastValue, false
	}
	// column time is initialized
	lastValue, lastIndex := c.Column(ordinal).BooleanValue(vs), vs
	for i := vs; i < ve; i++ {
		v := c.Column(ordinal).BooleanValue(i)
		if c.Column(ordinal).ColumnTime(i) > c.Column(ordinal).ColumnTime(lastIndex) ||
			(c.Column(ordinal).ColumnTime(i) == c.Column(ordinal).ColumnTime(lastIndex) && v && !lastValue) {
			lastIndex = i
			lastValue = v
		}
	}
	return lastIndex, lastValue, false
}

func BooleanLastTimeColReduce(c Chunk, ordinal, start, end int) (int, bool, bool) {
	if c.Column(ordinal).NilCount() == 0 {
		return BooleanLastTimeColFastReduce(c, ordinal, start, end)
	}
	return BooleanLastTimeColSlowReduce(c, ordinal, start, end)
}

func BooleanLastTimeColMerge(prevPoint, currPoint *BooleanPoint) {
	if prevPoint.isNil || (currPoint.time > prevPoint.time) ||
		(currPoint.time == prevPoint.time && currPoint.value && !prevPoint.value) {
		prevPoint.Assign(currPoint)
	}
}

func NewFloatPercentileReduce(percentile float64) FloatColReduceSliceReduce {
	return func(floatSliceItem *FloatSliceItem) (int, int64, float64, bool) {
		length := len(floatSliceItem.value)
		if length == 0 {
			return 0, int64(0), float64(0), true
		}

		sort.Sort(floatSliceItem)

		i := int(math.Floor(float64(length)*percentile/100.0+0.5)) - 1
		if i < 0 {
			i = 0
		} else if i >= length {
			i = length - 1
		}
		return i, int64(0), float64(0), false
	}
}

func NewIntegerPercentileReduce(percentile float64) IntegerColReduceSliceReduce {
	return func(integerSliceItem *IntegerSliceItem) (int, int64, float64, bool) {
		length := len(integerSliceItem.value)
		if length == 0 {
			return 0, int64(0), float64(0), true
		}

		sort.Sort(integerSliceItem)

		i := int(math.Floor(float64(length)*percentile/100.0+0.5)) - 1
		if i < 0 {
			i = 0
		} else if i >= length {
			i = length - 1
		}
		return i, int64(0), float64(0), false
	}
}

func NewFloatStddevReduce() FloatColReduceSliceReduce {
	return func(floatSliceItem *FloatSliceItem) (int, int64, float64, bool) {
		length := len(floatSliceItem.value)
		if length == 1 {
			return -1, int64(0), float64(0), false
		} else if length == 0 {
			return -1, int64(0), float64(0), true
		} else {
			sum := float64(0)
			sum2 := float64(0)
			count := float64(length)
			stddev := float64(0)
			for _, v := range floatSliceItem.value {
				sum += v
				sum2 += v * v
			}
			stddev = math.Sqrt((sum2/count - math.Pow(sum/count, 2)) * count / (count - 1))
			return -1, int64(0), stddev, false
		}
	}
}

func NewIntegerStddevReduce() IntegerColReduceSliceReduce {
	return func(integerSliceItem *IntegerSliceItem) (int, int64, float64, bool) {
		length := len(integerSliceItem.value)
		if length == 1 {
			return -1, int64(0), float64(0), false
		} else if length == 0 {
			return -1, int64(0), float64(0), true
		} else {
			sum := int64(0)
			sum2 := int64(0)
			count := float64(length)
			stddev := float64(0)
			for _, v := range integerSliceItem.value {
				sum += v
				sum2 += v * v
			}
			stddev = math.Sqrt((float64(sum2)/count - math.Pow(float64(sum)/count, 2)) * count / (count - 1))
			return -1, int64(0), stddev, false
		}
	}
}

func FloatRateFastReduce(c Chunk, ordinal, start, end int) (int, int, float64, float64, bool) {
	if end-start == 0 {
		return 0, 0, 0, 0, true
	}
	firstValue, firstIndex := c.Column(ordinal).FloatValue(start), start
	lastValue, lastIndex := firstValue, firstIndex
	for i := start; i < end; i++ {
		v := c.Column(ordinal).FloatValue(i)
		if c.TimeByIndex(i) < c.TimeByIndex(firstIndex) ||
			(c.TimeByIndex(i) == c.TimeByIndex(firstIndex) && v > firstValue) {
			firstIndex = i
			firstValue = v
		}
		if c.TimeByIndex(i) > c.TimeByIndex(lastIndex) ||
			(c.TimeByIndex(i) == c.TimeByIndex(lastIndex) && v > lastValue) {
			lastIndex = i
			lastValue = v
		}
	}
	return firstIndex, lastIndex, firstValue, lastValue, false
}

func FloatRateLowReduce(c Chunk, ordinal, start, end int) (int, int, float64, float64, bool) {
	vs, ve := c.Column(ordinal).GetRangeValueIndexV2(start, end)
	if vs == ve {
		return 0, 0, 0, 0, true
	}
	firstValue, firstIndex := c.Column(ordinal).FloatValue(vs), c.Column(ordinal).GetTimeIndex(vs)
	lastValue, lastIndex := firstValue, firstIndex
	for i := vs; i < ve; i++ {
		v, index := c.Column(ordinal).FloatValue(i), c.Column(ordinal).GetTimeIndex(i)
		if c.TimeByIndex(index) < c.TimeByIndex(firstIndex) ||
			(c.TimeByIndex(index) == c.TimeByIndex(firstIndex) && v > firstValue) {
			firstIndex = index
			firstValue = v
		}
		if c.TimeByIndex(index) > c.TimeByIndex(lastIndex) ||
			(c.TimeByIndex(index) == c.TimeByIndex(lastIndex) && v > lastValue) {
			lastIndex = index
			lastValue = v
		}
	}
	return firstIndex, lastIndex, firstValue, lastValue, false
}

func FloatRateMiddleReduce(c Chunk, ordinal, start, end int) (int, int, float64, float64, bool) {
	if c.Column(ordinal).NilCount() == 0 {
		// fast path
		return FloatRateFastReduce(c, ordinal, start, end)
	}

	// slow path
	return FloatRateLowReduce(c, ordinal, start, end)
}

func FloatRateFinalReduce(firstTime int64, lastTime int64, firstValue float64, lastValue float64,
	interval *hybridqp.Interval) (float64, bool) {
	if lastTime == firstTime || interval.Duration == 0 {
		return 0, true
	}
	rate := float64(lastValue-firstValue) / (float64(lastTime-firstTime) / float64(interval.Duration))
	return rate, false
}

func FloatRateUpdate(prevPoints, currPoints [2]*FloatPoint) {
	for i := range currPoints {
		if currPoints[i].isNil {
			continue
		}
		if currPoints[i].time < prevPoints[0].time ||
			(currPoints[i].time == prevPoints[0].time && currPoints[i].value > prevPoints[0].value) {
			prevPoints[0].time = currPoints[i].time
			prevPoints[0].value = currPoints[i].value
		}
		if currPoints[i].time > prevPoints[1].time ||
			(currPoints[i].time == prevPoints[1].time && currPoints[i].value > prevPoints[1].value) {
			prevPoints[1].time = currPoints[i].time
			prevPoints[1].value = currPoints[i].value
		}
	}
}

func FloatRateMerge(prevPoints [2]*FloatPoint, interval *hybridqp.Interval) (float64, bool) {
	return FloatRateFinalReduce(prevPoints[0].time, prevPoints[1].time,
		prevPoints[0].value, prevPoints[1].value, interval)
}

func IntegerRateFastReduce(c Chunk, ordinal, start, end int) (int, int, int64, int64, bool) {
	if end-start == 0 {
		return 0, 0, 0, 0, true
	}
	firstValue, firstIndex := c.Column(ordinal).IntegerValue(start), start
	lastValue, lastIndex := firstValue, firstIndex
	for i := start; i < end; i++ {
		v := c.Column(ordinal).IntegerValue(i)
		if c.TimeByIndex(i) < c.TimeByIndex(firstIndex) ||
			(c.TimeByIndex(i) == c.TimeByIndex(firstIndex) && v > firstValue) {
			firstIndex = i
			firstValue = v
		}
		if c.TimeByIndex(i) > c.TimeByIndex(lastIndex) ||
			(c.TimeByIndex(i) == c.TimeByIndex(lastIndex) && v > lastValue) {
			lastIndex = i
			lastValue = v
		}
	}
	return firstIndex, lastIndex, firstValue, lastValue, false
}

func IntegerRateLowReduce(c Chunk, ordinal, start, end int) (int, int, int64, int64, bool) {
	vs, ve := c.Column(ordinal).GetRangeValueIndexV2(start, end)
	if vs == ve {
		return 0, 0, 0, 0, true
	}
	firstValue, firstIndex := c.Column(ordinal).IntegerValue(vs), c.Column(ordinal).GetTimeIndex(vs)
	lastValue, lastIndex := firstValue, firstIndex
	for i := vs; i < ve; i++ {
		v, index := c.Column(ordinal).IntegerValue(i), c.Column(ordinal).GetTimeIndex(i)
		if c.TimeByIndex(index) < c.TimeByIndex(firstIndex) ||
			(c.TimeByIndex(index) == c.TimeByIndex(firstIndex) && v > firstValue) {
			firstIndex = index
			firstValue = v
		}
		if c.TimeByIndex(index) > c.TimeByIndex(lastIndex) ||
			(c.TimeByIndex(index) == c.TimeByIndex(lastIndex) && v > lastValue) {
			lastIndex = index
			lastValue = v
		}
	}
	return firstIndex, lastIndex, firstValue, lastValue, false
}

func IntegerRateMiddleReduce(c Chunk, ordinal, start, end int) (int, int, int64, int64, bool) {
	if c.Column(ordinal).NilCount() == 0 {
		// fast path
		return IntegerRateFastReduce(c, ordinal, start, end)
	}

	// slow path
	return IntegerRateLowReduce(c, ordinal, start, end)
}

func IntegerRateFinalReduce(firstTime int64, lastTime int64, firstValue int64, lastValue int64,
	interval *hybridqp.Interval) (float64, bool) {
	if lastTime == firstTime || interval.Duration == 0 {
		return 0, true
	}
	rate := float64(lastValue-firstValue) / (float64(lastTime-firstTime) / float64(interval.Duration))
	return rate, false
}

func IntegerRateUpdate(prevPoints, currPoints [2]*IntegerPoint) {
	for i := range currPoints {
		if currPoints[i].isNil {
			continue
		}
		if currPoints[i].time < prevPoints[0].time ||
			(currPoints[i].time == prevPoints[0].time && currPoints[i].value > prevPoints[0].value) {
			prevPoints[0].time = currPoints[i].time
			prevPoints[0].value = currPoints[i].value
		}
		if currPoints[i].time > prevPoints[1].time ||
			(currPoints[i].time == prevPoints[1].time && currPoints[i].value > prevPoints[1].value) {
			prevPoints[1].time = currPoints[i].time
			prevPoints[1].value = currPoints[i].value
		}
	}
}

func IntegerRateMerge(prevPoints [2]*IntegerPoint, interval *hybridqp.Interval) (float64, bool) {
	return IntegerRateFinalReduce(prevPoints[0].time, prevPoints[1].time,
		prevPoints[0].value, prevPoints[1].value, interval)
}

func FloatIrateFastReduce(c Chunk, ordinal, start, end int) (int, int, float64, float64, bool) {
	if end-start == 0 {
		return 0, 0, 0, 0, true
	}
	if end-start == 1 {
		col := c.Column(ordinal)
		v := col.FloatValue(start)
		return start, start, v, v, false
	}
	var (
		fi, si int
		fv, sv float64
	)
	if c.TimeByIndex(start) < c.TimeByIndex(start+1) || (c.TimeByIndex(start) == c.TimeByIndex(start+1) && fv > sv) {
		fi, si, fv, sv = start, start+1, c.Column(ordinal).FloatValue(start), c.Column(ordinal).FloatValue(start+1)
	} else {
		fi, si, fv, sv = start+1, start, c.Column(ordinal).FloatValue(start+1), c.Column(ordinal).FloatValue(start)
	}
	if end-start == 2 {
		return fi, si, fv, sv, false
	}
	for i := start + 2; i < end; i++ {
		v := c.Column(ordinal).FloatValue(i)
		if c.TimeByIndex(i) < c.TimeByIndex(fi) ||
			(c.TimeByIndex(i) == c.TimeByIndex(fi) && v < fv) {
			continue
		}
		if c.TimeByIndex(i) > c.TimeByIndex(fi) ||
			(c.TimeByIndex(i) == c.TimeByIndex(fi) && v > fv) {
			if c.TimeByIndex(i) > c.TimeByIndex(si) ||
				(c.TimeByIndex(i) == c.TimeByIndex(si) && v > sv) {
				fi, fv = si, sv
				si, sv = i, v
			} else {
				fi, fv = i, v
			}
		}
	}
	return fi, si, fv, sv, false
}

func FloatIrateSlowReduce(c Chunk, ordinal, start, end int) (int, int, float64, float64, bool) {
	vs, ve := c.Column(ordinal).GetRangeValueIndexV2(start, end)
	if vs == ve {
		return 0, 0, 0, 0, true
	}
	if ve-vs == 1 {
		col := c.Column(ordinal)
		v := col.FloatValue(vs)
		return start, start, v, v, false
	}
	var (
		fi, si int
		fv, sv float64
	)
	col := c.Column(ordinal)
	fv, sv = col.FloatValue(vs), col.FloatValue(vs+1)
	fi, si = col.GetTimeIndex(vs), col.GetTimeIndex(vs+1)
	if !(c.TimeByIndex(fi) < c.TimeByIndex(si) || (c.TimeByIndex(fi) == c.TimeByIndex(si) && fv > sv)) {
		fi, si, fv, sv = si, fi, sv, fv
	}
	if ve-vs == 2 {
		return fi, si, fv, sv, false
	}
	for i := vs + 2; i < ve; i++ {
		v, index := c.Column(ordinal).FloatValue(i), c.Column(ordinal).GetTimeIndex(i)
		if c.TimeByIndex(index) < c.TimeByIndex(fi) ||
			(c.TimeByIndex(index) == c.TimeByIndex(fi) && v > fv) {
			continue
		}
		if c.TimeByIndex(index) > c.TimeByIndex(fi) ||
			(c.TimeByIndex(index) == c.TimeByIndex(fi) && v > fv) {
			if c.TimeByIndex(index) > c.TimeByIndex(si) ||
				(c.TimeByIndex(index) == c.TimeByIndex(si) && v > sv) {
				fi, fv = si, sv
				si, sv = index, v
			} else {
				fi, fv = index, v
			}
		}
	}
	return fi, si, fv, sv, false
}

func FloatIrateMiddleReduce(c Chunk, ordinal, start, end int) (int, int, float64, float64, bool) {
	if c.Column(ordinal).NilCount() == 0 {
		// fast path
		return FloatIrateFastReduce(c, ordinal, start, end)
	}

	// slow path
	return FloatIrateSlowReduce(c, ordinal, start, end)
}

func FloatIrateFinalReduce(ft int64, st int64, fv float64, sv float64,
	interval *hybridqp.Interval) (float64, bool) {
	if st == ft || interval.Duration == 0 {
		return 0, true
	}
	rate := float64(sv-fv) / (float64(st-ft) / float64(interval.Duration))
	return rate, false
}

func FloatIrateUpdate(prevPoints, currPoints [2]*FloatPoint) {
	samePrevPoint := (!prevPoints[0].isNil && !prevPoints[1].isNil) &&
		(prevPoints[0].time == prevPoints[1].time && prevPoints[1].value == prevPoints[1].value)
	for i := range currPoints {
		if currPoints[i].isNil || currPoints[i].time < prevPoints[0].time ||
			(currPoints[i].time == prevPoints[0].time && currPoints[i].value < prevPoints[0].value) {
			if samePrevPoint {
				prevPoints[0].time, prevPoints[0].value = currPoints[i].time, currPoints[i].value
			}
			continue
		}
		if (i > 0 && !currPoints[i-1].isNil) &&
			(currPoints[i].time == currPoints[i-1].time && currPoints[i].value == currPoints[i-1].value) {
			continue
		}
		if currPoints[i].time > prevPoints[0].time ||
			(currPoints[i].time == prevPoints[0].time && currPoints[i].value > prevPoints[0].value) {
			if currPoints[i].time > prevPoints[1].time ||
				(currPoints[i].time == prevPoints[1].time && currPoints[i].value > prevPoints[1].value) {
				prevPoints[0].time, prevPoints[0].value = prevPoints[1].time, prevPoints[1].value
				prevPoints[1].time, prevPoints[1].value = currPoints[i].time, currPoints[i].value
			} else {
				prevPoints[0].time, prevPoints[0].value = currPoints[i].time, currPoints[i].value
			}
		}
	}
}

func FloatIrateMerge(prevPoints [2]*FloatPoint, interval *hybridqp.Interval) (float64, bool) {
	return FloatRateFinalReduce(prevPoints[0].time, prevPoints[1].time,
		prevPoints[0].value, prevPoints[1].value, interval)
}

func IntegerIrateFastReduce(c Chunk, ordinal, start, end int) (int, int, int64, int64, bool) {
	if end-start == 0 {
		return 0, 0, 0, 0, true
	}
	if end-start == 1 {
		col := c.Column(ordinal)
		v := col.IntegerValue(start)
		return start, start, v, v, false
	}
	var (
		fi, si int
		fv, sv int64
	)
	if c.TimeByIndex(start) < c.TimeByIndex(start+1) || (c.TimeByIndex(start) == c.TimeByIndex(start+1) && fv > sv) {
		fi, si, fv, sv = start, start+1, c.Column(ordinal).IntegerValue(start), c.Column(ordinal).IntegerValue(start+1)
	} else {
		fi, si, fv, sv = start+1, start, c.Column(ordinal).IntegerValue(start+1), c.Column(ordinal).IntegerValue(start)
	}
	if end-start == 2 {
		return fi, si, fv, sv, false
	}
	for i := start + 2; i < end; i++ {
		v := c.Column(ordinal).IntegerValue(i)
		if c.TimeByIndex(i) < c.TimeByIndex(fi) ||
			(c.TimeByIndex(i) == c.TimeByIndex(fi) && v < fv) {
			continue
		}
		if c.TimeByIndex(i) > c.TimeByIndex(fi) ||
			(c.TimeByIndex(i) == c.TimeByIndex(fi) && v > fv) {
			if c.TimeByIndex(i) > c.TimeByIndex(si) ||
				(c.TimeByIndex(i) == c.TimeByIndex(si) && v > sv) {
				fi, fv = si, sv
				si, sv = i, v
			} else {
				fi, fv = i, v
			}
		}
	}
	return fi, si, fv, sv, false
}

func IntegerIrateSlowReduce(c Chunk, ordinal, start, end int) (int, int, int64, int64, bool) {
	vs, ve := c.Column(ordinal).GetRangeValueIndexV2(start, end)
	if vs == ve {
		return 0, 0, 0, 0, true
	}
	if ve-vs == 1 {
		col := c.Column(ordinal)
		v := col.IntegerValue(vs)
		return start, start, v, v, false
	}
	var (
		fi, si int
		fv, sv int64
	)
	col := c.Column(ordinal)
	fv, sv = col.IntegerValue(vs), col.IntegerValue(vs+1)
	fi, si = col.GetTimeIndex(vs), col.GetTimeIndex(vs+1)
	if !(c.TimeByIndex(fi) < c.TimeByIndex(si) || (c.TimeByIndex(fi) == c.TimeByIndex(si) && fv > sv)) {
		fi, si, fv, sv = si, fi, sv, fv
	}
	if ve-vs == 2 {
		return fi, si, fv, sv, false
	}
	for i := vs + 2; i < ve; i++ {
		v, index := c.Column(ordinal).IntegerValue(i), c.Column(ordinal).GetTimeIndex(i)
		if c.TimeByIndex(index) < c.TimeByIndex(fi) ||
			(c.TimeByIndex(index) == c.TimeByIndex(fi) && v > fv) {
			continue
		}
		if c.TimeByIndex(index) > c.TimeByIndex(fi) ||
			(c.TimeByIndex(index) == c.TimeByIndex(fi) && v > fv) {
			if c.TimeByIndex(index) > c.TimeByIndex(si) ||
				(c.TimeByIndex(index) == c.TimeByIndex(si) && v > sv) {
				fi, fv = si, sv
				si, sv = index, v
			} else {
				fi, fv = index, v
			}
		}
	}
	return fi, si, fv, sv, false
}

func IntegerIrateMiddleReduce(c Chunk, ordinal, start, end int) (int, int, int64, int64, bool) {
	if c.Column(ordinal).NilCount() == 0 {
		// fast path
		return IntegerIrateFastReduce(c, ordinal, start, end)
	}

	// slow path
	return IntegerIrateSlowReduce(c, ordinal, start, end)
}

func IntegerIrateFinalReduce(ft int64, st int64, fv int64, sv int64,
	interval *hybridqp.Interval) (float64, bool) {
	if st == ft || interval.Duration == 0 {
		return 0, true
	}
	rate := float64(sv-fv) / (float64(st-ft) / float64(interval.Duration))
	return rate, false
}

func IntegerIrateUpdate(prevPoints, currPoints [2]*IntegerPoint) {
	samePrevPoint := (!prevPoints[0].isNil && !prevPoints[1].isNil) &&
		(prevPoints[0].time == prevPoints[1].time && prevPoints[1].value == prevPoints[1].value)
	for i := range currPoints {
		if currPoints[i].isNil || currPoints[i].time < prevPoints[0].time ||
			(currPoints[i].time == prevPoints[0].time && currPoints[i].value < prevPoints[0].value) {
			if samePrevPoint {
				prevPoints[0].time, prevPoints[0].value = currPoints[i].time, currPoints[i].value
			}
			continue
		}
		if (i > 0 && !currPoints[i-1].isNil) &&
			(currPoints[i].time == currPoints[i-1].time && currPoints[i].value == currPoints[i-1].value) {
			continue
		}
		if currPoints[i].time > prevPoints[0].time ||
			(currPoints[i].time == prevPoints[0].time && currPoints[i].value > prevPoints[0].value) {
			if currPoints[i].time > prevPoints[1].time ||
				(currPoints[i].time == prevPoints[1].time && currPoints[i].value > prevPoints[1].value) {
				prevPoints[0].time, prevPoints[0].value = prevPoints[1].time, prevPoints[1].value
				prevPoints[1].time, prevPoints[1].value = currPoints[i].time, currPoints[i].value
			} else {
				prevPoints[0].time, prevPoints[0].value = currPoints[i].time, currPoints[i].value
			}
		}
	}
}

func IntegerIrateMerge(prevPoints [2]*IntegerPoint, interval *hybridqp.Interval) (float64, bool) {
	return IntegerRateFinalReduce(prevPoints[0].time, prevPoints[1].time,
		prevPoints[0].value, prevPoints[1].value, interval)
}

func FloatAbsentReduce(c Chunk, ordinal, start, end int) (int, int64, bool) {
	var count int64
	if c.Column(ordinal).NilCount() == 0 {
		// fast path
		count = int64(end - start)
		if count > 0 {
			return start, 1, false
		}
		return start, 0, true
	}

	// slow path
	vs, ve := c.Column(ordinal).GetRangeValueIndexV2(start, end)
	count = int64(ve - vs)
	if count > 0 {
		return start, 1, false
	}
	return start, 0, true
}

func IntegerAbsentReduce(c Chunk, ordinal, start, end int) (int, int64, bool) {
	var count int64
	if c.Column(ordinal).NilCount() == 0 {
		// fast path
		count = int64(end - start)
		if count > 0 {
			return start, 1, false
		}
		return start, 0, true
	}

	// slow path
	vs, ve := c.Column(ordinal).GetRangeValueIndexV2(start, end)
	count = int64(ve - vs)
	if count > 0 {
		return start, 1, false
	}
	return start, 0, true
}

func StringAbsentReduce(c Chunk, ordinal, start, end int) (int, int64, bool) {
	var count int64
	if c.Column(ordinal).NilCount() == 0 {
		// fast path
		count = int64(end - start)
		if count > 0 {
			return start, 1, false
		}
		return start, 0, true
	}

	// slow path
	vs, ve := c.Column(ordinal).GetRangeValueIndexV2(start, end)
	count = int64(ve - vs)
	if count > 0 {
		return start, 1, false
	}
	return start, 0, true
}

func BooleanAbsentReduce(c Chunk, ordinal, start, end int) (int, int64, bool) {
	var count int64
	if c.Column(ordinal).NilCount() == 0 {
		// fast path
		count = int64(end - start)
		if count > 0 {
			return start, 1, false
		}
		return start, 0, true
	}

	// slow path
	vs, ve := c.Column(ordinal).GetRangeValueIndexV2(start, end)
	count = int64(ve - vs)
	if count > 0 {
		return start, 1, false
	}
	return start, 0, true
}

func IntegerAbsentMerge(prevPoint, currPoint *IntegerPoint) {
	if prevPoint.isNil && currPoint.isNil {
		prevPoint.isNil = true
		prevPoint.value = 0
		return
	}
	prevPoint.isNil = false
	prevPoint.value = 1
}

func FloatSlidingWindowMergeFunc(prevWindow, currWindow *FloatSlidingWindow, fpm FloatPointMerge) {
	for i := 0; i < prevWindow.Len(); i++ {
		fpm(prevWindow.points[i], currWindow.points[i])
	}
}

func IntegerSlidingWindowMergeFunc(prevWindow, currWindow *IntegerSlidingWindow, fpm IntegerPointMerge) {
	for i := 0; i < prevWindow.Len(); i++ {
		fpm(prevWindow.points[i], currWindow.points[i])
	}
}

func BooleanSlidingWindowMergeFunc(prevWindow, currWindow *BooleanSlidingWindow, fpm BooleanPointMerge) {
	for i := 0; i < prevWindow.Len(); i++ {
		fpm(prevWindow.points[i], currWindow.points[i])
	}
}

func FloatFrontDiffFunc(prev, curr float64) float64 {
	return prev - curr
}

func FloatBehindDiffFunc(prev, curr float64) float64 {
	return curr - prev
}

func FloatAbsoluteDiffFunc(prev, curr float64) float64 {
	res := prev - curr
	if res >= 0 {
		return res
	}
	return -res
}

func IntegerFrontDiffFunc(prev, curr int64) int64 {
	return prev - curr
}

func IntegerBehindDiffFunc(prev, curr int64) int64 {
	return curr - prev
}

func IntegerAbsoluteDiffFunc(prev, curr int64) int64 {
	res := prev - curr
	if res >= 0 {
		return res
	}
	return -res
}

func FloatTopCmpByTimeReduce(a, b *FloatPointItem) bool {
	if a.time != b.time {
		return a.time < b.time
	}
	return a.value > b.value
}

func FloatTopCmpByValueReduce(a, b *FloatPointItem) bool {
	if a.value != b.value {
		return a.value < b.value
	}
	return a.time > b.time
}

func FloatBottomCmpByValueReduce(a, b *FloatPointItem) bool {
	if a.value != b.value {
		return a.value > b.value
	}
	return a.time > b.time
}

func FloatBottomCmpByTimeReduce(a, b *FloatPointItem) bool {
	if a.time != b.time {
		return a.time < b.time
	}
	return a.value < b.value
}

func IntegerTopCmpByTimeReduce(a, b *IntegerPointItem) bool {
	if a.time != b.time {
		return a.time < b.time
	}
	return a.value > b.value
}

func IntegerTopCmpByValueReduce(a, b *IntegerPointItem) bool {
	if a.value != b.value {
		return a.value < b.value
	}
	return a.time > b.time
}

func IntegerBottomCmpByValueReduce(a, b *IntegerPointItem) bool {
	if a.value != b.value {
		return a.value > b.value
	}
	return a.time > b.time
}

func IntegerBottomCmpByTimeReduce(a, b *IntegerPointItem) bool {
	if a.time != b.time {
		return a.time < b.time
	}
	return a.value < b.value
}
