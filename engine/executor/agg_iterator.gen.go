// Code generated by tmpl; DO NOT EDIT.
// https://github.com/benbjohnson/tmpl
//
// Source: agg_iterator.gen.go.tmpl

/*
Copyright 2022 Huawei Cloud Computing Technologies Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
package executor

import (
	"bytes"
	"container/heap"
	"sort"

	"github.com/openGemini/openGemini/engine/hybridqp"
	"github.com/openGemini/openGemini/lib/rand"
	"github.com/openGemini/openGemini/lib/record"
	"github.com/openGemini/openGemini/open_src/influx/query"
)

type FloatPoint struct {
	time  int64
	value float64
	index int
	isNil bool
}

func newFloatPoint() *FloatPoint {
	return &FloatPoint{isNil: true}
}

func (p *FloatPoint) Set(index int, time int64, value float64) {
	p.index = index
	p.time = time
	p.value = value
	p.isNil = false
}

func (p *FloatPoint) Reset() {
	p.isNil = true
}

func (p *FloatPoint) Assign(c *FloatPoint) {
	p.index = c.index
	p.time = c.time
	p.value = c.value
}

type IntegerPoint struct {
	time  int64
	value int64
	index int
	isNil bool
}

func newIntegerPoint() *IntegerPoint {
	return &IntegerPoint{isNil: true}
}

func (p *IntegerPoint) Set(index int, time int64, value int64) {
	p.index = index
	p.time = time
	p.value = value
	p.isNil = false
}

func (p *IntegerPoint) Reset() {
	p.isNil = true
}

func (p *IntegerPoint) Assign(c *IntegerPoint) {
	p.index = c.index
	p.time = c.time
	p.value = c.value
}

type BooleanPoint struct {
	time  int64
	value bool
	index int
	isNil bool
}

func newBooleanPoint() *BooleanPoint {
	return &BooleanPoint{isNil: true}
}

func (p *BooleanPoint) Set(index int, time int64, value bool) {
	p.index = index
	p.time = time
	p.value = value
	p.isNil = false
}

func (p *BooleanPoint) Reset() {
	p.isNil = true
}

func (p *BooleanPoint) Assign(c *BooleanPoint) {
	p.index = c.index
	p.time = c.time
	p.value = c.value
}

type StringPoint struct {
	time  int64
	value []byte
	index int
	isNil bool
}

func newStringPoint() *StringPoint {
	return &StringPoint{isNil: true}
}

func (p *StringPoint) Set(index int, time int64, value string) {
	p.index = index
	p.time = time
	p.isNil = false
	valueByte := record.Str2bytes(value)
	if cap(p.value) >= len(valueByte) {
		p.value = p.value[:len(valueByte)]
		copy(p.value, valueByte)
	} else {
		p.value = make([]byte, len(valueByte))
		copy(p.value, valueByte)
	}
}

func (p *StringPoint) Reset() {
	p.isNil = true
	p.value = p.value[:0]
}

func (p *StringPoint) Assign(c *StringPoint) {
	p.index = c.index
	p.time = c.time
	p.value = p.value[:0]
	if cap(p.value) >= len(c.value) {
		p.value = p.value[:len(c.value)]
		copy(p.value, c.value)
	} else {
		p.value = make([]byte, len(c.value))
		copy(p.value, c.value)
	}
}

type FloatColFloatReduce func(c Chunk, ordinal, start, end int) (index int, value float64, isNil bool)

type FloatColFloatMerge func(prevPoint, currPoint *FloatPoint)

type FloatColFloatIterator struct {
	isSingleCall bool
	inOrdinal    int
	outOrdinal   int
	prevPoint    *FloatPoint
	currPoint    *FloatPoint
	fn           FloatColFloatReduce
	fv           FloatColFloatMerge
	auxChunk     Chunk
	auxProcessor []*AuxProcessor
}

func NewFloatColFloatIterator(fn FloatColFloatReduce, fv FloatColFloatMerge,
	isSingleCall bool, inOrdinal, outOrdinal int, auxProcessor []*AuxProcessor, rowDataType hybridqp.RowDataType,
) *FloatColFloatIterator {
	r := &FloatColFloatIterator{
		fn:           fn,
		fv:           fv,
		isSingleCall: isSingleCall,
		inOrdinal:    inOrdinal,
		outOrdinal:   outOrdinal,
		prevPoint:    newFloatPoint(),
		currPoint:    newFloatPoint(),
	}
	if isSingleCall && len(auxProcessor) > 0 {
		r.auxProcessor = auxProcessor
		r.auxChunk = NewChunkBuilder(rowDataType).NewChunk("")
	}
	return r
}

func (r *FloatColFloatIterator) appendInAuxCol(
	inChunk, outChunk Chunk, index int,
) {
	for j := range r.auxProcessor {
		r.auxProcessor[j].auxHelperFunc(
			inChunk.Column(r.auxProcessor[j].inOrdinal),
			outChunk.Column(r.auxProcessor[j].outOrdinal),
			index,
		)
	}
}

func (r *FloatColFloatIterator) appendOutAuxCol(
	inChunk, outChunk Chunk, index int,
) {
	for j := range r.auxProcessor {
		r.auxProcessor[j].auxHelperFunc(
			inChunk.Column(r.auxProcessor[j].outOrdinal),
			outChunk.Column(r.auxProcessor[j].outOrdinal),
			index,
		)
	}
}

func (r *FloatColFloatIterator) mergePrevItem(
	inChunk, outChunk Chunk,
) {
	if r.isSingleCall {
		outChunk.AppendTime(r.prevPoint.time)
		outChunk.AppendIntervalIndex(outChunk.Len() - 1)
	}
	outChunk.Column(r.outOrdinal).AppendNilsV2(true)
	outChunk.Column(r.outOrdinal).AppendFloatValues(r.prevPoint.value)
	if r.auxProcessor != nil {
		if r.prevPoint.index == 0 {
			r.appendOutAuxCol(r.auxChunk, outChunk, r.prevPoint.index)
		} else {
			r.appendInAuxCol(inChunk, outChunk, r.prevPoint.index-1)
		}
		r.auxChunk.Reset()
	}
}

func (r *FloatColFloatIterator) processFirstWindow(
	inChunk, outChunk Chunk, isNil, sameInterval, onlyOneInterval bool, index int, value float64,
) {
	// To distinguish values between inChunk and auxChunk, r.currPoint.index incremented by 1.
	if !isNil {
		r.currPoint.Set(index+1, inChunk.TimeByIndex(index), value)
		r.fv(r.prevPoint, r.currPoint)
	}
	if onlyOneInterval && sameInterval {
		if r.auxProcessor != nil && r.prevPoint.index > 0 {
			r.auxChunk.Reset()
			r.auxChunk.AppendTime(inChunk.TimeByIndex(r.prevPoint.index - 1))
			r.appendInAuxCol(inChunk, r.auxChunk, r.prevPoint.index-1)
		}
		r.prevPoint.index = 0
	} else {
		if !r.prevPoint.isNil {
			r.mergePrevItem(inChunk, outChunk)
		}
		r.prevPoint.Reset()
	}
	r.currPoint.Reset()
}

func (r *FloatColFloatIterator) processLastWindow(
	inChunk Chunk, index int, isNil bool, value float64,
) {
	if isNil {
		r.prevPoint.Reset()
	} else {
		r.prevPoint.Set(0, inChunk.TimeByIndex(index), value)
	}
	if r.auxProcessor != nil {
		r.auxChunk.AppendTime(inChunk.TimeByIndex(index))
		r.appendInAuxCol(inChunk, r.auxChunk, index)
	}
}

func (r *FloatColFloatIterator) processMiddleWindow(
	inChunk, outChunk Chunk, index int, value float64,
) {
	if r.isSingleCall {
		outChunk.AppendTime(inChunk.TimeByIndex(index))
		outChunk.AppendIntervalIndex(outChunk.Len() - 1)
	}
	outChunk.Column(r.outOrdinal).AppendNilsV2(true)
	outChunk.Column(r.outOrdinal).AppendFloatValues(value)
	if r.auxProcessor != nil {
		r.appendInAuxCol(inChunk, outChunk, index)
	}
}

func (r *FloatColFloatIterator) Next(ie *IteratorEndpoint, p *IteratorParams) {
	inChunk, outChunk := ie.InputPoint.Chunk, ie.OutputPoint.Chunk
	if inChunk.Column(r.inOrdinal).IsEmpty() && r.prevPoint.isNil {
		var addIntervalLen int
		if p.sameInterval {
			addIntervalLen = inChunk.IntervalLen() - 1
		} else {
			addIntervalLen = inChunk.IntervalLen()
		}
		if addIntervalLen > 0 {
			outChunk.Column(r.outOrdinal).AppendManyNil(addIntervalLen)
		}
		return
	}

	var end int
	firstIndex, lastIndex := 0, len(inChunk.IntervalIndex())-1
	for i, start := range inChunk.IntervalIndex() {
		if i < lastIndex {
			end = inChunk.IntervalIndex()[i+1]
		} else {
			end = inChunk.NumberOfRows()
		}
		index, value, isNil := r.fn(inChunk, r.inOrdinal, start, end)
		if isNil && ((i > firstIndex && i < lastIndex) ||
			(firstIndex == lastIndex && r.prevPoint.isNil && !p.sameInterval) ||
			(firstIndex != lastIndex && i == firstIndex && r.prevPoint.isNil) ||
			(firstIndex != lastIndex && i == lastIndex && !p.sameInterval)) {
			outChunk.Column(r.outOrdinal).AppendNil()
			continue
		}
		if i == firstIndex && !r.prevPoint.isNil {
			r.processFirstWindow(inChunk, outChunk, isNil, p.sameInterval,
				firstIndex == lastIndex, index, value)
		} else if i == lastIndex && p.sameInterval {
			r.processLastWindow(inChunk, index, isNil, value)
		} else if !isNil {
			r.processMiddleWindow(inChunk, outChunk, index, value)
		}
	}
}

type FloatColIntegerReduce func(c Chunk, ordinal, start, end int) (index int, value int64, isNil bool)

type FloatColIntegerMerge func(prevPoint, currPoint *IntegerPoint)

type FloatColIntegerIterator struct {
	isSingleCall bool
	inOrdinal    int
	outOrdinal   int
	prevPoint    *IntegerPoint
	currPoint    *IntegerPoint
	fn           FloatColIntegerReduce
	fv           FloatColIntegerMerge
	auxChunk     Chunk
	auxProcessor []*AuxProcessor
}

func NewFloatColIntegerIterator(fn FloatColIntegerReduce, fv FloatColIntegerMerge,
	isSingleCall bool, inOrdinal, outOrdinal int, auxProcessor []*AuxProcessor, rowDataType hybridqp.RowDataType,
) *FloatColIntegerIterator {
	r := &FloatColIntegerIterator{
		fn:           fn,
		fv:           fv,
		isSingleCall: isSingleCall,
		inOrdinal:    inOrdinal,
		outOrdinal:   outOrdinal,
		prevPoint:    newIntegerPoint(),
		currPoint:    newIntegerPoint(),
	}
	if isSingleCall && len(auxProcessor) > 0 {
		r.auxProcessor = auxProcessor
		r.auxChunk = NewChunkBuilder(rowDataType).NewChunk("")
	}
	return r
}

func (r *FloatColIntegerIterator) appendInAuxCol(
	inChunk, outChunk Chunk, index int,
) {
	for j := range r.auxProcessor {
		r.auxProcessor[j].auxHelperFunc(
			inChunk.Column(r.auxProcessor[j].inOrdinal),
			outChunk.Column(r.auxProcessor[j].outOrdinal),
			index,
		)
	}
}

func (r *FloatColIntegerIterator) appendOutAuxCol(
	inChunk, outChunk Chunk, index int,
) {
	for j := range r.auxProcessor {
		r.auxProcessor[j].auxHelperFunc(
			inChunk.Column(r.auxProcessor[j].outOrdinal),
			outChunk.Column(r.auxProcessor[j].outOrdinal),
			index,
		)
	}
}

func (r *FloatColIntegerIterator) mergePrevItem(
	inChunk, outChunk Chunk,
) {
	if r.isSingleCall {
		outChunk.AppendTime(r.prevPoint.time)
		outChunk.AppendIntervalIndex(outChunk.Len() - 1)
	}
	outChunk.Column(r.outOrdinal).AppendNilsV2(true)
	outChunk.Column(r.outOrdinal).AppendIntegerValues(r.prevPoint.value)
	if r.auxProcessor != nil {
		if r.prevPoint.index == 0 {
			r.appendOutAuxCol(r.auxChunk, outChunk, r.prevPoint.index)
		} else {
			r.appendInAuxCol(inChunk, outChunk, r.prevPoint.index-1)
		}
		r.auxChunk.Reset()
	}
}

func (r *FloatColIntegerIterator) processFirstWindow(
	inChunk, outChunk Chunk, isNil, sameInterval, onlyOneInterval bool, index int, value int64,
) {
	// To distinguish values between inChunk and auxChunk, r.currPoint.index incremented by 1.
	if !isNil {
		r.currPoint.Set(index+1, inChunk.TimeByIndex(index), value)
		r.fv(r.prevPoint, r.currPoint)
	}
	if onlyOneInterval && sameInterval {
		if r.auxProcessor != nil && r.prevPoint.index > 0 {
			r.auxChunk.Reset()
			r.auxChunk.AppendTime(inChunk.TimeByIndex(r.prevPoint.index - 1))
			r.appendInAuxCol(inChunk, r.auxChunk, r.prevPoint.index-1)
		}
		r.prevPoint.index = 0
	} else {
		if !r.prevPoint.isNil {
			r.mergePrevItem(inChunk, outChunk)
		}
		r.prevPoint.Reset()
	}
	r.currPoint.Reset()
}

func (r *FloatColIntegerIterator) processLastWindow(
	inChunk Chunk, index int, isNil bool, value int64,
) {
	if isNil {
		r.prevPoint.Reset()
	} else {
		r.prevPoint.Set(0, inChunk.TimeByIndex(index), value)
	}
	if r.auxProcessor != nil {
		r.auxChunk.AppendTime(inChunk.TimeByIndex(index))
		r.appendInAuxCol(inChunk, r.auxChunk, index)
	}
}

func (r *FloatColIntegerIterator) processMiddleWindow(
	inChunk, outChunk Chunk, index int, value int64,
) {
	if r.isSingleCall {
		outChunk.AppendTime(inChunk.TimeByIndex(index))
		outChunk.AppendIntervalIndex(outChunk.Len() - 1)
	}
	outChunk.Column(r.outOrdinal).AppendNilsV2(true)
	outChunk.Column(r.outOrdinal).AppendIntegerValues(value)
	if r.auxProcessor != nil {
		r.appendInAuxCol(inChunk, outChunk, index)
	}
}

func (r *FloatColIntegerIterator) Next(ie *IteratorEndpoint, p *IteratorParams) {
	inChunk, outChunk := ie.InputPoint.Chunk, ie.OutputPoint.Chunk
	if inChunk.Column(r.inOrdinal).IsEmpty() && r.prevPoint.isNil {
		var addIntervalLen int
		if p.sameInterval {
			addIntervalLen = inChunk.IntervalLen() - 1
		} else {
			addIntervalLen = inChunk.IntervalLen()
		}
		if addIntervalLen > 0 {
			outChunk.Column(r.outOrdinal).AppendManyNil(addIntervalLen)
		}
		return
	}

	var end int
	firstIndex, lastIndex := 0, len(inChunk.IntervalIndex())-1
	for i, start := range inChunk.IntervalIndex() {
		if i < lastIndex {
			end = inChunk.IntervalIndex()[i+1]
		} else {
			end = inChunk.NumberOfRows()
		}
		index, value, isNil := r.fn(inChunk, r.inOrdinal, start, end)
		if isNil && ((i > firstIndex && i < lastIndex) ||
			(firstIndex == lastIndex && r.prevPoint.isNil && !p.sameInterval) ||
			(firstIndex != lastIndex && i == firstIndex && r.prevPoint.isNil) ||
			(firstIndex != lastIndex && i == lastIndex && !p.sameInterval)) {
			outChunk.Column(r.outOrdinal).AppendNil()
			continue
		}
		if i == firstIndex && !r.prevPoint.isNil {
			r.processFirstWindow(inChunk, outChunk, isNil, p.sameInterval,
				firstIndex == lastIndex, index, value)
		} else if i == lastIndex && p.sameInterval {
			r.processLastWindow(inChunk, index, isNil, value)
		} else if !isNil {
			r.processMiddleWindow(inChunk, outChunk, index, value)
		}
	}
}

type IntegerColIntegerReduce func(c Chunk, ordinal, start, end int) (index int, value int64, isNil bool)

type IntegerColIntegerMerge func(prevPoint, currPoint *IntegerPoint)

type IntegerColIntegerIterator struct {
	isSingleCall bool
	inOrdinal    int
	outOrdinal   int
	prevPoint    *IntegerPoint
	currPoint    *IntegerPoint
	fn           IntegerColIntegerReduce
	fv           IntegerColIntegerMerge
	auxChunk     Chunk
	auxProcessor []*AuxProcessor
}

func NewIntegerColIntegerIterator(fn IntegerColIntegerReduce, fv IntegerColIntegerMerge,
	isSingleCall bool, inOrdinal, outOrdinal int, auxProcessor []*AuxProcessor, rowDataType hybridqp.RowDataType,
) *IntegerColIntegerIterator {
	r := &IntegerColIntegerIterator{
		fn:           fn,
		fv:           fv,
		isSingleCall: isSingleCall,
		inOrdinal:    inOrdinal,
		outOrdinal:   outOrdinal,
		prevPoint:    newIntegerPoint(),
		currPoint:    newIntegerPoint(),
	}
	if isSingleCall && len(auxProcessor) > 0 {
		r.auxProcessor = auxProcessor
		r.auxChunk = NewChunkBuilder(rowDataType).NewChunk("")
	}
	return r
}

func (r *IntegerColIntegerIterator) appendInAuxCol(
	inChunk, outChunk Chunk, index int,
) {
	for j := range r.auxProcessor {
		r.auxProcessor[j].auxHelperFunc(
			inChunk.Column(r.auxProcessor[j].inOrdinal),
			outChunk.Column(r.auxProcessor[j].outOrdinal),
			index,
		)
	}
}

func (r *IntegerColIntegerIterator) appendOutAuxCol(
	inChunk, outChunk Chunk, index int,
) {
	for j := range r.auxProcessor {
		r.auxProcessor[j].auxHelperFunc(
			inChunk.Column(r.auxProcessor[j].outOrdinal),
			outChunk.Column(r.auxProcessor[j].outOrdinal),
			index,
		)
	}
}

func (r *IntegerColIntegerIterator) mergePrevItem(
	inChunk, outChunk Chunk,
) {
	if r.isSingleCall {
		outChunk.AppendTime(r.prevPoint.time)
		outChunk.AppendIntervalIndex(outChunk.Len() - 1)
	}
	outChunk.Column(r.outOrdinal).AppendNilsV2(true)
	outChunk.Column(r.outOrdinal).AppendIntegerValues(r.prevPoint.value)
	if r.auxProcessor != nil {
		if r.prevPoint.index == 0 {
			r.appendOutAuxCol(r.auxChunk, outChunk, r.prevPoint.index)
		} else {
			r.appendInAuxCol(inChunk, outChunk, r.prevPoint.index-1)
		}
		r.auxChunk.Reset()
	}
}

func (r *IntegerColIntegerIterator) processFirstWindow(
	inChunk, outChunk Chunk, isNil, sameInterval, onlyOneInterval bool, index int, value int64,
) {
	// To distinguish values between inChunk and auxChunk, r.currPoint.index incremented by 1.
	if !isNil {
		r.currPoint.Set(index+1, inChunk.TimeByIndex(index), value)
		r.fv(r.prevPoint, r.currPoint)
	}
	if onlyOneInterval && sameInterval {
		if r.auxProcessor != nil && r.prevPoint.index > 0 {
			r.auxChunk.Reset()
			r.auxChunk.AppendTime(inChunk.TimeByIndex(r.prevPoint.index - 1))
			r.appendInAuxCol(inChunk, r.auxChunk, r.prevPoint.index-1)
		}
		r.prevPoint.index = 0
	} else {
		if !r.prevPoint.isNil {
			r.mergePrevItem(inChunk, outChunk)
		}
		r.prevPoint.Reset()
	}
	r.currPoint.Reset()
}

func (r *IntegerColIntegerIterator) processLastWindow(
	inChunk Chunk, index int, isNil bool, value int64,
) {
	if isNil {
		r.prevPoint.Reset()
	} else {
		r.prevPoint.Set(0, inChunk.TimeByIndex(index), value)
	}
	if r.auxProcessor != nil {
		r.auxChunk.AppendTime(inChunk.TimeByIndex(index))
		r.appendInAuxCol(inChunk, r.auxChunk, index)
	}
}

func (r *IntegerColIntegerIterator) processMiddleWindow(
	inChunk, outChunk Chunk, index int, value int64,
) {
	if r.isSingleCall {
		outChunk.AppendTime(inChunk.TimeByIndex(index))
		outChunk.AppendIntervalIndex(outChunk.Len() - 1)
	}
	outChunk.Column(r.outOrdinal).AppendNilsV2(true)
	outChunk.Column(r.outOrdinal).AppendIntegerValues(value)
	if r.auxProcessor != nil {
		r.appendInAuxCol(inChunk, outChunk, index)
	}
}

func (r *IntegerColIntegerIterator) Next(ie *IteratorEndpoint, p *IteratorParams) {
	inChunk, outChunk := ie.InputPoint.Chunk, ie.OutputPoint.Chunk
	if inChunk.Column(r.inOrdinal).IsEmpty() && r.prevPoint.isNil {
		var addIntervalLen int
		if p.sameInterval {
			addIntervalLen = inChunk.IntervalLen() - 1
		} else {
			addIntervalLen = inChunk.IntervalLen()
		}
		if addIntervalLen > 0 {
			outChunk.Column(r.outOrdinal).AppendManyNil(addIntervalLen)
		}
		return
	}

	var end int
	firstIndex, lastIndex := 0, len(inChunk.IntervalIndex())-1
	for i, start := range inChunk.IntervalIndex() {
		if i < lastIndex {
			end = inChunk.IntervalIndex()[i+1]
		} else {
			end = inChunk.NumberOfRows()
		}
		index, value, isNil := r.fn(inChunk, r.inOrdinal, start, end)
		if isNil && ((i > firstIndex && i < lastIndex) ||
			(firstIndex == lastIndex && r.prevPoint.isNil && !p.sameInterval) ||
			(firstIndex != lastIndex && i == firstIndex && r.prevPoint.isNil) ||
			(firstIndex != lastIndex && i == lastIndex && !p.sameInterval)) {
			outChunk.Column(r.outOrdinal).AppendNil()
			continue
		}
		if i == firstIndex && !r.prevPoint.isNil {
			r.processFirstWindow(inChunk, outChunk, isNil, p.sameInterval,
				firstIndex == lastIndex, index, value)
		} else if i == lastIndex && p.sameInterval {
			r.processLastWindow(inChunk, index, isNil, value)
		} else if !isNil {
			r.processMiddleWindow(inChunk, outChunk, index, value)
		}
	}
}

type StringColIntegerReduce func(c Chunk, ordinal, start, end int) (index int, value int64, isNil bool)

type StringColIntegerMerge func(prevPoint, currPoint *IntegerPoint)

type StringColIntegerIterator struct {
	isSingleCall bool
	inOrdinal    int
	outOrdinal   int
	prevPoint    *IntegerPoint
	currPoint    *IntegerPoint
	fn           StringColIntegerReduce
	fv           StringColIntegerMerge
	auxChunk     Chunk
	auxProcessor []*AuxProcessor
}

func NewStringColIntegerIterator(fn StringColIntegerReduce, fv StringColIntegerMerge,
	isSingleCall bool, inOrdinal, outOrdinal int, auxProcessor []*AuxProcessor, rowDataType hybridqp.RowDataType,
) *StringColIntegerIterator {
	r := &StringColIntegerIterator{
		fn:           fn,
		fv:           fv,
		isSingleCall: isSingleCall,
		inOrdinal:    inOrdinal,
		outOrdinal:   outOrdinal,
		prevPoint:    newIntegerPoint(),
		currPoint:    newIntegerPoint(),
	}
	if isSingleCall && len(auxProcessor) > 0 {
		r.auxProcessor = auxProcessor
		r.auxChunk = NewChunkBuilder(rowDataType).NewChunk("")
	}
	return r
}

func (r *StringColIntegerIterator) appendInAuxCol(
	inChunk, outChunk Chunk, index int,
) {
	for j := range r.auxProcessor {
		r.auxProcessor[j].auxHelperFunc(
			inChunk.Column(r.auxProcessor[j].inOrdinal),
			outChunk.Column(r.auxProcessor[j].outOrdinal),
			index,
		)
	}
}

func (r *StringColIntegerIterator) appendOutAuxCol(
	inChunk, outChunk Chunk, index int,
) {
	for j := range r.auxProcessor {
		r.auxProcessor[j].auxHelperFunc(
			inChunk.Column(r.auxProcessor[j].outOrdinal),
			outChunk.Column(r.auxProcessor[j].outOrdinal),
			index,
		)
	}
}

func (r *StringColIntegerIterator) mergePrevItem(
	inChunk, outChunk Chunk,
) {
	if r.isSingleCall {
		outChunk.AppendTime(r.prevPoint.time)
		outChunk.AppendIntervalIndex(outChunk.Len() - 1)
	}
	outChunk.Column(r.outOrdinal).AppendNilsV2(true)
	outChunk.Column(r.outOrdinal).AppendIntegerValues(r.prevPoint.value)
	if r.auxProcessor != nil {
		if r.prevPoint.index == 0 {
			r.appendOutAuxCol(r.auxChunk, outChunk, r.prevPoint.index)
		} else {
			r.appendInAuxCol(inChunk, outChunk, r.prevPoint.index-1)
		}
		r.auxChunk.Reset()
	}
}

func (r *StringColIntegerIterator) processFirstWindow(
	inChunk, outChunk Chunk, isNil, sameInterval, onlyOneInterval bool, index int, value int64,
) {
	// To distinguish values between inChunk and auxChunk, r.currPoint.index incremented by 1.
	if !isNil {
		r.currPoint.Set(index+1, inChunk.TimeByIndex(index), value)
		r.fv(r.prevPoint, r.currPoint)
	}
	if onlyOneInterval && sameInterval {
		if r.auxProcessor != nil && r.prevPoint.index > 0 {
			r.auxChunk.Reset()
			r.auxChunk.AppendTime(inChunk.TimeByIndex(r.prevPoint.index - 1))
			r.appendInAuxCol(inChunk, r.auxChunk, r.prevPoint.index-1)
		}
		r.prevPoint.index = 0
	} else {
		if !r.prevPoint.isNil {
			r.mergePrevItem(inChunk, outChunk)
		}
		r.prevPoint.Reset()
	}
	r.currPoint.Reset()
}

func (r *StringColIntegerIterator) processLastWindow(
	inChunk Chunk, index int, isNil bool, value int64,
) {
	if isNil {
		r.prevPoint.Reset()
	} else {
		r.prevPoint.Set(0, inChunk.TimeByIndex(index), value)
	}
	if r.auxProcessor != nil {
		r.auxChunk.AppendTime(inChunk.TimeByIndex(index))
		r.appendInAuxCol(inChunk, r.auxChunk, index)
	}
}

func (r *StringColIntegerIterator) processMiddleWindow(
	inChunk, outChunk Chunk, index int, value int64,
) {
	if r.isSingleCall {
		outChunk.AppendTime(inChunk.TimeByIndex(index))
		outChunk.AppendIntervalIndex(outChunk.Len() - 1)
	}
	outChunk.Column(r.outOrdinal).AppendNilsV2(true)
	outChunk.Column(r.outOrdinal).AppendIntegerValues(value)
	if r.auxProcessor != nil {
		r.appendInAuxCol(inChunk, outChunk, index)
	}
}

func (r *StringColIntegerIterator) Next(ie *IteratorEndpoint, p *IteratorParams) {
	inChunk, outChunk := ie.InputPoint.Chunk, ie.OutputPoint.Chunk
	if inChunk.Column(r.inOrdinal).IsEmpty() && r.prevPoint.isNil {
		var addIntervalLen int
		if p.sameInterval {
			addIntervalLen = inChunk.IntervalLen() - 1
		} else {
			addIntervalLen = inChunk.IntervalLen()
		}
		if addIntervalLen > 0 {
			outChunk.Column(r.outOrdinal).AppendManyNil(addIntervalLen)
		}
		return
	}

	var end int
	firstIndex, lastIndex := 0, len(inChunk.IntervalIndex())-1
	for i, start := range inChunk.IntervalIndex() {
		if i < lastIndex {
			end = inChunk.IntervalIndex()[i+1]
		} else {
			end = inChunk.NumberOfRows()
		}
		index, value, isNil := r.fn(inChunk, r.inOrdinal, start, end)
		if isNil && ((i > firstIndex && i < lastIndex) ||
			(firstIndex == lastIndex && r.prevPoint.isNil && !p.sameInterval) ||
			(firstIndex != lastIndex && i == firstIndex && r.prevPoint.isNil) ||
			(firstIndex != lastIndex && i == lastIndex && !p.sameInterval)) {
			outChunk.Column(r.outOrdinal).AppendNil()
			continue
		}
		if i == firstIndex && !r.prevPoint.isNil {
			r.processFirstWindow(inChunk, outChunk, isNil, p.sameInterval,
				firstIndex == lastIndex, index, value)
		} else if i == lastIndex && p.sameInterval {
			r.processLastWindow(inChunk, index, isNil, value)
		} else if !isNil {
			r.processMiddleWindow(inChunk, outChunk, index, value)
		}
	}
}

type StringColStringReduce func(c Chunk, ordinal, start, end int) (index int, value string, isNil bool)

type StringColStringMerge func(prevPoint, currPoint *StringPoint)

type StringColStringIterator struct {
	isSingleCall bool
	inOrdinal    int
	outOrdinal   int
	prevPoint    *StringPoint
	currPoint    *StringPoint
	fn           StringColStringReduce
	fv           StringColStringMerge
	auxChunk     Chunk
	auxProcessor []*AuxProcessor
}

func NewStringColStringIterator(fn StringColStringReduce, fv StringColStringMerge,
	isSingleCall bool, inOrdinal, outOrdinal int, auxProcessor []*AuxProcessor, rowDataType hybridqp.RowDataType,
) *StringColStringIterator {
	r := &StringColStringIterator{
		fn:           fn,
		fv:           fv,
		isSingleCall: isSingleCall,
		inOrdinal:    inOrdinal,
		outOrdinal:   outOrdinal,
		prevPoint:    newStringPoint(),
		currPoint:    newStringPoint(),
	}
	if isSingleCall && len(auxProcessor) > 0 {
		r.auxProcessor = auxProcessor
		r.auxChunk = NewChunkBuilder(rowDataType).NewChunk("")
	}
	return r
}

func (r *StringColStringIterator) appendInAuxCol(
	inChunk, outChunk Chunk, index int,
) {
	for j := range r.auxProcessor {
		r.auxProcessor[j].auxHelperFunc(
			inChunk.Column(r.auxProcessor[j].inOrdinal),
			outChunk.Column(r.auxProcessor[j].outOrdinal),
			index,
		)
	}
}

func (r *StringColStringIterator) appendOutAuxCol(
	inChunk, outChunk Chunk, index int,
) {
	for j := range r.auxProcessor {
		r.auxProcessor[j].auxHelperFunc(
			inChunk.Column(r.auxProcessor[j].outOrdinal),
			outChunk.Column(r.auxProcessor[j].outOrdinal),
			index,
		)
	}
}

func (r *StringColStringIterator) mergePrevItem(
	inChunk, outChunk Chunk,
) {
	if r.isSingleCall {
		outChunk.AppendTime(r.prevPoint.time)
		outChunk.AppendIntervalIndex(outChunk.Len() - 1)
	}
	outChunk.Column(r.outOrdinal).AppendNilsV2(true)
	outChunk.Column(r.outOrdinal).AppendStringValues(string(r.prevPoint.value))
	if r.auxProcessor != nil {
		if r.prevPoint.index == 0 {
			r.appendOutAuxCol(r.auxChunk, outChunk, r.prevPoint.index)
		} else {
			r.appendInAuxCol(inChunk, outChunk, r.prevPoint.index-1)
		}
		r.auxChunk.Reset()
	}
}

func (r *StringColStringIterator) processFirstWindow(
	inChunk, outChunk Chunk, isNil, sameInterval, onlyOneInterval bool, index int, value string,
) {
	// To distinguish values between inChunk and auxChunk, r.currPoint.index incremented by 1.
	if !isNil {
		r.currPoint.Set(index+1, inChunk.TimeByIndex(index), value)
		r.fv(r.prevPoint, r.currPoint)
	}
	if onlyOneInterval && sameInterval {
		if r.auxProcessor != nil && r.prevPoint.index > 0 {
			r.auxChunk.Reset()
			r.auxChunk.AppendTime(inChunk.TimeByIndex(r.prevPoint.index - 1))
			r.appendInAuxCol(inChunk, r.auxChunk, r.prevPoint.index-1)
		}
		r.prevPoint.index = 0
	} else {
		if !r.prevPoint.isNil {
			r.mergePrevItem(inChunk, outChunk)
		}
		r.prevPoint.Reset()
	}
	r.currPoint.Reset()
}

func (r *StringColStringIterator) processLastWindow(
	inChunk Chunk, index int, isNil bool, value string,
) {
	if isNil {
		r.prevPoint.Reset()
	} else {
		r.prevPoint.Set(0, inChunk.TimeByIndex(index), value)
	}
	if r.auxProcessor != nil {
		r.auxChunk.AppendTime(inChunk.TimeByIndex(index))
		r.appendInAuxCol(inChunk, r.auxChunk, index)
	}
}

func (r *StringColStringIterator) processMiddleWindow(
	inChunk, outChunk Chunk, index int, value string,
) {
	if r.isSingleCall {
		outChunk.AppendTime(inChunk.TimeByIndex(index))
		outChunk.AppendIntervalIndex(outChunk.Len() - 1)
	}
	outChunk.Column(r.outOrdinal).AppendNilsV2(true)
	outChunk.Column(r.outOrdinal).AppendStringValues(value)
	if r.auxProcessor != nil {
		r.appendInAuxCol(inChunk, outChunk, index)
	}
}

func (r *StringColStringIterator) Next(ie *IteratorEndpoint, p *IteratorParams) {
	inChunk, outChunk := ie.InputPoint.Chunk, ie.OutputPoint.Chunk
	if inChunk.Column(r.inOrdinal).IsEmpty() && r.prevPoint.isNil {
		var addIntervalLen int
		if p.sameInterval {
			addIntervalLen = inChunk.IntervalLen() - 1
		} else {
			addIntervalLen = inChunk.IntervalLen()
		}
		if addIntervalLen > 0 {
			outChunk.Column(r.outOrdinal).AppendManyNil(addIntervalLen)
		}
		return
	}

	var end int
	firstIndex, lastIndex := 0, len(inChunk.IntervalIndex())-1
	for i, start := range inChunk.IntervalIndex() {
		if i < lastIndex {
			end = inChunk.IntervalIndex()[i+1]
		} else {
			end = inChunk.NumberOfRows()
		}
		index, value, isNil := r.fn(inChunk, r.inOrdinal, start, end)
		if isNil && ((i > firstIndex && i < lastIndex) ||
			(firstIndex == lastIndex && r.prevPoint.isNil && !p.sameInterval) ||
			(firstIndex != lastIndex && i == firstIndex && r.prevPoint.isNil) ||
			(firstIndex != lastIndex && i == lastIndex && !p.sameInterval)) {
			outChunk.Column(r.outOrdinal).AppendNil()
			continue
		}
		if i == firstIndex && !r.prevPoint.isNil {
			r.processFirstWindow(inChunk, outChunk, isNil, p.sameInterval,
				firstIndex == lastIndex, index, value)
		} else if i == lastIndex && p.sameInterval {
			r.processLastWindow(inChunk, index, isNil, value)
		} else if !isNil {
			r.processMiddleWindow(inChunk, outChunk, index, value)
		}
	}
}

type BooleanColIntegerReduce func(c Chunk, ordinal, start, end int) (index int, value int64, isNil bool)

type BooleanColIntegerMerge func(prevPoint, currPoint *IntegerPoint)

type BooleanColIntegerIterator struct {
	isSingleCall bool
	inOrdinal    int
	outOrdinal   int
	prevPoint    *IntegerPoint
	currPoint    *IntegerPoint
	fn           BooleanColIntegerReduce
	fv           BooleanColIntegerMerge
	auxChunk     Chunk
	auxProcessor []*AuxProcessor
}

func NewBooleanColIntegerIterator(fn BooleanColIntegerReduce, fv BooleanColIntegerMerge,
	isSingleCall bool, inOrdinal, outOrdinal int, auxProcessor []*AuxProcessor, rowDataType hybridqp.RowDataType,
) *BooleanColIntegerIterator {
	r := &BooleanColIntegerIterator{
		fn:           fn,
		fv:           fv,
		isSingleCall: isSingleCall,
		inOrdinal:    inOrdinal,
		outOrdinal:   outOrdinal,
		prevPoint:    newIntegerPoint(),
		currPoint:    newIntegerPoint(),
	}
	if isSingleCall && len(auxProcessor) > 0 {
		r.auxProcessor = auxProcessor
		r.auxChunk = NewChunkBuilder(rowDataType).NewChunk("")
	}
	return r
}

func (r *BooleanColIntegerIterator) appendInAuxCol(
	inChunk, outChunk Chunk, index int,
) {
	for j := range r.auxProcessor {
		r.auxProcessor[j].auxHelperFunc(
			inChunk.Column(r.auxProcessor[j].inOrdinal),
			outChunk.Column(r.auxProcessor[j].outOrdinal),
			index,
		)
	}
}

func (r *BooleanColIntegerIterator) appendOutAuxCol(
	inChunk, outChunk Chunk, index int,
) {
	for j := range r.auxProcessor {
		r.auxProcessor[j].auxHelperFunc(
			inChunk.Column(r.auxProcessor[j].outOrdinal),
			outChunk.Column(r.auxProcessor[j].outOrdinal),
			index,
		)
	}
}

func (r *BooleanColIntegerIterator) mergePrevItem(
	inChunk, outChunk Chunk,
) {
	if r.isSingleCall {
		outChunk.AppendTime(r.prevPoint.time)
		outChunk.AppendIntervalIndex(outChunk.Len() - 1)
	}
	outChunk.Column(r.outOrdinal).AppendNilsV2(true)
	outChunk.Column(r.outOrdinal).AppendIntegerValues(r.prevPoint.value)
	if r.auxProcessor != nil {
		if r.prevPoint.index == 0 {
			r.appendOutAuxCol(r.auxChunk, outChunk, r.prevPoint.index)
		} else {
			r.appendInAuxCol(inChunk, outChunk, r.prevPoint.index-1)
		}
		r.auxChunk.Reset()
	}
}

func (r *BooleanColIntegerIterator) processFirstWindow(
	inChunk, outChunk Chunk, isNil, sameInterval, onlyOneInterval bool, index int, value int64,
) {
	// To distinguish values between inChunk and auxChunk, r.currPoint.index incremented by 1.
	if !isNil {
		r.currPoint.Set(index+1, inChunk.TimeByIndex(index), value)
		r.fv(r.prevPoint, r.currPoint)
	}
	if onlyOneInterval && sameInterval {
		if r.auxProcessor != nil && r.prevPoint.index > 0 {
			r.auxChunk.Reset()
			r.auxChunk.AppendTime(inChunk.TimeByIndex(r.prevPoint.index - 1))
			r.appendInAuxCol(inChunk, r.auxChunk, r.prevPoint.index-1)
		}
		r.prevPoint.index = 0
	} else {
		if !r.prevPoint.isNil {
			r.mergePrevItem(inChunk, outChunk)
		}
		r.prevPoint.Reset()
	}
	r.currPoint.Reset()
}

func (r *BooleanColIntegerIterator) processLastWindow(
	inChunk Chunk, index int, isNil bool, value int64,
) {
	if isNil {
		r.prevPoint.Reset()
	} else {
		r.prevPoint.Set(0, inChunk.TimeByIndex(index), value)
	}
	if r.auxProcessor != nil {
		r.auxChunk.AppendTime(inChunk.TimeByIndex(index))
		r.appendInAuxCol(inChunk, r.auxChunk, index)
	}
}

func (r *BooleanColIntegerIterator) processMiddleWindow(
	inChunk, outChunk Chunk, index int, value int64,
) {
	if r.isSingleCall {
		outChunk.AppendTime(inChunk.TimeByIndex(index))
		outChunk.AppendIntervalIndex(outChunk.Len() - 1)
	}
	outChunk.Column(r.outOrdinal).AppendNilsV2(true)
	outChunk.Column(r.outOrdinal).AppendIntegerValues(value)
	if r.auxProcessor != nil {
		r.appendInAuxCol(inChunk, outChunk, index)
	}
}

func (r *BooleanColIntegerIterator) Next(ie *IteratorEndpoint, p *IteratorParams) {
	inChunk, outChunk := ie.InputPoint.Chunk, ie.OutputPoint.Chunk
	if inChunk.Column(r.inOrdinal).IsEmpty() && r.prevPoint.isNil {
		var addIntervalLen int
		if p.sameInterval {
			addIntervalLen = inChunk.IntervalLen() - 1
		} else {
			addIntervalLen = inChunk.IntervalLen()
		}
		if addIntervalLen > 0 {
			outChunk.Column(r.outOrdinal).AppendManyNil(addIntervalLen)
		}
		return
	}

	var end int
	firstIndex, lastIndex := 0, len(inChunk.IntervalIndex())-1
	for i, start := range inChunk.IntervalIndex() {
		if i < lastIndex {
			end = inChunk.IntervalIndex()[i+1]
		} else {
			end = inChunk.NumberOfRows()
		}
		index, value, isNil := r.fn(inChunk, r.inOrdinal, start, end)
		if isNil && ((i > firstIndex && i < lastIndex) ||
			(firstIndex == lastIndex && r.prevPoint.isNil && !p.sameInterval) ||
			(firstIndex != lastIndex && i == firstIndex && r.prevPoint.isNil) ||
			(firstIndex != lastIndex && i == lastIndex && !p.sameInterval)) {
			outChunk.Column(r.outOrdinal).AppendNil()
			continue
		}
		if i == firstIndex && !r.prevPoint.isNil {
			r.processFirstWindow(inChunk, outChunk, isNil, p.sameInterval,
				firstIndex == lastIndex, index, value)
		} else if i == lastIndex && p.sameInterval {
			r.processLastWindow(inChunk, index, isNil, value)
		} else if !isNil {
			r.processMiddleWindow(inChunk, outChunk, index, value)
		}
	}
}

type BooleanColBooleanReduce func(c Chunk, ordinal, start, end int) (index int, value bool, isNil bool)

type BooleanColBooleanMerge func(prevPoint, currPoint *BooleanPoint)

type BooleanColBooleanIterator struct {
	isSingleCall bool
	inOrdinal    int
	outOrdinal   int
	prevPoint    *BooleanPoint
	currPoint    *BooleanPoint
	fn           BooleanColBooleanReduce
	fv           BooleanColBooleanMerge
	auxChunk     Chunk
	auxProcessor []*AuxProcessor
}

func NewBooleanColBooleanIterator(fn BooleanColBooleanReduce, fv BooleanColBooleanMerge,
	isSingleCall bool, inOrdinal, outOrdinal int, auxProcessor []*AuxProcessor, rowDataType hybridqp.RowDataType,
) *BooleanColBooleanIterator {
	r := &BooleanColBooleanIterator{
		fn:           fn,
		fv:           fv,
		isSingleCall: isSingleCall,
		inOrdinal:    inOrdinal,
		outOrdinal:   outOrdinal,
		prevPoint:    newBooleanPoint(),
		currPoint:    newBooleanPoint(),
	}
	if isSingleCall && len(auxProcessor) > 0 {
		r.auxProcessor = auxProcessor
		r.auxChunk = NewChunkBuilder(rowDataType).NewChunk("")
	}
	return r
}

func (r *BooleanColBooleanIterator) appendInAuxCol(
	inChunk, outChunk Chunk, index int,
) {
	for j := range r.auxProcessor {
		r.auxProcessor[j].auxHelperFunc(
			inChunk.Column(r.auxProcessor[j].inOrdinal),
			outChunk.Column(r.auxProcessor[j].outOrdinal),
			index,
		)
	}
}

func (r *BooleanColBooleanIterator) appendOutAuxCol(
	inChunk, outChunk Chunk, index int,
) {
	for j := range r.auxProcessor {
		r.auxProcessor[j].auxHelperFunc(
			inChunk.Column(r.auxProcessor[j].outOrdinal),
			outChunk.Column(r.auxProcessor[j].outOrdinal),
			index,
		)
	}
}

func (r *BooleanColBooleanIterator) mergePrevItem(
	inChunk, outChunk Chunk,
) {
	if r.isSingleCall {
		outChunk.AppendTime(r.prevPoint.time)
		outChunk.AppendIntervalIndex(outChunk.Len() - 1)
	}
	outChunk.Column(r.outOrdinal).AppendNilsV2(true)
	outChunk.Column(r.outOrdinal).AppendBooleanValues(r.prevPoint.value)
	if r.auxProcessor != nil {
		if r.prevPoint.index == 0 {
			r.appendOutAuxCol(r.auxChunk, outChunk, r.prevPoint.index)
		} else {
			r.appendInAuxCol(inChunk, outChunk, r.prevPoint.index-1)
		}
		r.auxChunk.Reset()
	}
}

func (r *BooleanColBooleanIterator) processFirstWindow(
	inChunk, outChunk Chunk, isNil, sameInterval, onlyOneInterval bool, index int, value bool,
) {
	// To distinguish values between inChunk and auxChunk, r.currPoint.index incremented by 1.
	if !isNil {
		r.currPoint.Set(index+1, inChunk.TimeByIndex(index), value)
		r.fv(r.prevPoint, r.currPoint)
	}
	if onlyOneInterval && sameInterval {
		if r.auxProcessor != nil && r.prevPoint.index > 0 {
			r.auxChunk.Reset()
			r.auxChunk.AppendTime(inChunk.TimeByIndex(r.prevPoint.index - 1))
			r.appendInAuxCol(inChunk, r.auxChunk, r.prevPoint.index-1)
		}
		r.prevPoint.index = 0
	} else {
		if !r.prevPoint.isNil {
			r.mergePrevItem(inChunk, outChunk)
		}
		r.prevPoint.Reset()
	}
	r.currPoint.Reset()
}

func (r *BooleanColBooleanIterator) processLastWindow(
	inChunk Chunk, index int, isNil bool, value bool,
) {
	if isNil {
		r.prevPoint.Reset()
	} else {
		r.prevPoint.Set(0, inChunk.TimeByIndex(index), value)
	}
	if r.auxProcessor != nil {
		r.auxChunk.AppendTime(inChunk.TimeByIndex(index))
		r.appendInAuxCol(inChunk, r.auxChunk, index)
	}
}

func (r *BooleanColBooleanIterator) processMiddleWindow(
	inChunk, outChunk Chunk, index int, value bool,
) {
	if r.isSingleCall {
		outChunk.AppendTime(inChunk.TimeByIndex(index))
		outChunk.AppendIntervalIndex(outChunk.Len() - 1)
	}
	outChunk.Column(r.outOrdinal).AppendNilsV2(true)
	outChunk.Column(r.outOrdinal).AppendBooleanValues(value)
	if r.auxProcessor != nil {
		r.appendInAuxCol(inChunk, outChunk, index)
	}
}

func (r *BooleanColBooleanIterator) Next(ie *IteratorEndpoint, p *IteratorParams) {
	inChunk, outChunk := ie.InputPoint.Chunk, ie.OutputPoint.Chunk
	if inChunk.Column(r.inOrdinal).IsEmpty() && r.prevPoint.isNil {
		var addIntervalLen int
		if p.sameInterval {
			addIntervalLen = inChunk.IntervalLen() - 1
		} else {
			addIntervalLen = inChunk.IntervalLen()
		}
		if addIntervalLen > 0 {
			outChunk.Column(r.outOrdinal).AppendManyNil(addIntervalLen)
		}
		return
	}

	var end int
	firstIndex, lastIndex := 0, len(inChunk.IntervalIndex())-1
	for i, start := range inChunk.IntervalIndex() {
		if i < lastIndex {
			end = inChunk.IntervalIndex()[i+1]
		} else {
			end = inChunk.NumberOfRows()
		}
		index, value, isNil := r.fn(inChunk, r.inOrdinal, start, end)
		if isNil && ((i > firstIndex && i < lastIndex) ||
			(firstIndex == lastIndex && r.prevPoint.isNil && !p.sameInterval) ||
			(firstIndex != lastIndex && i == firstIndex && r.prevPoint.isNil) ||
			(firstIndex != lastIndex && i == lastIndex && !p.sameInterval)) {
			outChunk.Column(r.outOrdinal).AppendNil()
			continue
		}
		if i == firstIndex && !r.prevPoint.isNil {
			r.processFirstWindow(inChunk, outChunk, isNil, p.sameInterval,
				firstIndex == lastIndex, index, value)
		} else if i == lastIndex && p.sameInterval {
			r.processLastWindow(inChunk, index, isNil, value)
		} else if !isNil {
			r.processMiddleWindow(inChunk, outChunk, index, value)
		}
	}
}

type FloatTimeColFloatReduce func(c Chunk, ordinal, start, end int) (index int, value float64, isNil bool)

type FloatTimeColFloatMerge func(prevPoint, currPoint *FloatPoint)

type FloatTimeColFloatIterator struct {
	initTimeCol bool
	inOrdinal   int
	outOrdinal  int
	prevPoint   *FloatPoint
	currPoint   *FloatPoint
	fn          FloatTimeColFloatReduce
	fv          FloatTimeColFloatMerge
}

func NewFloatTimeColFloatIterator(
	fn FloatTimeColFloatReduce, fv FloatTimeColFloatMerge, inOrdinal, outOrdinal int,
) *FloatTimeColFloatIterator {
	r := &FloatTimeColFloatIterator{
		fn:         fn,
		fv:         fv,
		inOrdinal:  inOrdinal,
		outOrdinal: outOrdinal,
		prevPoint:  newFloatPoint(),
		currPoint:  newFloatPoint(),
	}
	return r
}

func (r *FloatTimeColFloatIterator) mergePrevItem(
	outChunk Chunk,
) {
	outChunk.Column(r.outOrdinal).AppendFloatValues(r.prevPoint.value)
	outChunk.Column(r.outOrdinal).AppendColumnTimes(r.prevPoint.time)
	outChunk.Column(r.outOrdinal).AppendNilsV2(true)
}

func (r *FloatTimeColFloatIterator) processFirstWindow(
	inChunk, outChunk Chunk, isNil, sameInterval, onlyOneInterval bool, index int, value float64,
) {
	// To distinguish values between inChunk and auxChunk, r.currPoint.index incremented by 1.
	if !isNil {
		if r.initTimeCol {
			r.currPoint.Set(index+1, inChunk.Column(r.inOrdinal).ColumnTime(index), value)
		} else {
			r.currPoint.Set(index+1, inChunk.TimeByIndex(index), value)
		}
		r.fv(r.prevPoint, r.currPoint)
	}
	if onlyOneInterval && sameInterval {
		r.prevPoint.index = 0
	} else {
		if !r.prevPoint.isNil {
			r.mergePrevItem(outChunk)
		}
		r.prevPoint.Reset()
	}
	r.currPoint.Reset()
}

func (r *FloatTimeColFloatIterator) processLastWindow(
	inChunk Chunk, index int, isNil bool, value float64,
) {
	if isNil {
		r.prevPoint.Reset()
		return
	}
	if r.initTimeCol {
		r.prevPoint.Set(0, inChunk.Column(r.inOrdinal).ColumnTime(index), value)
	} else {
		r.prevPoint.Set(0, inChunk.TimeByIndex(index), value)
	}
}

func (r *FloatTimeColFloatIterator) processMiddleWindow(
	inChunk, outChunk Chunk, index int, value float64,
) {
	if r.initTimeCol {
		outChunk.Column(r.outOrdinal).AppendColumnTimes(inChunk.Column(r.inOrdinal).ColumnTime(index))
	} else {
		outChunk.Column(r.outOrdinal).AppendColumnTimes(inChunk.TimeByIndex(index))
	}
	outChunk.Column(r.outOrdinal).AppendFloatValues(value)
	outChunk.Column(r.outOrdinal).AppendNilsV2(true)
}

func (r *FloatTimeColFloatIterator) Next(ie *IteratorEndpoint, p *IteratorParams) {
	inChunk, outChunk := ie.InputPoint.Chunk, ie.OutputPoint.Chunk
	if inChunk.Column(r.inOrdinal).IsEmpty() && r.prevPoint.isNil {
		var addIntervalLen int
		if p.sameInterval {
			addIntervalLen = inChunk.IntervalLen() - 1
		} else {
			addIntervalLen = inChunk.IntervalLen()
		}
		if addIntervalLen > 0 {
			outChunk.Column(r.outOrdinal).AppendManyNil(addIntervalLen)
		}
		return
	}

	var end int
	r.initTimeCol = len(inChunk.Column(r.inOrdinal).ColumnTimes()) > 0
	firstIndex, lastIndex := 0, len(inChunk.IntervalIndex())-1
	for i, start := range inChunk.IntervalIndex() {
		if i < lastIndex {
			end = inChunk.IntervalIndex()[i+1]
		} else {
			end = inChunk.NumberOfRows()
		}
		index, value, isNil := r.fn(inChunk, r.inOrdinal, start, end)
		if isNil && ((i > firstIndex && i < lastIndex) ||
			(firstIndex == lastIndex && r.prevPoint.isNil && !p.sameInterval) ||
			(firstIndex != lastIndex && i == firstIndex && r.prevPoint.isNil) ||
			(firstIndex != lastIndex && i == lastIndex && !p.sameInterval)) {
			outChunk.Column(r.outOrdinal).AppendNil()
			continue
		}
		if i == firstIndex && !r.prevPoint.isNil {
			r.processFirstWindow(inChunk, outChunk, isNil, p.sameInterval,
				firstIndex == lastIndex, index, value)
		} else if i == lastIndex && p.sameInterval {
			r.processLastWindow(inChunk, index, isNil, value)
		} else if !isNil {
			r.processMiddleWindow(inChunk, outChunk, index, value)
		}
	}
}

type IntegerTimeColIntegerReduce func(c Chunk, ordinal, start, end int) (index int, value int64, isNil bool)

type IntegerTimeColIntegerMerge func(prevPoint, currPoint *IntegerPoint)

type IntegerTimeColIntegerIterator struct {
	initTimeCol bool
	inOrdinal   int
	outOrdinal  int
	prevPoint   *IntegerPoint
	currPoint   *IntegerPoint
	fn          IntegerTimeColIntegerReduce
	fv          IntegerTimeColIntegerMerge
}

func NewIntegerTimeColIntegerIterator(
	fn IntegerTimeColIntegerReduce, fv IntegerTimeColIntegerMerge, inOrdinal, outOrdinal int,
) *IntegerTimeColIntegerIterator {
	r := &IntegerTimeColIntegerIterator{
		fn:         fn,
		fv:         fv,
		inOrdinal:  inOrdinal,
		outOrdinal: outOrdinal,
		prevPoint:  newIntegerPoint(),
		currPoint:  newIntegerPoint(),
	}
	return r
}

func (r *IntegerTimeColIntegerIterator) mergePrevItem(
	outChunk Chunk,
) {
	outChunk.Column(r.outOrdinal).AppendIntegerValues(r.prevPoint.value)
	outChunk.Column(r.outOrdinal).AppendColumnTimes(r.prevPoint.time)
	outChunk.Column(r.outOrdinal).AppendNilsV2(true)
}

func (r *IntegerTimeColIntegerIterator) processFirstWindow(
	inChunk, outChunk Chunk, isNil, sameInterval, onlyOneInterval bool, index int, value int64,
) {
	// To distinguish values between inChunk and auxChunk, r.currPoint.index incremented by 1.
	if !isNil {
		if r.initTimeCol {
			r.currPoint.Set(index+1, inChunk.Column(r.inOrdinal).ColumnTime(index), value)
		} else {
			r.currPoint.Set(index+1, inChunk.TimeByIndex(index), value)
		}
		r.fv(r.prevPoint, r.currPoint)
	}
	if onlyOneInterval && sameInterval {
		r.prevPoint.index = 0
	} else {
		if !r.prevPoint.isNil {
			r.mergePrevItem(outChunk)
		}
		r.prevPoint.Reset()
	}
	r.currPoint.Reset()
}

func (r *IntegerTimeColIntegerIterator) processLastWindow(
	inChunk Chunk, index int, isNil bool, value int64,
) {
	if isNil {
		r.prevPoint.Reset()
		return
	}
	if r.initTimeCol {
		r.prevPoint.Set(0, inChunk.Column(r.inOrdinal).ColumnTime(index), value)
	} else {
		r.prevPoint.Set(0, inChunk.TimeByIndex(index), value)
	}
}

func (r *IntegerTimeColIntegerIterator) processMiddleWindow(
	inChunk, outChunk Chunk, index int, value int64,
) {
	if r.initTimeCol {
		outChunk.Column(r.outOrdinal).AppendColumnTimes(inChunk.Column(r.inOrdinal).ColumnTime(index))
	} else {
		outChunk.Column(r.outOrdinal).AppendColumnTimes(inChunk.TimeByIndex(index))
	}
	outChunk.Column(r.outOrdinal).AppendIntegerValues(value)
	outChunk.Column(r.outOrdinal).AppendNilsV2(true)
}

func (r *IntegerTimeColIntegerIterator) Next(ie *IteratorEndpoint, p *IteratorParams) {
	inChunk, outChunk := ie.InputPoint.Chunk, ie.OutputPoint.Chunk
	if inChunk.Column(r.inOrdinal).IsEmpty() && r.prevPoint.isNil {
		var addIntervalLen int
		if p.sameInterval {
			addIntervalLen = inChunk.IntervalLen() - 1
		} else {
			addIntervalLen = inChunk.IntervalLen()
		}
		if addIntervalLen > 0 {
			outChunk.Column(r.outOrdinal).AppendManyNil(addIntervalLen)
		}
		return
	}

	var end int
	r.initTimeCol = len(inChunk.Column(r.inOrdinal).ColumnTimes()) > 0
	firstIndex, lastIndex := 0, len(inChunk.IntervalIndex())-1
	for i, start := range inChunk.IntervalIndex() {
		if i < lastIndex {
			end = inChunk.IntervalIndex()[i+1]
		} else {
			end = inChunk.NumberOfRows()
		}
		index, value, isNil := r.fn(inChunk, r.inOrdinal, start, end)
		if isNil && ((i > firstIndex && i < lastIndex) ||
			(firstIndex == lastIndex && r.prevPoint.isNil && !p.sameInterval) ||
			(firstIndex != lastIndex && i == firstIndex && r.prevPoint.isNil) ||
			(firstIndex != lastIndex && i == lastIndex && !p.sameInterval)) {
			outChunk.Column(r.outOrdinal).AppendNil()
			continue
		}
		if i == firstIndex && !r.prevPoint.isNil {
			r.processFirstWindow(inChunk, outChunk, isNil, p.sameInterval,
				firstIndex == lastIndex, index, value)
		} else if i == lastIndex && p.sameInterval {
			r.processLastWindow(inChunk, index, isNil, value)
		} else if !isNil {
			r.processMiddleWindow(inChunk, outChunk, index, value)
		}
	}
}

type StringTimeColStringReduce func(c Chunk, ordinal, start, end int) (index int, value string, isNil bool)

type StringTimeColStringMerge func(prevPoint, currPoint *StringPoint)

type StringTimeColStringIterator struct {
	initTimeCol bool
	inOrdinal   int
	outOrdinal  int
	prevPoint   *StringPoint
	currPoint   *StringPoint
	fn          StringTimeColStringReduce
	fv          StringTimeColStringMerge
}

func NewStringTimeColStringIterator(
	fn StringTimeColStringReduce, fv StringTimeColStringMerge, inOrdinal, outOrdinal int,
) *StringTimeColStringIterator {
	r := &StringTimeColStringIterator{
		fn:         fn,
		fv:         fv,
		inOrdinal:  inOrdinal,
		outOrdinal: outOrdinal,
		prevPoint:  newStringPoint(),
		currPoint:  newStringPoint(),
	}
	return r
}

func (r *StringTimeColStringIterator) mergePrevItem(
	outChunk Chunk,
) {
	outChunk.Column(r.outOrdinal).AppendStringValues(string(r.prevPoint.value))
	outChunk.Column(r.outOrdinal).AppendColumnTimes(r.prevPoint.time)
	outChunk.Column(r.outOrdinal).AppendNilsV2(true)
}

func (r *StringTimeColStringIterator) processFirstWindow(
	inChunk, outChunk Chunk, isNil, sameInterval, onlyOneInterval bool, index int, value string,
) {
	// To distinguish values between inChunk and auxChunk, r.currPoint.index incremented by 1.
	if !isNil {
		if r.initTimeCol {
			r.currPoint.Set(index+1, inChunk.Column(r.inOrdinal).ColumnTime(index), value)
		} else {
			r.currPoint.Set(index+1, inChunk.TimeByIndex(index), value)
		}
		r.fv(r.prevPoint, r.currPoint)
	}
	if onlyOneInterval && sameInterval {
		r.prevPoint.index = 0
	} else {
		if !r.prevPoint.isNil {
			r.mergePrevItem(outChunk)
		}
		r.prevPoint.Reset()
	}
	r.currPoint.Reset()
}

func (r *StringTimeColStringIterator) processLastWindow(
	inChunk Chunk, index int, isNil bool, value string,
) {
	if isNil {
		r.prevPoint.Reset()
		return
	}
	if r.initTimeCol {
		r.prevPoint.Set(0, inChunk.Column(r.inOrdinal).ColumnTime(index), value)
	} else {
		r.prevPoint.Set(0, inChunk.TimeByIndex(index), value)
	}
}

func (r *StringTimeColStringIterator) processMiddleWindow(
	inChunk, outChunk Chunk, index int, value string,
) {
	if r.initTimeCol {
		outChunk.Column(r.outOrdinal).AppendColumnTimes(inChunk.Column(r.inOrdinal).ColumnTime(index))
	} else {
		outChunk.Column(r.outOrdinal).AppendColumnTimes(inChunk.TimeByIndex(index))
	}
	outChunk.Column(r.outOrdinal).AppendStringValues(value)
	outChunk.Column(r.outOrdinal).AppendNilsV2(true)
}

func (r *StringTimeColStringIterator) Next(ie *IteratorEndpoint, p *IteratorParams) {
	inChunk, outChunk := ie.InputPoint.Chunk, ie.OutputPoint.Chunk
	if inChunk.Column(r.inOrdinal).IsEmpty() && r.prevPoint.isNil {
		var addIntervalLen int
		if p.sameInterval {
			addIntervalLen = inChunk.IntervalLen() - 1
		} else {
			addIntervalLen = inChunk.IntervalLen()
		}
		if addIntervalLen > 0 {
			outChunk.Column(r.outOrdinal).AppendManyNil(addIntervalLen)
		}
		return
	}

	var end int
	r.initTimeCol = len(inChunk.Column(r.inOrdinal).ColumnTimes()) > 0
	firstIndex, lastIndex := 0, len(inChunk.IntervalIndex())-1
	for i, start := range inChunk.IntervalIndex() {
		if i < lastIndex {
			end = inChunk.IntervalIndex()[i+1]
		} else {
			end = inChunk.NumberOfRows()
		}
		index, value, isNil := r.fn(inChunk, r.inOrdinal, start, end)
		if isNil && ((i > firstIndex && i < lastIndex) ||
			(firstIndex == lastIndex && r.prevPoint.isNil && !p.sameInterval) ||
			(firstIndex != lastIndex && i == firstIndex && r.prevPoint.isNil) ||
			(firstIndex != lastIndex && i == lastIndex && !p.sameInterval)) {
			outChunk.Column(r.outOrdinal).AppendNil()
			continue
		}
		if i == firstIndex && !r.prevPoint.isNil {
			r.processFirstWindow(inChunk, outChunk, isNil, p.sameInterval,
				firstIndex == lastIndex, index, value)
		} else if i == lastIndex && p.sameInterval {
			r.processLastWindow(inChunk, index, isNil, value)
		} else if !isNil {
			r.processMiddleWindow(inChunk, outChunk, index, value)
		}
	}
}

type BooleanTimeColBooleanReduce func(c Chunk, ordinal, start, end int) (index int, value bool, isNil bool)

type BooleanTimeColBooleanMerge func(prevPoint, currPoint *BooleanPoint)

type BooleanTimeColBooleanIterator struct {
	initTimeCol bool
	inOrdinal   int
	outOrdinal  int
	prevPoint   *BooleanPoint
	currPoint   *BooleanPoint
	fn          BooleanTimeColBooleanReduce
	fv          BooleanTimeColBooleanMerge
}

func NewBooleanTimeColBooleanIterator(
	fn BooleanTimeColBooleanReduce, fv BooleanTimeColBooleanMerge, inOrdinal, outOrdinal int,
) *BooleanTimeColBooleanIterator {
	r := &BooleanTimeColBooleanIterator{
		fn:         fn,
		fv:         fv,
		inOrdinal:  inOrdinal,
		outOrdinal: outOrdinal,
		prevPoint:  newBooleanPoint(),
		currPoint:  newBooleanPoint(),
	}
	return r
}

func (r *BooleanTimeColBooleanIterator) mergePrevItem(
	outChunk Chunk,
) {
	outChunk.Column(r.outOrdinal).AppendBooleanValues(r.prevPoint.value)
	outChunk.Column(r.outOrdinal).AppendColumnTimes(r.prevPoint.time)
	outChunk.Column(r.outOrdinal).AppendNilsV2(true)
}

func (r *BooleanTimeColBooleanIterator) processFirstWindow(
	inChunk, outChunk Chunk, isNil, sameInterval, onlyOneInterval bool, index int, value bool,
) {
	// To distinguish values between inChunk and auxChunk, r.currPoint.index incremented by 1.
	if !isNil {
		if r.initTimeCol {
			r.currPoint.Set(index+1, inChunk.Column(r.inOrdinal).ColumnTime(index), value)
		} else {
			r.currPoint.Set(index+1, inChunk.TimeByIndex(index), value)
		}
		r.fv(r.prevPoint, r.currPoint)
	}
	if onlyOneInterval && sameInterval {
		r.prevPoint.index = 0
	} else {
		if !r.prevPoint.isNil {
			r.mergePrevItem(outChunk)
		}
		r.prevPoint.Reset()
	}
	r.currPoint.Reset()
}

func (r *BooleanTimeColBooleanIterator) processLastWindow(
	inChunk Chunk, index int, isNil bool, value bool,
) {
	if isNil {
		r.prevPoint.Reset()
		return
	}
	if r.initTimeCol {
		r.prevPoint.Set(0, inChunk.Column(r.inOrdinal).ColumnTime(index), value)
	} else {
		r.prevPoint.Set(0, inChunk.TimeByIndex(index), value)
	}
}

func (r *BooleanTimeColBooleanIterator) processMiddleWindow(
	inChunk, outChunk Chunk, index int, value bool,
) {
	if r.initTimeCol {
		outChunk.Column(r.outOrdinal).AppendColumnTimes(inChunk.Column(r.inOrdinal).ColumnTime(index))
	} else {
		outChunk.Column(r.outOrdinal).AppendColumnTimes(inChunk.TimeByIndex(index))
	}
	outChunk.Column(r.outOrdinal).AppendBooleanValues(value)
	outChunk.Column(r.outOrdinal).AppendNilsV2(true)
}

func (r *BooleanTimeColBooleanIterator) Next(ie *IteratorEndpoint, p *IteratorParams) {
	inChunk, outChunk := ie.InputPoint.Chunk, ie.OutputPoint.Chunk
	if inChunk.Column(r.inOrdinal).IsEmpty() && r.prevPoint.isNil {
		var addIntervalLen int
		if p.sameInterval {
			addIntervalLen = inChunk.IntervalLen() - 1
		} else {
			addIntervalLen = inChunk.IntervalLen()
		}
		if addIntervalLen > 0 {
			outChunk.Column(r.outOrdinal).AppendManyNil(addIntervalLen)
		}
		return
	}

	var end int
	r.initTimeCol = len(inChunk.Column(r.inOrdinal).ColumnTimes()) > 0
	firstIndex, lastIndex := 0, len(inChunk.IntervalIndex())-1
	for i, start := range inChunk.IntervalIndex() {
		if i < lastIndex {
			end = inChunk.IntervalIndex()[i+1]
		} else {
			end = inChunk.NumberOfRows()
		}
		index, value, isNil := r.fn(inChunk, r.inOrdinal, start, end)
		if isNil && ((i > firstIndex && i < lastIndex) ||
			(firstIndex == lastIndex && r.prevPoint.isNil && !p.sameInterval) ||
			(firstIndex != lastIndex && i == firstIndex && r.prevPoint.isNil) ||
			(firstIndex != lastIndex && i == lastIndex && !p.sameInterval)) {
			outChunk.Column(r.outOrdinal).AppendNil()
			continue
		}
		if i == firstIndex && !r.prevPoint.isNil {
			r.processFirstWindow(inChunk, outChunk, isNil, p.sameInterval,
				firstIndex == lastIndex, index, value)
		} else if i == lastIndex && p.sameInterval {
			r.processLastWindow(inChunk, index, isNil, value)
		} else if !isNil {
			r.processMiddleWindow(inChunk, outChunk, index, value)
		}
	}
}

type FloatSliceItem struct {
	index []int
	time  []int64
	value []float64
}

func (f *FloatSliceItem) AppendItem(c Chunk, ordinal, start, end int) {
	if start == end {
		return
	}
	fLen := len(f.time)
	if c.Column(ordinal).NilCount() == 0 {
		// fast path
		for i := start; i < end; i++ {
			f.index = append(f.index, fLen+i-start)
			f.time = append(f.time, c.TimeByIndex(i))
		}
	} else {
		// slow path
		getTimeIndex := c.Column(ordinal).GetTimeIndex
		for i := start; i < end; i++ {
			f.index = append(f.index, fLen+i-start)
			f.time = append(f.time, c.TimeByIndex(getTimeIndex(i)))
		}
	}
	f.value = append(f.value, c.Column(ordinal).FloatValues()[start:end]...)
}

func (f *FloatSliceItem) Reset() {
	f.index = f.index[:0]
	f.time = f.time[:0]
	f.value = f.value[:0]
}

func (f *FloatSliceItem) Len() int {
	return len(f.time)
}

func (f *FloatSliceItem) Less(i, j int) bool {
	return f.value[i] < f.value[j]
}

func (f *FloatSliceItem) Swap(i, j int) {
	f.index[i], f.index[j] = f.index[j], f.index[i]
	f.time[i], f.time[j] = f.time[j], f.time[i]
	f.value[i], f.value[j] = f.value[j], f.value[i]
}

type IntegerSliceItem struct {
	index []int
	time  []int64
	value []int64
}

func (f *IntegerSliceItem) AppendItem(c Chunk, ordinal, start, end int) {
	if start == end {
		return
	}
	fLen := len(f.time)
	if c.Column(ordinal).NilCount() == 0 {
		// fast path
		for i := start; i < end; i++ {
			f.index = append(f.index, fLen+i-start)
			f.time = append(f.time, c.TimeByIndex(i))
		}
	} else {
		// slow path
		getTimeIndex := c.Column(ordinal).GetTimeIndex
		for i := start; i < end; i++ {
			f.index = append(f.index, fLen+i-start)
			f.time = append(f.time, c.TimeByIndex(getTimeIndex(i)))
		}
	}
	f.value = append(f.value, c.Column(ordinal).IntegerValues()[start:end]...)
}

func (f *IntegerSliceItem) Reset() {
	f.index = f.index[:0]
	f.time = f.time[:0]
	f.value = f.value[:0]
}

func (f *IntegerSliceItem) Len() int {
	return len(f.time)
}

func (f *IntegerSliceItem) Less(i, j int) bool {
	return f.value[i] < f.value[j]
}

func (f *IntegerSliceItem) Swap(i, j int) {
	f.index[i], f.index[j] = f.index[j], f.index[i]
	f.time[i], f.time[j] = f.time[j], f.time[i]
	f.value[i], f.value[j] = f.value[j], f.value[i]
}

type StringSliceItem struct {
	index     []int
	time      []int64
	value     []string
	valueBits []byte
}

func (f *StringSliceItem) AppendItem(c Chunk, ordinal, start, end int) {
	if start == end {
		return
	}
	fLen := len(f.time)
	if c.Column(ordinal).NilCount() == 0 {
		// fast path
		for i := start; i < end; i++ {
			f.index = append(f.index, fLen+i-start)
			f.time = append(f.time, c.TimeByIndex(i))
		}
	} else {
		// slow path
		getTimeIndex := c.Column(ordinal).GetTimeIndex
		for i := start; i < end; i++ {
			f.index = append(f.index, fLen+i-start)
			f.time = append(f.time, c.TimeByIndex(getTimeIndex(i)))
		}
	}

	col := c.Column(ordinal)
	f.valueBits, f.value = col.GetStringValueBytes(f.valueBits, f.value, start, end)
}

func (f *StringSliceItem) Reset() {
	f.index = f.index[:0]
	f.time = f.time[:0]
	f.value = f.value[:0]
	f.valueBits = f.valueBits[:0]
}

func (f *StringSliceItem) Len() int {
	return len(f.time)
}

func (f *StringSliceItem) Less(i, j int) bool {
	return f.value[i] < f.value[j]
}

func (f *StringSliceItem) Swap(i, j int) {
	f.index[i], f.index[j] = f.index[j], f.index[i]
	f.time[i], f.time[j] = f.time[j], f.time[i]
	f.value[i], f.value[j] = f.value[j], f.value[i]
}

type BooleanSliceItem struct {
	index []int
	time  []int64
	value []bool
}

func (f *BooleanSliceItem) AppendItem(c Chunk, ordinal, start, end int) {
	if start == end {
		return
	}
	fLen := len(f.time)
	if c.Column(ordinal).NilCount() == 0 {
		// fast path
		for i := start; i < end; i++ {
			f.index = append(f.index, fLen+i-start)
			f.time = append(f.time, c.TimeByIndex(i))
		}
	} else {
		// slow path
		getTimeIndex := c.Column(ordinal).GetTimeIndex
		for i := start; i < end; i++ {
			f.index = append(f.index, fLen+i-start)
			f.time = append(f.time, c.TimeByIndex(getTimeIndex(i)))
		}
	}
	f.value = append(f.value, c.Column(ordinal).BooleanValues()[start:end]...)
}

func (f *BooleanSliceItem) Reset() {
	f.index = f.index[:0]
	f.time = f.time[:0]
	f.value = f.value[:0]
}

func (f *BooleanSliceItem) Len() int {
	return len(f.time)
}

type FloatColReduceSliceReduce func(floatItem *FloatSliceItem) (index int, time int64, value float64, isNil bool)

func NewFloatSliceItem() *FloatSliceItem {
	return &FloatSliceItem{}
}

type FloatColFloatSliceIterator struct {
	isSingleCall bool
	inOrdinal    int
	outOrdinal   int
	buf          *FloatSliceItem
	fn           FloatColReduceSliceReduce
	auxChunk     Chunk
	auxProcessor []*AuxProcessor
	windowIndex  []int
}

func NewFloatColFloatSliceIterator(fn FloatColReduceSliceReduce,
	isSingleCall bool, inOrdinal, outOrdinal int, auxProcessor []*AuxProcessor, rowDataType hybridqp.RowDataType,
) *FloatColFloatSliceIterator {
	r := &FloatColFloatSliceIterator{
		buf:          NewFloatSliceItem(),
		fn:           fn,
		isSingleCall: isSingleCall,
		inOrdinal:    inOrdinal,
		outOrdinal:   outOrdinal,
	}
	if isSingleCall && len(auxProcessor) > 0 {
		r.auxProcessor = auxProcessor
		r.auxChunk = NewChunkBuilder(rowDataType).NewChunk("")
	}
	return r
}

func (r *FloatColFloatSliceIterator) appendInAuxCol(
	inChunk, outChunk Chunk, index int,
) {
	for j := range r.auxProcessor {
		r.auxProcessor[j].auxHelperFunc(
			inChunk.Column(r.auxProcessor[j].inOrdinal),
			outChunk.Column(r.auxProcessor[j].outOrdinal),
			index,
		)
	}
}

func (r *FloatColFloatSliceIterator) appendOutAuxCol(
	inChunk, outChunk Chunk, index int,
) {
	for j := range r.auxProcessor {
		r.auxProcessor[j].auxHelperFunc(
			inChunk.Column(r.auxProcessor[j].outOrdinal),
			outChunk.Column(r.auxProcessor[j].outOrdinal),
			index,
		)
	}
}

func (r *FloatColFloatSliceIterator) updateAuxChunk(
	inChunk, outChunk Chunk, start, end int,
) {
	if start == end {
		return
	}
	for j := start; j < end; j++ {
		r.windowIndex = append(r.windowIndex, j)
	}
	for j := range r.auxProcessor {
		r.auxProcessor[j].auxHelperFunc(
			inChunk.Column(r.auxProcessor[j].inOrdinal),
			outChunk.Column(r.auxProcessor[j].outOrdinal),
			r.windowIndex...,
		)
	}
	r.windowIndex = r.windowIndex[:0]
}

func (r *FloatColFloatSliceIterator) mergePrevItem(
	outChunk Chunk, idx int, time int64, val float64,
) {
	if idx != -1 {
		if r.isSingleCall {
			outChunk.AppendTime(r.buf.time[idx])
			outChunk.AppendIntervalIndex(outChunk.Len() - 1)
		}
		outChunk.Column(r.outOrdinal).AppendNilsV2(true)
		outChunk.Column(r.outOrdinal).AppendFloatValues(r.buf.value[idx])
		if r.auxProcessor != nil {
			r.appendOutAuxCol(r.auxChunk, outChunk, r.buf.index[idx])
			r.auxChunk.Reset()
		}
	} else {
		if r.isSingleCall {
			outChunk.AppendTime(time)
			outChunk.AppendIntervalIndex(outChunk.Len() - 1)
		}
		outChunk.Column(r.outOrdinal).AppendNilsV2(true)
		outChunk.Column(r.outOrdinal).AppendFloatValues(val)
	}
}

func (r *FloatColFloatSliceIterator) assembleCurrItem(
	inChunk, outChunk Chunk, vs, idx int, time int64, val float64,
) {
	if idx != -1 {
		if r.isSingleCall {
			outChunk.AppendTime(r.buf.time[idx])
			outChunk.AppendIntervalIndex(outChunk.Len() - 1)
		}
		outChunk.Column(r.outOrdinal).AppendNilsV2(true)
		outChunk.Column(r.outOrdinal).AppendFloatValues(r.buf.value[idx])
		if r.auxProcessor != nil {
			r.appendInAuxCol(inChunk, outChunk, vs+r.buf.index[idx])
		}
	} else {
		if r.isSingleCall {
			outChunk.AppendTime(time)
			outChunk.AppendIntervalIndex(outChunk.Len() - 1)
		}
		outChunk.Column(r.outOrdinal).AppendNilsV2(true)
		outChunk.Column(r.outOrdinal).AppendFloatValues(val)
	}
}

func (r *FloatColFloatSliceIterator) processFirstWindow(
	inChunk, outChunk Chunk, sameInterval, haveMultiInterval bool, start, end int,
) {
	r.buf.AppendItem(inChunk, r.inOrdinal, start, end)
	if r.auxProcessor != nil {
		r.updateAuxChunk(inChunk, r.auxChunk, start, end)
	}
	if haveMultiInterval || !sameInterval {
		index, time, value, isNil := r.fn(r.buf)
		if !isNil {
			r.mergePrevItem(outChunk, index, time, value)
		}
		r.buf.Reset()
	}
}

func (r *FloatColFloatSliceIterator) processLastWindow(
	inChunk Chunk, start, end int,
) {
	r.buf.AppendItem(inChunk, r.inOrdinal, start, end)
	if r.auxProcessor != nil {
		r.updateAuxChunk(inChunk, r.auxChunk, start, end)
	}
}

func (r *FloatColFloatSliceIterator) processMiddleWindow(
	inChunk, outChunk Chunk, start, end int,
) {
	r.buf.AppendItem(inChunk, r.inOrdinal, start, end)
	index, time, value, isNil := r.fn(r.buf)
	if !isNil {
		r.assembleCurrItem(inChunk, outChunk, start, index, time, value)
	}
	r.buf.Reset()
}

func (r *FloatColFloatSliceIterator) Next(ie *IteratorEndpoint, p *IteratorParams) {
	inChunk, outChunk := ie.InputPoint.Chunk, ie.OutputPoint.Chunk

	var end int
	firstIndex, lastIndex := 0, len(inChunk.IntervalIndex())-1
	for i, start := range inChunk.IntervalIndex() {
		if i < lastIndex {
			end = inChunk.IntervalIndex()[i+1]
		} else {
			end = inChunk.NumberOfRows()
		}
		if !r.isSingleCall {
			start, end = inChunk.Column(r.inOrdinal).GetRangeValueIndexV2(start, end)
			if start == end && r.buf.Len() == 0 && (i < lastIndex || (i == lastIndex && !p.sameInterval)) {
				outChunk.Column(r.outOrdinal).AppendNilsV2(false)
				continue
			}
		}
		if i == firstIndex && r.buf.Len() > 0 {
			r.processFirstWindow(inChunk, outChunk, p.sameInterval,
				firstIndex != lastIndex, start, end)
		} else if i == lastIndex && p.sameInterval {
			r.processLastWindow(inChunk, start, end)
		} else {
			r.processMiddleWindow(inChunk, outChunk, start, end)
		}
	}
}

type IntegerColReduceSliceReduce func(integerItem *IntegerSliceItem) (index int, time int64, value float64, isNil bool)

func NewIntegerSliceItem() *IntegerSliceItem {
	return &IntegerSliceItem{}
}

type IntegerColIntegerSliceIterator struct {
	isSingleCall bool
	inOrdinal    int
	outOrdinal   int
	buf          *IntegerSliceItem
	fn           IntegerColReduceSliceReduce
	auxChunk     Chunk
	auxProcessor []*AuxProcessor
	windowIndex  []int
}

func NewIntegerColIntegerSliceIterator(fn IntegerColReduceSliceReduce,
	isSingleCall bool, inOrdinal, outOrdinal int, auxProcessor []*AuxProcessor, rowDataType hybridqp.RowDataType,
) *IntegerColIntegerSliceIterator {
	r := &IntegerColIntegerSliceIterator{
		buf:          NewIntegerSliceItem(),
		fn:           fn,
		isSingleCall: isSingleCall,
		inOrdinal:    inOrdinal,
		outOrdinal:   outOrdinal,
	}
	if isSingleCall && len(auxProcessor) > 0 {
		r.auxProcessor = auxProcessor
		r.auxChunk = NewChunkBuilder(rowDataType).NewChunk("")
	}
	return r
}

func (r *IntegerColIntegerSliceIterator) appendInAuxCol(
	inChunk, outChunk Chunk, index int,
) {
	for j := range r.auxProcessor {
		r.auxProcessor[j].auxHelperFunc(
			inChunk.Column(r.auxProcessor[j].inOrdinal),
			outChunk.Column(r.auxProcessor[j].outOrdinal),
			index,
		)
	}
}

func (r *IntegerColIntegerSliceIterator) appendOutAuxCol(
	inChunk, outChunk Chunk, index int,
) {
	for j := range r.auxProcessor {
		r.auxProcessor[j].auxHelperFunc(
			inChunk.Column(r.auxProcessor[j].outOrdinal),
			outChunk.Column(r.auxProcessor[j].outOrdinal),
			index,
		)
	}
}

func (r *IntegerColIntegerSliceIterator) updateAuxChunk(
	inChunk, outChunk Chunk, start, end int,
) {
	if start == end {
		return
	}
	for j := start; j < end; j++ {
		r.windowIndex = append(r.windowIndex, j)
	}
	for j := range r.auxProcessor {
		r.auxProcessor[j].auxHelperFunc(
			inChunk.Column(r.auxProcessor[j].inOrdinal),
			outChunk.Column(r.auxProcessor[j].outOrdinal),
			r.windowIndex...,
		)
	}
	r.windowIndex = r.windowIndex[:0]
}

func (r *IntegerColIntegerSliceIterator) mergePrevItem(
	outChunk Chunk, idx int, time int64, val float64,
) {
	if idx != -1 {
		if r.isSingleCall {
			outChunk.AppendTime(r.buf.time[idx])
			outChunk.AppendIntervalIndex(outChunk.Len() - 1)
		}
		outChunk.Column(r.outOrdinal).AppendNilsV2(true)
		outChunk.Column(r.outOrdinal).AppendIntegerValues(r.buf.value[idx])
		if r.auxProcessor != nil {
			r.appendOutAuxCol(r.auxChunk, outChunk, r.buf.index[idx])
			r.auxChunk.Reset()
		}
	} else {
		if r.isSingleCall {
			outChunk.AppendTime(time)
			outChunk.AppendIntervalIndex(outChunk.Len() - 1)
		}
		outChunk.Column(r.outOrdinal).AppendNilsV2(true)
		outChunk.Column(r.outOrdinal).AppendFloatValues(val)
	}
}

func (r *IntegerColIntegerSliceIterator) assembleCurrItem(
	inChunk, outChunk Chunk, vs, idx int, time int64, val float64,
) {
	if idx != -1 {
		if r.isSingleCall {
			outChunk.AppendTime(r.buf.time[idx])
			outChunk.AppendIntervalIndex(outChunk.Len() - 1)
		}
		outChunk.Column(r.outOrdinal).AppendNilsV2(true)
		outChunk.Column(r.outOrdinal).AppendIntegerValues(r.buf.value[idx])
		if r.auxProcessor != nil {
			r.appendInAuxCol(inChunk, outChunk, vs+r.buf.index[idx])
		}
	} else {
		if r.isSingleCall {
			outChunk.AppendTime(time)
			outChunk.AppendIntervalIndex(outChunk.Len() - 1)
		}
		outChunk.Column(r.outOrdinal).AppendNilsV2(true)
		outChunk.Column(r.outOrdinal).AppendFloatValues(val)
	}
}

func (r *IntegerColIntegerSliceIterator) processFirstWindow(
	inChunk, outChunk Chunk, sameInterval, haveMultiInterval bool, start, end int,
) {
	r.buf.AppendItem(inChunk, r.inOrdinal, start, end)
	if r.auxProcessor != nil {
		r.updateAuxChunk(inChunk, r.auxChunk, start, end)
	}
	if haveMultiInterval || !sameInterval {
		index, time, value, isNil := r.fn(r.buf)
		if !isNil {
			r.mergePrevItem(outChunk, index, time, value)
		}
		r.buf.Reset()
	}
}

func (r *IntegerColIntegerSliceIterator) processLastWindow(
	inChunk Chunk, start, end int,
) {
	r.buf.AppendItem(inChunk, r.inOrdinal, start, end)
	if r.auxProcessor != nil {
		r.updateAuxChunk(inChunk, r.auxChunk, start, end)
	}
}

func (r *IntegerColIntegerSliceIterator) processMiddleWindow(
	inChunk, outChunk Chunk, start, end int,
) {
	r.buf.AppendItem(inChunk, r.inOrdinal, start, end)
	index, time, value, isNil := r.fn(r.buf)
	if !isNil {
		r.assembleCurrItem(inChunk, outChunk, start, index, time, value)
	}
	r.buf.Reset()
}

func (r *IntegerColIntegerSliceIterator) Next(ie *IteratorEndpoint, p *IteratorParams) {
	inChunk, outChunk := ie.InputPoint.Chunk, ie.OutputPoint.Chunk

	var end int
	firstIndex, lastIndex := 0, len(inChunk.IntervalIndex())-1
	for i, start := range inChunk.IntervalIndex() {
		if i < lastIndex {
			end = inChunk.IntervalIndex()[i+1]
		} else {
			end = inChunk.NumberOfRows()
		}
		if !r.isSingleCall {
			start, end = inChunk.Column(r.inOrdinal).GetRangeValueIndexV2(start, end)
			if start == end && r.buf.Len() == 0 && (i < lastIndex || (i == lastIndex && !p.sameInterval)) {
				outChunk.Column(r.outOrdinal).AppendNilsV2(false)
				continue
			}
		}
		if i == firstIndex && r.buf.Len() > 0 {
			r.processFirstWindow(inChunk, outChunk, p.sameInterval,
				firstIndex != lastIndex, start, end)
		} else if i == lastIndex && p.sameInterval {
			r.processLastWindow(inChunk, start, end)
		} else {
			r.processMiddleWindow(inChunk, outChunk, start, end)
		}
	}
}

type StringColReduceSliceReduce func(stringItem *StringSliceItem) (index int, time int64, value float64, isNil bool)

func NewStringSliceItem() *StringSliceItem {
	return &StringSliceItem{}
}

type StringColStringSliceIterator struct {
	isSingleCall bool
	inOrdinal    int
	outOrdinal   int
	buf          *StringSliceItem
	fn           StringColReduceSliceReduce
	auxChunk     Chunk
	auxProcessor []*AuxProcessor
	windowIndex  []int
}

func NewStringColStringSliceIterator(fn StringColReduceSliceReduce,
	isSingleCall bool, inOrdinal, outOrdinal int, auxProcessor []*AuxProcessor, rowDataType hybridqp.RowDataType,
) *StringColStringSliceIterator {
	r := &StringColStringSliceIterator{
		buf:          NewStringSliceItem(),
		fn:           fn,
		isSingleCall: isSingleCall,
		inOrdinal:    inOrdinal,
		outOrdinal:   outOrdinal,
	}
	if isSingleCall && len(auxProcessor) > 0 {
		r.auxProcessor = auxProcessor
		r.auxChunk = NewChunkBuilder(rowDataType).NewChunk("")
	}
	return r
}

func (r *StringColStringSliceIterator) appendInAuxCol(
	inChunk, outChunk Chunk, index int,
) {
	for j := range r.auxProcessor {
		r.auxProcessor[j].auxHelperFunc(
			inChunk.Column(r.auxProcessor[j].inOrdinal),
			outChunk.Column(r.auxProcessor[j].outOrdinal),
			index,
		)
	}
}

func (r *StringColStringSliceIterator) appendOutAuxCol(
	inChunk, outChunk Chunk, index int,
) {
	for j := range r.auxProcessor {
		r.auxProcessor[j].auxHelperFunc(
			inChunk.Column(r.auxProcessor[j].outOrdinal),
			outChunk.Column(r.auxProcessor[j].outOrdinal),
			index,
		)
	}
}

func (r *StringColStringSliceIterator) updateAuxChunk(
	inChunk, outChunk Chunk, start, end int,
) {
	if start == end {
		return
	}
	for j := start; j < end; j++ {
		r.windowIndex = append(r.windowIndex, j)
	}
	for j := range r.auxProcessor {
		r.auxProcessor[j].auxHelperFunc(
			inChunk.Column(r.auxProcessor[j].inOrdinal),
			outChunk.Column(r.auxProcessor[j].outOrdinal),
			r.windowIndex...,
		)
	}
	r.windowIndex = r.windowIndex[:0]
}

func (r *StringColStringSliceIterator) mergePrevItem(
	outChunk Chunk, idx int, time int64, val float64,
) {
	if idx != -1 {
		if r.isSingleCall {
			outChunk.AppendTime(r.buf.time[idx])
			outChunk.AppendIntervalIndex(outChunk.Len() - 1)
		}
		outChunk.Column(r.outOrdinal).AppendNilsV2(true)
		outChunk.Column(r.outOrdinal).AppendStringValues(r.buf.value[idx])
		if r.auxProcessor != nil {
			r.appendOutAuxCol(r.auxChunk, outChunk, r.buf.index[idx])
			r.auxChunk.Reset()
		}
	} else {
		if r.isSingleCall {
			outChunk.AppendTime(time)
			outChunk.AppendIntervalIndex(outChunk.Len() - 1)
		}
		outChunk.Column(r.outOrdinal).AppendNilsV2(true)
		outChunk.Column(r.outOrdinal).AppendFloatValues(val)
	}
}

func (r *StringColStringSliceIterator) assembleCurrItem(
	inChunk, outChunk Chunk, vs, idx int, time int64, val float64,
) {
	if idx != -1 {
		if r.isSingleCall {
			outChunk.AppendTime(r.buf.time[idx])
			outChunk.AppendIntervalIndex(outChunk.Len() - 1)
		}
		outChunk.Column(r.outOrdinal).AppendNilsV2(true)
		outChunk.Column(r.outOrdinal).AppendStringValues(r.buf.value[idx])
		if r.auxProcessor != nil {
			r.appendInAuxCol(inChunk, outChunk, vs+r.buf.index[idx])
		}
	} else {
		if r.isSingleCall {
			outChunk.AppendTime(time)
			outChunk.AppendIntervalIndex(outChunk.Len() - 1)
		}
		outChunk.Column(r.outOrdinal).AppendNilsV2(true)
		outChunk.Column(r.outOrdinal).AppendFloatValues(val)
	}
}

func (r *StringColStringSliceIterator) processFirstWindow(
	inChunk, outChunk Chunk, sameInterval, haveMultiInterval bool, start, end int,
) {
	r.buf.AppendItem(inChunk, r.inOrdinal, start, end)
	if r.auxProcessor != nil {
		r.updateAuxChunk(inChunk, r.auxChunk, start, end)
	}
	if haveMultiInterval || !sameInterval {
		index, time, value, isNil := r.fn(r.buf)
		if !isNil {
			r.mergePrevItem(outChunk, index, time, value)
		}
		r.buf.Reset()
	}
}

func (r *StringColStringSliceIterator) processLastWindow(
	inChunk Chunk, start, end int,
) {
	r.buf.AppendItem(inChunk, r.inOrdinal, start, end)
	if r.auxProcessor != nil {
		r.updateAuxChunk(inChunk, r.auxChunk, start, end)
	}
}

func (r *StringColStringSliceIterator) processMiddleWindow(
	inChunk, outChunk Chunk, start, end int,
) {
	r.buf.AppendItem(inChunk, r.inOrdinal, start, end)
	index, time, value, isNil := r.fn(r.buf)
	if !isNil {
		r.assembleCurrItem(inChunk, outChunk, start, index, time, value)
	}
	r.buf.Reset()
}

func (r *StringColStringSliceIterator) Next(ie *IteratorEndpoint, p *IteratorParams) {
	inChunk, outChunk := ie.InputPoint.Chunk, ie.OutputPoint.Chunk

	var end int
	firstIndex, lastIndex := 0, len(inChunk.IntervalIndex())-1
	for i, start := range inChunk.IntervalIndex() {
		if i < lastIndex {
			end = inChunk.IntervalIndex()[i+1]
		} else {
			end = inChunk.NumberOfRows()
		}
		if !r.isSingleCall {
			start, end = inChunk.Column(r.inOrdinal).GetRangeValueIndexV2(start, end)
			if start == end && r.buf.Len() == 0 && (i < lastIndex || (i == lastIndex && !p.sameInterval)) {
				outChunk.Column(r.outOrdinal).AppendNilsV2(false)
				continue
			}
		}
		if i == firstIndex && r.buf.Len() > 0 {
			r.processFirstWindow(inChunk, outChunk, p.sameInterval,
				firstIndex != lastIndex, start, end)
		} else if i == lastIndex && p.sameInterval {
			r.processLastWindow(inChunk, start, end)
		} else {
			r.processMiddleWindow(inChunk, outChunk, start, end)
		}
	}
}

type BooleanColReduceSliceReduce func(booleanItem *BooleanSliceItem) (index int, time int64, value float64, isNil bool)

func NewBooleanSliceItem() *BooleanSliceItem {
	return &BooleanSliceItem{}
}

type BooleanColBooleanSliceIterator struct {
	isSingleCall bool
	inOrdinal    int
	outOrdinal   int
	buf          *BooleanSliceItem
	fn           BooleanColReduceSliceReduce
	auxChunk     Chunk
	auxProcessor []*AuxProcessor
	windowIndex  []int
}

func NewBooleanColBooleanSliceIterator(fn BooleanColReduceSliceReduce,
	isSingleCall bool, inOrdinal, outOrdinal int, auxProcessor []*AuxProcessor, rowDataType hybridqp.RowDataType,
) *BooleanColBooleanSliceIterator {
	r := &BooleanColBooleanSliceIterator{
		buf:          NewBooleanSliceItem(),
		fn:           fn,
		isSingleCall: isSingleCall,
		inOrdinal:    inOrdinal,
		outOrdinal:   outOrdinal,
	}
	if isSingleCall && len(auxProcessor) > 0 {
		r.auxProcessor = auxProcessor
		r.auxChunk = NewChunkBuilder(rowDataType).NewChunk("")
	}
	return r
}

func (r *BooleanColBooleanSliceIterator) appendInAuxCol(
	inChunk, outChunk Chunk, index int,
) {
	for j := range r.auxProcessor {
		r.auxProcessor[j].auxHelperFunc(
			inChunk.Column(r.auxProcessor[j].inOrdinal),
			outChunk.Column(r.auxProcessor[j].outOrdinal),
			index,
		)
	}
}

func (r *BooleanColBooleanSliceIterator) appendOutAuxCol(
	inChunk, outChunk Chunk, index int,
) {
	for j := range r.auxProcessor {
		r.auxProcessor[j].auxHelperFunc(
			inChunk.Column(r.auxProcessor[j].outOrdinal),
			outChunk.Column(r.auxProcessor[j].outOrdinal),
			index,
		)
	}
}

func (r *BooleanColBooleanSliceIterator) updateAuxChunk(
	inChunk, outChunk Chunk, start, end int,
) {
	if start == end {
		return
	}
	for j := start; j < end; j++ {
		r.windowIndex = append(r.windowIndex, j)
	}
	for j := range r.auxProcessor {
		r.auxProcessor[j].auxHelperFunc(
			inChunk.Column(r.auxProcessor[j].inOrdinal),
			outChunk.Column(r.auxProcessor[j].outOrdinal),
			r.windowIndex...,
		)
	}
	r.windowIndex = r.windowIndex[:0]
}

func (r *BooleanColBooleanSliceIterator) mergePrevItem(
	outChunk Chunk, idx int, time int64, val float64,
) {
	if idx != -1 {
		if r.isSingleCall {
			outChunk.AppendTime(r.buf.time[idx])
			outChunk.AppendIntervalIndex(outChunk.Len() - 1)
		}
		outChunk.Column(r.outOrdinal).AppendNilsV2(true)
		outChunk.Column(r.outOrdinal).AppendBooleanValues(r.buf.value[idx])
		if r.auxProcessor != nil {
			r.appendOutAuxCol(r.auxChunk, outChunk, r.buf.index[idx])
			r.auxChunk.Reset()
		}
	} else {
		if r.isSingleCall {
			outChunk.AppendTime(time)
			outChunk.AppendIntervalIndex(outChunk.Len() - 1)
		}
		outChunk.Column(r.outOrdinal).AppendNilsV2(true)
		outChunk.Column(r.outOrdinal).AppendFloatValues(val)
	}
}

func (r *BooleanColBooleanSliceIterator) assembleCurrItem(
	inChunk, outChunk Chunk, vs, idx int, time int64, val float64,
) {
	if idx != -1 {
		if r.isSingleCall {
			outChunk.AppendTime(r.buf.time[idx])
			outChunk.AppendIntervalIndex(outChunk.Len() - 1)
		}
		outChunk.Column(r.outOrdinal).AppendNilsV2(true)
		outChunk.Column(r.outOrdinal).AppendBooleanValues(r.buf.value[idx])
		if r.auxProcessor != nil {
			r.appendInAuxCol(inChunk, outChunk, vs+r.buf.index[idx])
		}
	} else {
		if r.isSingleCall {
			outChunk.AppendTime(time)
			outChunk.AppendIntervalIndex(outChunk.Len() - 1)
		}
		outChunk.Column(r.outOrdinal).AppendNilsV2(true)
		outChunk.Column(r.outOrdinal).AppendFloatValues(val)
	}
}

func (r *BooleanColBooleanSliceIterator) processFirstWindow(
	inChunk, outChunk Chunk, sameInterval, haveMultiInterval bool, start, end int,
) {
	r.buf.AppendItem(inChunk, r.inOrdinal, start, end)
	if r.auxProcessor != nil {
		r.updateAuxChunk(inChunk, r.auxChunk, start, end)
	}
	if haveMultiInterval || !sameInterval {
		index, time, value, isNil := r.fn(r.buf)
		if !isNil {
			r.mergePrevItem(outChunk, index, time, value)
		}
		r.buf.Reset()
	}
}

func (r *BooleanColBooleanSliceIterator) processLastWindow(
	inChunk Chunk, start, end int,
) {
	r.buf.AppendItem(inChunk, r.inOrdinal, start, end)
	if r.auxProcessor != nil {
		r.updateAuxChunk(inChunk, r.auxChunk, start, end)
	}
}

func (r *BooleanColBooleanSliceIterator) processMiddleWindow(
	inChunk, outChunk Chunk, start, end int,
) {
	r.buf.AppendItem(inChunk, r.inOrdinal, start, end)
	index, time, value, isNil := r.fn(r.buf)
	if !isNil {
		r.assembleCurrItem(inChunk, outChunk, start, index, time, value)
	}
	r.buf.Reset()
}

func (r *BooleanColBooleanSliceIterator) Next(ie *IteratorEndpoint, p *IteratorParams) {
	inChunk, outChunk := ie.InputPoint.Chunk, ie.OutputPoint.Chunk

	var end int
	firstIndex, lastIndex := 0, len(inChunk.IntervalIndex())-1
	for i, start := range inChunk.IntervalIndex() {
		if i < lastIndex {
			end = inChunk.IntervalIndex()[i+1]
		} else {
			end = inChunk.NumberOfRows()
		}
		if !r.isSingleCall {
			start, end = inChunk.Column(r.inOrdinal).GetRangeValueIndexV2(start, end)
			if start == end && r.buf.Len() == 0 && (i < lastIndex || (i == lastIndex && !p.sameInterval)) {
				outChunk.Column(r.outOrdinal).AppendNilsV2(false)
				continue
			}
		}
		if i == firstIndex && r.buf.Len() > 0 {
			r.processFirstWindow(inChunk, outChunk, p.sameInterval,
				firstIndex != lastIndex, start, end)
		} else if i == lastIndex && p.sameInterval {
			r.processLastWindow(inChunk, start, end)
		} else {
			r.processMiddleWindow(inChunk, outChunk, start, end)
		}
	}
}

type FloatPointItem struct {
	time  int64
	value float64
	index int
}

func NewFloatPointItem(time int64, value float64) *FloatPointItem {
	return &FloatPointItem{
		time:  time,
		value: value,
	}
}

type FloatHeapItem struct {
	sortByTime bool
	maxIndex   int
	cmpByValue func(a, b *FloatPointItem) bool
	cmpByTime  func(a, b *FloatPointItem) bool
	items      []FloatPointItem
}

func NewFloatHeapItem(n int, cmpByValue, cmpByTime func(a, b *FloatPointItem) bool) *FloatHeapItem {
	return &FloatHeapItem{
		items:      make([]FloatPointItem, 0, n),
		cmpByValue: cmpByValue,
		cmpByTime:  cmpByTime,
	}
}

func (f *FloatHeapItem) appendFast(input Chunk, start, end, ordinal int) {
	// fast path
	for i := start; i < end; i++ {
		p := NewFloatPointItem(
			input.TimeByIndex(i),
			input.Column(ordinal).FloatValues()[i])
		if f.Len() == cap(f.items) {
			if !f.cmpByValue(&f.items[0], p) {
				continue
			}
			f.items[0] = *p
			heap.Fix(f, 0)
			continue
		} else {
			heap.Push(f, *p)
		}
	}
}

func (f *FloatHeapItem) appendSlow(input Chunk, start, end, ordinal int) {
	// slow path
	for i := start; i < end; i++ {
		if input.Column(ordinal).IsNilV2(i) {
			continue
		}
		p := NewFloatPointItem(
			input.TimeByIndex(i),
			input.Column(ordinal).FloatValues()[input.Column(ordinal).GetValueIndexV2(i)])
		if f.Len() == cap(f.items) {
			if !f.cmpByValue(&f.items[0], p) {
				continue
			}
			f.items[0] = *p
			heap.Fix(f, 0)
			continue
		} else {
			heap.Push(f, *p)
		}
	}
}

func (f *FloatHeapItem) append(input Chunk, start, end, ordinal int) {
	if input.Column(ordinal).NilCount() == 0 {
		f.appendFast(input, start, end, ordinal)
	} else {
		f.appendSlow(input, start, end, ordinal)
	}
}

func (f *FloatHeapItem) appendForAuxFast(input Chunk, start, end, ordinal, maxIndex int) {
	// fast path
	for i := start; i < end; i++ {
		p := NewFloatPointItem(
			input.TimeByIndex(i),
			input.Column(ordinal).FloatValues()[i])
		p.index = maxIndex + i
		if f.Len() == cap(f.items) {
			if !f.cmpByValue(&f.items[0], p) {
				continue
			}
			if (*p).index > f.maxIndex {
				f.maxIndex = (*p).index
			}
			f.items[0] = *p
			heap.Fix(f, 0)
			continue
		} else {
			if (*p).index > f.maxIndex {
				f.maxIndex = (*p).index
			}
			heap.Push(f, *p)
		}
	}
}

func (f *FloatHeapItem) appendForAuxSlow(input Chunk, start, end, ordinal, maxIndex int) {
	// slow path
	for i := start; i < end; i++ {
		if input.Column(ordinal).IsNilV2(i) {
			continue
		}
		p := NewFloatPointItem(
			input.TimeByIndex(i),
			input.Column(ordinal).FloatValues()[input.Column(ordinal).GetValueIndexV2(i)])
		p.index = maxIndex + i
		if f.Len() == cap(f.items) {
			if !f.cmpByValue(&f.items[0], p) {
				continue
			}
			if (*p).index > f.maxIndex {
				f.maxIndex = (*p).index
			}
			f.items[0] = *p
			heap.Fix(f, 0)
			continue
		} else {
			if (*p).index > f.maxIndex {
				f.maxIndex = (*p).index
			}
			heap.Push(f, *p)
		}
	}
}

func (f *FloatHeapItem) appendForAux(input Chunk, start, end, ordinal int) []int {
	// make each index unique
	maxIndex := f.maxIndex + 1 - start
	if input.Column(ordinal).NilCount() == 0 {
		f.appendForAuxFast(input, start, end, ordinal, maxIndex)
	} else {
		f.appendForAuxSlow(input, start, end, ordinal, maxIndex)
	}
	index := make([]int, 0)
	for i := range f.items {
		if idx := f.items[i].index - maxIndex; idx >= start {
			index = append(index, idx)
		}
	}
	return index
}

func (f *FloatHeapItem) Reset() {
	f.items = f.items[:0]
	f.sortByTime = false
	f.maxIndex = 0
}

func (f *FloatHeapItem) Len() int {
	return len(f.items)
}

func (f *FloatHeapItem) Less(i, j int) bool {
	if !f.sortByTime {
		return f.cmpByValue(&f.items[i], &f.items[j])
	}
	return f.cmpByTime(&f.items[i], &f.items[j])
}

func (f *FloatHeapItem) Swap(i, j int) {
	f.items[i], f.items[j] = f.items[j], f.items[i]
}

func (f *FloatHeapItem) Push(x interface{}) {
	f.items = append(f.items, x.(FloatPointItem))
}

func (f *FloatHeapItem) Pop() interface{} {
	p := f.items[len(f.items)-1]
	f.items = f.items[:len(f.items)-1]
	return p
}

type IntegerPointItem struct {
	time  int64
	value int64
	index int
}

func NewIntegerPointItem(time int64, value int64) *IntegerPointItem {
	return &IntegerPointItem{
		time:  time,
		value: value,
	}
}

type IntegerHeapItem struct {
	sortByTime bool
	maxIndex   int
	cmpByValue func(a, b *IntegerPointItem) bool
	cmpByTime  func(a, b *IntegerPointItem) bool
	items      []IntegerPointItem
}

func NewIntegerHeapItem(n int, cmpByValue, cmpByTime func(a, b *IntegerPointItem) bool) *IntegerHeapItem {
	return &IntegerHeapItem{
		items:      make([]IntegerPointItem, 0, n),
		cmpByValue: cmpByValue,
		cmpByTime:  cmpByTime,
	}
}

func (f *IntegerHeapItem) appendFast(input Chunk, start, end, ordinal int) {
	// fast path
	for i := start; i < end; i++ {
		p := NewIntegerPointItem(
			input.TimeByIndex(i),
			input.Column(ordinal).IntegerValues()[i])
		if f.Len() == cap(f.items) {
			if !f.cmpByValue(&f.items[0], p) {
				continue
			}
			f.items[0] = *p
			heap.Fix(f, 0)
			continue
		} else {
			heap.Push(f, *p)
		}
	}
}

func (f *IntegerHeapItem) appendSlow(input Chunk, start, end, ordinal int) {
	// slow path
	for i := start; i < end; i++ {
		if input.Column(ordinal).IsNilV2(i) {
			continue
		}
		p := NewIntegerPointItem(
			input.TimeByIndex(i),
			input.Column(ordinal).IntegerValues()[input.Column(ordinal).GetValueIndexV2(i)])
		if f.Len() == cap(f.items) {
			if !f.cmpByValue(&f.items[0], p) {
				continue
			}
			f.items[0] = *p
			heap.Fix(f, 0)
			continue
		} else {
			heap.Push(f, *p)
		}
	}
}

func (f *IntegerHeapItem) append(input Chunk, start, end, ordinal int) {
	if input.Column(ordinal).NilCount() == 0 {
		f.appendFast(input, start, end, ordinal)
	} else {
		f.appendSlow(input, start, end, ordinal)
	}
}

func (f *IntegerHeapItem) appendForAuxFast(input Chunk, start, end, ordinal, maxIndex int) {
	// fast path
	for i := start; i < end; i++ {
		p := NewIntegerPointItem(
			input.TimeByIndex(i),
			input.Column(ordinal).IntegerValues()[i])
		p.index = maxIndex + i
		if f.Len() == cap(f.items) {
			if !f.cmpByValue(&f.items[0], p) {
				continue
			}
			if (*p).index > f.maxIndex {
				f.maxIndex = (*p).index
			}
			f.items[0] = *p
			heap.Fix(f, 0)
			continue
		} else {
			if (*p).index > f.maxIndex {
				f.maxIndex = (*p).index
			}
			heap.Push(f, *p)
		}
	}
}

func (f *IntegerHeapItem) appendForAuxSlow(input Chunk, start, end, ordinal, maxIndex int) {
	// slow path
	for i := start; i < end; i++ {
		if input.Column(ordinal).IsNilV2(i) {
			continue
		}
		p := NewIntegerPointItem(
			input.TimeByIndex(i),
			input.Column(ordinal).IntegerValues()[input.Column(ordinal).GetValueIndexV2(i)])
		p.index = maxIndex + i
		if f.Len() == cap(f.items) {
			if !f.cmpByValue(&f.items[0], p) {
				continue
			}
			if (*p).index > f.maxIndex {
				f.maxIndex = (*p).index
			}
			f.items[0] = *p
			heap.Fix(f, 0)
			continue
		} else {
			if (*p).index > f.maxIndex {
				f.maxIndex = (*p).index
			}
			heap.Push(f, *p)
		}
	}
}

func (f *IntegerHeapItem) appendForAux(input Chunk, start, end, ordinal int) []int {
	// make each index unique
	maxIndex := f.maxIndex + 1 - start
	if input.Column(ordinal).NilCount() == 0 {
		f.appendForAuxFast(input, start, end, ordinal, maxIndex)
	} else {
		f.appendForAuxSlow(input, start, end, ordinal, maxIndex)
	}
	index := make([]int, 0)
	for i := range f.items {
		if idx := f.items[i].index - maxIndex; idx >= start {
			index = append(index, idx)
		}
	}
	return index
}

func (f *IntegerHeapItem) Reset() {
	f.items = f.items[:0]
	f.sortByTime = false
	f.maxIndex = 0
}

func (f *IntegerHeapItem) Len() int {
	return len(f.items)
}

func (f *IntegerHeapItem) Less(i, j int) bool {
	if !f.sortByTime {
		return f.cmpByValue(&f.items[i], &f.items[j])
	}
	return f.cmpByTime(&f.items[i], &f.items[j])
}

func (f *IntegerHeapItem) Swap(i, j int) {
	f.items[i], f.items[j] = f.items[j], f.items[i]
}

func (f *IntegerHeapItem) Push(x interface{}) {
	f.items = append(f.items, x.(IntegerPointItem))
}

func (f *IntegerHeapItem) Pop() interface{} {
	p := f.items[len(f.items)-1]
	f.items = f.items[:len(f.items)-1]
	return p
}

type FloatColFloatHeapIterator struct {
	n             int
	inOrdinal     int
	outOrdinal    int
	prevMaxIndex  int
	buf           *FloatHeapItem
	auxChunk      Chunk
	auxProcessor  []*AuxProcessor
	windowIndex   []int
	prevBufIndex  []int
	currBufIndex  []int
	interBufIndex []int
}

func NewFloatColFloatHeapIterator(
	inOrdinal, outOrdinal int, auxProcessor []*AuxProcessor, rowDataType hybridqp.RowDataType, FloatHeapItem *FloatHeapItem,
) *FloatColFloatHeapIterator {
	r := &FloatColFloatHeapIterator{
		buf:        FloatHeapItem,
		inOrdinal:  inOrdinal,
		outOrdinal: outOrdinal,
	}
	if len(auxProcessor) > 0 {
		r.auxProcessor = auxProcessor
		r.auxChunk = NewChunkBuilder(rowDataType).NewChunk("")
	}
	return r
}

func (r *FloatColFloatHeapIterator) appendPrevItem(
	inChunk, outChunk Chunk,
) {
	for j := range r.buf.items {
		outChunk.AppendTime(r.buf.items[j].time)
		outChunk.Column(r.outOrdinal).AppendFloatValues(r.buf.items[j].value)
		outChunk.Column(r.outOrdinal).AppendNilsV2(true)
	}
	if len(r.auxProcessor) > 0 {
		for j := range r.buf.items {
			r.windowIndex = append(r.windowIndex, j)
		}
		for j := range r.auxProcessor {
			r.auxProcessor[j].auxHelperFunc(
				r.auxChunk.Column(r.auxProcessor[j].outOrdinal),
				outChunk.Column(r.auxProcessor[j].outOrdinal),
				r.windowIndex...,
			)
		}
		r.windowIndex = r.windowIndex[:0]
		r.auxChunk.Reset()
	}
	outChunk.AppendIntervalIndex(outChunk.Len() - r.buf.Len())
}

func (r *FloatColFloatHeapIterator) appendCurrItem(
	inChunk, outChunk Chunk, start int,
) {
	for j := range r.buf.items {
		outChunk.AppendTime(r.buf.items[j].time)
		outChunk.Column(r.outOrdinal).AppendFloatValues(r.buf.items[j].value)
		outChunk.Column(r.outOrdinal).AppendNilsV2(true)
	}
	if len(r.auxProcessor) > 0 {
		for i := range r.buf.items {
			r.currBufIndex = append(r.currBufIndex, r.buf.items[i].index+start-r.prevMaxIndex)
		}
		hybridqp.SortS1ByS2(r.windowIndex, r.currBufIndex)
		for j := range r.auxProcessor {
			r.auxProcessor[j].auxHelperFunc(
				inChunk.Column(r.auxProcessor[j].inOrdinal),
				outChunk.Column(r.auxProcessor[j].outOrdinal),
				r.windowIndex...,
			)
		}
		r.windowIndex = r.windowIndex[:0]
		r.currBufIndex = r.currBufIndex[:0]
	}
	outChunk.AppendIntervalIndex(outChunk.Len() - r.buf.Len())
}

func (r *FloatColFloatHeapIterator) updateAuxColInChunk(inChunk Chunk) {
	if len(r.interBufIndex) == 0 {
		r.auxChunk.Reset()
	}
	// inserts elements pushed from the heap
	r.currBufIndex = r.currBufIndex[:0]
	for i := range r.buf.items {
		r.currBufIndex = append(r.currBufIndex, r.buf.items[i].index-r.prevMaxIndex)
	}
	hybridqp.SortS1ByS2(r.windowIndex, r.currBufIndex)

	for j := range r.auxProcessor {
		r.auxProcessor[j].auxHelperFunc(
			inChunk.Column(r.auxProcessor[j].inOrdinal),
			r.auxChunk.Column(r.auxProcessor[j].outOrdinal),
			r.windowIndex...,
		)
	}
}

func (r *FloatColFloatHeapIterator) updateAuxColBothChunk(inChunk Chunk) {
	clone := r.auxChunk.Clone()
	r.auxChunk.Reset()
	sort.Ints(r.interBufIndex)

	r.currBufIndex = r.currBufIndex[:0]
	for i := range r.prevBufIndex {
		if hybridqp.BinarySearch(r.prevBufIndex[i], r.interBufIndex) {
			r.currBufIndex = append(r.currBufIndex, i)
		}
	}

	r.prevBufIndex = r.prevBufIndex[:0]
	for i := range r.buf.items {
		r.prevBufIndex = append(r.prevBufIndex, r.buf.items[i].index-r.prevMaxIndex)
	}
	hybridqp.SortS1ByS2(r.windowIndex, r.prevBufIndex)

	cs, ws := 0, 0
	for i := range r.buf.items {
		if hybridqp.BinarySearch(r.buf.items[i].index, r.interBufIndex) {
			// inserts elements still remained in the heap
			for j := range r.auxProcessor {
				r.auxProcessor[j].auxHelperFunc(
					clone.Column(r.auxProcessor[j].outOrdinal),
					r.auxChunk.Column(r.auxProcessor[j].outOrdinal),
					r.currBufIndex[cs],
				)
			}
			cs++
		} else {
			// inserts elements pushed from the heap
			for j := range r.auxProcessor {
				r.auxProcessor[j].auxHelperFunc(
					inChunk.Column(r.auxProcessor[j].inOrdinal),
					r.auxChunk.Column(r.auxProcessor[j].outOrdinal),
					r.windowIndex[ws],
				)
			}
			ws++
		}
	}
	clone.Reset()
}

func (r *FloatColFloatHeapIterator) reset() {
	r.prevBufIndex = r.prevBufIndex[:0]
	r.currBufIndex = r.currBufIndex[:0]
	r.interBufIndex = r.interBufIndex[:0]
	r.windowIndex = r.windowIndex[:0]
	r.buf.sortByTime = false
}

func (r *FloatColFloatHeapIterator) updatePrevItem(
	inChunk Chunk, start, end int,
) {
	if len(r.auxProcessor) == 0 {
		r.buf.append(inChunk, start, end, r.inOrdinal)
	} else {
		r.buf.sortByTime = true
		sort.Sort(r.buf)
		for i := range r.buf.items {
			r.prevBufIndex = append(r.prevBufIndex, r.buf.items[i].index)
		}
		r.buf.sortByTime = false
		sort.Sort(r.buf)
		r.prevMaxIndex = r.buf.maxIndex + 1

		r.windowIndex = r.buf.appendForAux(inChunk, start, end, r.inOrdinal)

		r.buf.sortByTime = true
		sort.Sort(r.buf)

		for i := range r.buf.items {
			r.currBufIndex = append(r.currBufIndex, r.buf.items[i].index)
		}
		r.interBufIndex = hybridqp.Intersect(r.prevBufIndex, r.currBufIndex)

		if !hybridqp.IsSubSlice(r.prevBufIndex, r.currBufIndex) {
			r.updateAuxColBothChunk(inChunk)
		} else {
			r.updateAuxColInChunk(inChunk)
		}
	}
	r.reset()
}

func (r *FloatColFloatHeapIterator) updateCurrItem(
	inChunk Chunk, start, end int,
) {
	if len(r.auxProcessor) == 0 {
		r.buf.append(inChunk, start, end, r.inOrdinal)
	} else {
		r.buf.sortByTime = true
		sort.Sort(r.buf)
		r.prevMaxIndex = r.buf.maxIndex + 1
		r.windowIndex = r.buf.appendForAux(inChunk, start, end, r.inOrdinal)
		for j := range r.auxProcessor {
			r.auxProcessor[j].auxHelperFunc(
				inChunk.Column(r.auxProcessor[j].inOrdinal),
				r.auxChunk.Column(r.auxProcessor[j].outOrdinal),
				r.windowIndex...,
			)
		}
		r.windowIndex = r.windowIndex[:0]
		r.currBufIndex = r.currBufIndex[:0]
		r.buf.sortByTime = false
	}
}

func (r *FloatColFloatHeapIterator) processFirstWindow(
	inChunk, outChunk Chunk, sameInterval, hasMultiInterval bool, start, end int,
) {
	r.updatePrevItem(inChunk, start, end)
	if hasMultiInterval || !sameInterval {
		r.buf.sortByTime = true
		sort.Sort(r.buf)
		if r.buf.Len() > 0 {
			r.appendPrevItem(r.auxChunk, outChunk)
		}
		r.buf.Reset()
	}
}

func (r *FloatColFloatHeapIterator) processLastWindow(
	inChunk Chunk, start, end int,
) {
	r.updateCurrItem(inChunk, start, end)
}

func (r *FloatColFloatHeapIterator) processMiddleWindow(
	inChunk, outChunk Chunk, start, end int,
) {
	if len(r.auxProcessor) == 0 {
		r.buf.append(inChunk, start, end, r.inOrdinal)
	} else {
		r.prevMaxIndex = r.buf.maxIndex + 1
		r.windowIndex = r.buf.appendForAux(inChunk, start, end, r.inOrdinal)
	}
	r.buf.sortByTime = true
	sort.Sort(r.buf)
	if r.buf.Len() > 0 {
		r.appendCurrItem(inChunk, outChunk, start)
	}
	r.buf.Reset()
}

func (r *FloatColFloatHeapIterator) Next(ie *IteratorEndpoint, p *IteratorParams) {
	inChunk, outChunk := ie.InputPoint.Chunk, ie.OutputPoint.Chunk
	if inChunk.Column(r.inOrdinal).IsEmpty() {
		return
	}

	var end int
	firstIndex, lastIndex := 0, len(inChunk.IntervalIndex())-1
	for i, start := range inChunk.IntervalIndex() {
		if i < lastIndex {
			end = inChunk.IntervalIndex()[i+1]
		} else {
			end = inChunk.NumberOfRows()
		}
		if i == firstIndex && r.buf.Len() > 0 {
			r.processFirstWindow(inChunk, outChunk, p.sameInterval,
				firstIndex != lastIndex, start, end)
		} else if i == lastIndex && p.sameInterval {
			r.processLastWindow(inChunk, start, end)
		} else {
			r.processMiddleWindow(inChunk, outChunk, start, end)
		}
	}
}

type IntegerColIntegerHeapIterator struct {
	n             int
	inOrdinal     int
	outOrdinal    int
	prevMaxIndex  int
	buf           *IntegerHeapItem
	auxChunk      Chunk
	auxProcessor  []*AuxProcessor
	windowIndex   []int
	prevBufIndex  []int
	currBufIndex  []int
	interBufIndex []int
}

func NewIntegerColIntegerHeapIterator(
	inOrdinal, outOrdinal int, auxProcessor []*AuxProcessor, rowDataType hybridqp.RowDataType, IntegerHeapItem *IntegerHeapItem,
) *IntegerColIntegerHeapIterator {
	r := &IntegerColIntegerHeapIterator{
		buf:        IntegerHeapItem,
		inOrdinal:  inOrdinal,
		outOrdinal: outOrdinal,
	}
	if len(auxProcessor) > 0 {
		r.auxProcessor = auxProcessor
		r.auxChunk = NewChunkBuilder(rowDataType).NewChunk("")
	}
	return r
}

func (r *IntegerColIntegerHeapIterator) appendPrevItem(
	inChunk, outChunk Chunk,
) {
	for j := range r.buf.items {
		outChunk.AppendTime(r.buf.items[j].time)
		outChunk.Column(r.outOrdinal).AppendIntegerValues(r.buf.items[j].value)
		outChunk.Column(r.outOrdinal).AppendNilsV2(true)
	}
	if len(r.auxProcessor) > 0 {
		for j := range r.buf.items {
			r.windowIndex = append(r.windowIndex, j)
		}
		for j := range r.auxProcessor {
			r.auxProcessor[j].auxHelperFunc(
				r.auxChunk.Column(r.auxProcessor[j].outOrdinal),
				outChunk.Column(r.auxProcessor[j].outOrdinal),
				r.windowIndex...,
			)
		}
		r.windowIndex = r.windowIndex[:0]
		r.auxChunk.Reset()
	}
	outChunk.AppendIntervalIndex(outChunk.Len() - r.buf.Len())
}

func (r *IntegerColIntegerHeapIterator) appendCurrItem(
	inChunk, outChunk Chunk, start int,
) {
	for j := range r.buf.items {
		outChunk.AppendTime(r.buf.items[j].time)
		outChunk.Column(r.outOrdinal).AppendIntegerValues(r.buf.items[j].value)
		outChunk.Column(r.outOrdinal).AppendNilsV2(true)
	}
	if len(r.auxProcessor) > 0 {
		for i := range r.buf.items {
			r.currBufIndex = append(r.currBufIndex, r.buf.items[i].index+start-r.prevMaxIndex)
		}
		hybridqp.SortS1ByS2(r.windowIndex, r.currBufIndex)
		for j := range r.auxProcessor {
			r.auxProcessor[j].auxHelperFunc(
				inChunk.Column(r.auxProcessor[j].inOrdinal),
				outChunk.Column(r.auxProcessor[j].outOrdinal),
				r.windowIndex...,
			)
		}
		r.windowIndex = r.windowIndex[:0]
		r.currBufIndex = r.currBufIndex[:0]
	}
	outChunk.AppendIntervalIndex(outChunk.Len() - r.buf.Len())
}

func (r *IntegerColIntegerHeapIterator) updateAuxColInChunk(inChunk Chunk) {
	if len(r.interBufIndex) == 0 {
		r.auxChunk.Reset()
	}
	// inserts elements pushed from the heap
	r.currBufIndex = r.currBufIndex[:0]
	for i := range r.buf.items {
		r.currBufIndex = append(r.currBufIndex, r.buf.items[i].index-r.prevMaxIndex)
	}
	hybridqp.SortS1ByS2(r.windowIndex, r.currBufIndex)

	for j := range r.auxProcessor {
		r.auxProcessor[j].auxHelperFunc(
			inChunk.Column(r.auxProcessor[j].inOrdinal),
			r.auxChunk.Column(r.auxProcessor[j].outOrdinal),
			r.windowIndex...,
		)
	}
}

func (r *IntegerColIntegerHeapIterator) updateAuxColBothChunk(inChunk Chunk) {
	clone := r.auxChunk.Clone()
	r.auxChunk.Reset()
	sort.Ints(r.interBufIndex)

	r.currBufIndex = r.currBufIndex[:0]
	for i := range r.prevBufIndex {
		if hybridqp.BinarySearch(r.prevBufIndex[i], r.interBufIndex) {
			r.currBufIndex = append(r.currBufIndex, i)
		}
	}

	r.prevBufIndex = r.prevBufIndex[:0]
	for i := range r.buf.items {
		r.prevBufIndex = append(r.prevBufIndex, r.buf.items[i].index-r.prevMaxIndex)
	}
	hybridqp.SortS1ByS2(r.windowIndex, r.prevBufIndex)

	cs, ws := 0, 0
	for i := range r.buf.items {
		if hybridqp.BinarySearch(r.buf.items[i].index, r.interBufIndex) {
			// inserts elements still remained in the heap
			for j := range r.auxProcessor {
				r.auxProcessor[j].auxHelperFunc(
					clone.Column(r.auxProcessor[j].outOrdinal),
					r.auxChunk.Column(r.auxProcessor[j].outOrdinal),
					r.currBufIndex[cs],
				)
			}
			cs++
		} else {
			// inserts elements pushed from the heap
			for j := range r.auxProcessor {
				r.auxProcessor[j].auxHelperFunc(
					inChunk.Column(r.auxProcessor[j].inOrdinal),
					r.auxChunk.Column(r.auxProcessor[j].outOrdinal),
					r.windowIndex[ws],
				)
			}
			ws++
		}
	}
	clone.Reset()
}

func (r *IntegerColIntegerHeapIterator) reset() {
	r.prevBufIndex = r.prevBufIndex[:0]
	r.currBufIndex = r.currBufIndex[:0]
	r.interBufIndex = r.interBufIndex[:0]
	r.windowIndex = r.windowIndex[:0]
	r.buf.sortByTime = false
}

func (r *IntegerColIntegerHeapIterator) updatePrevItem(
	inChunk Chunk, start, end int,
) {
	if len(r.auxProcessor) == 0 {
		r.buf.append(inChunk, start, end, r.inOrdinal)
	} else {
		r.buf.sortByTime = true
		sort.Sort(r.buf)
		for i := range r.buf.items {
			r.prevBufIndex = append(r.prevBufIndex, r.buf.items[i].index)
		}
		r.buf.sortByTime = false
		sort.Sort(r.buf)
		r.prevMaxIndex = r.buf.maxIndex + 1

		r.windowIndex = r.buf.appendForAux(inChunk, start, end, r.inOrdinal)

		r.buf.sortByTime = true
		sort.Sort(r.buf)

		for i := range r.buf.items {
			r.currBufIndex = append(r.currBufIndex, r.buf.items[i].index)
		}
		r.interBufIndex = hybridqp.Intersect(r.prevBufIndex, r.currBufIndex)

		if !hybridqp.IsSubSlice(r.prevBufIndex, r.currBufIndex) {
			r.updateAuxColBothChunk(inChunk)
		} else {
			r.updateAuxColInChunk(inChunk)
		}
	}
	r.reset()
}

func (r *IntegerColIntegerHeapIterator) updateCurrItem(
	inChunk Chunk, start, end int,
) {
	if len(r.auxProcessor) == 0 {
		r.buf.append(inChunk, start, end, r.inOrdinal)
	} else {
		r.buf.sortByTime = true
		sort.Sort(r.buf)
		r.prevMaxIndex = r.buf.maxIndex + 1
		r.windowIndex = r.buf.appendForAux(inChunk, start, end, r.inOrdinal)
		for j := range r.auxProcessor {
			r.auxProcessor[j].auxHelperFunc(
				inChunk.Column(r.auxProcessor[j].inOrdinal),
				r.auxChunk.Column(r.auxProcessor[j].outOrdinal),
				r.windowIndex...,
			)
		}
		r.windowIndex = r.windowIndex[:0]
		r.currBufIndex = r.currBufIndex[:0]
		r.buf.sortByTime = false
	}
}

func (r *IntegerColIntegerHeapIterator) processFirstWindow(
	inChunk, outChunk Chunk, sameInterval, hasMultiInterval bool, start, end int,
) {
	r.updatePrevItem(inChunk, start, end)
	if hasMultiInterval || !sameInterval {
		r.buf.sortByTime = true
		sort.Sort(r.buf)
		if r.buf.Len() > 0 {
			r.appendPrevItem(r.auxChunk, outChunk)
		}
		r.buf.Reset()
	}
}

func (r *IntegerColIntegerHeapIterator) processLastWindow(
	inChunk Chunk, start, end int,
) {
	r.updateCurrItem(inChunk, start, end)
}

func (r *IntegerColIntegerHeapIterator) processMiddleWindow(
	inChunk, outChunk Chunk, start, end int,
) {
	if len(r.auxProcessor) == 0 {
		r.buf.append(inChunk, start, end, r.inOrdinal)
	} else {
		r.prevMaxIndex = r.buf.maxIndex + 1
		r.windowIndex = r.buf.appendForAux(inChunk, start, end, r.inOrdinal)
	}
	r.buf.sortByTime = true
	sort.Sort(r.buf)
	if r.buf.Len() > 0 {
		r.appendCurrItem(inChunk, outChunk, start)
	}
	r.buf.Reset()
}

func (r *IntegerColIntegerHeapIterator) Next(ie *IteratorEndpoint, p *IteratorParams) {
	inChunk, outChunk := ie.InputPoint.Chunk, ie.OutputPoint.Chunk
	if inChunk.Column(r.inOrdinal).IsEmpty() {
		return
	}

	var end int
	firstIndex, lastIndex := 0, len(inChunk.IntervalIndex())-1
	for i, start := range inChunk.IntervalIndex() {
		if i < lastIndex {
			end = inChunk.IntervalIndex()[i+1]
		} else {
			end = inChunk.NumberOfRows()
		}
		if i == firstIndex && r.buf.Len() > 0 {
			r.processFirstWindow(inChunk, outChunk, p.sameInterval,
				firstIndex != lastIndex, start, end)
		} else if i == lastIndex && p.sameInterval {
			r.processLastWindow(inChunk, start, end)
		} else {
			r.processMiddleWindow(inChunk, outChunk, start, end)
		}
	}
}

type FloatDistinctItem struct {
	m     map[float64]struct{}
	time  []int64
	value []float64
}

func NewFloatDistinctItem() *FloatDistinctItem {
	return &FloatDistinctItem{
		m: make(map[float64]struct{}),
	}
}

func (f *FloatDistinctItem) appendItem(time []int64, value []float64) {
	for i := 0; i < len(time); i++ {
		if _, ok := f.m[value[i]]; !ok {
			f.m[value[i]] = struct{}{}
			f.time = append(f.time, time[i])
			f.value = append(f.value, value[i])
		}
	}
}

func (f *FloatDistinctItem) Nil() bool {
	return len(f.time) == 0
}

func (f *FloatDistinctItem) Reset() {
	for k := range f.m {
		delete(f.m, k)
	}
	f.time = f.time[:0]
	f.value = f.value[:0]
}

func (f *FloatDistinctItem) Len() int {
	return len(f.value)
}

func (f *FloatDistinctItem) Less(i, j int) bool {
	if f.time[i] != f.time[j] {
		return f.time[i] < f.time[j]
	}
	return f.value[i] < f.value[j]
}

func (f *FloatDistinctItem) Swap(i, j int) {
	f.time[i], f.time[j] = f.time[j], f.time[i]
	f.value[i], f.value[j] = f.value[j], f.value[i]
}

type IntegerDistinctItem struct {
	m     map[int64]struct{}
	time  []int64
	value []int64
}

func NewIntegerDistinctItem() *IntegerDistinctItem {
	return &IntegerDistinctItem{
		m: make(map[int64]struct{}),
	}
}

func (f *IntegerDistinctItem) appendItem(time []int64, value []int64) {
	for i := 0; i < len(time); i++ {
		if _, ok := f.m[value[i]]; !ok {
			f.m[value[i]] = struct{}{}
			f.time = append(f.time, time[i])
			f.value = append(f.value, value[i])
		}
	}
}

func (f *IntegerDistinctItem) Nil() bool {
	return len(f.time) == 0
}

func (f *IntegerDistinctItem) Reset() {
	for k := range f.m {
		delete(f.m, k)
	}
	f.time = f.time[:0]
	f.value = f.value[:0]
}

func (f *IntegerDistinctItem) Len() int {
	return len(f.value)
}

func (f *IntegerDistinctItem) Less(i, j int) bool {
	if f.time[i] != f.time[j] {
		return f.time[i] < f.time[j]
	}
	return f.value[i] < f.value[j]
}

func (f *IntegerDistinctItem) Swap(i, j int) {
	f.time[i], f.time[j] = f.time[j], f.time[i]
	f.value[i], f.value[j] = f.value[j], f.value[i]
}

type StringDistinctItem struct {
	m     map[string]struct{}
	time  []int64
	value []string
}

func NewStringDistinctItem() *StringDistinctItem {
	return &StringDistinctItem{
		m: make(map[string]struct{}),
	}
}

func (f *StringDistinctItem) appendItem(time []int64, value []string) {
	for i := 0; i < len(time); i++ {
		if _, ok := f.m[value[i]]; !ok {
			f.m[value[i]] = struct{}{}
			f.time = append(f.time, time[i])
			f.value = append(f.value, value[i])
		}
	}
}

func (f *StringDistinctItem) Nil() bool {
	return len(f.time) == 0
}

func (f *StringDistinctItem) Reset() {
	for k := range f.m {
		delete(f.m, k)
	}
	f.time = f.time[:0]
	f.value = f.value[:0]
}

func (f *StringDistinctItem) Len() int {
	return len(f.value)
}

func (f *StringDistinctItem) Less(i, j int) bool {
	if f.time[i] != f.time[j] {
		return f.time[i] < f.time[j]
	}
	return f.value[i] < f.value[j]
}

func (f *StringDistinctItem) Swap(i, j int) {
	f.time[i], f.time[j] = f.time[j], f.time[i]
	f.value[i], f.value[j] = f.value[j], f.value[i]
}

type BooleanDistinctItem struct {
	m     map[bool]struct{}
	time  []int64
	value []bool
}

func NewBooleanDistinctItem() *BooleanDistinctItem {
	return &BooleanDistinctItem{
		m: make(map[bool]struct{}),
	}
}

func (f *BooleanDistinctItem) appendItem(time []int64, value []bool) {
	for i := 0; i < len(time); i++ {
		if _, ok := f.m[value[i]]; !ok {
			f.m[value[i]] = struct{}{}
			f.time = append(f.time, time[i])
			f.value = append(f.value, value[i])
		}
	}
}

func (f *BooleanDistinctItem) Nil() bool {
	return len(f.time) == 0
}

func (f *BooleanDistinctItem) Reset() {
	for k := range f.m {
		delete(f.m, k)
	}
	f.time = f.time[:0]
	f.value = f.value[:0]
}

func (f *BooleanDistinctItem) Len() int {
	return len(f.value)
}

func (f *BooleanDistinctItem) Less(i, j int) bool {
	if f.time[i] != f.time[j] {
		return f.time[i] < f.time[j]
	}
	return !f.value[i]
}

func (f *BooleanDistinctItem) Swap(i, j int) {
	f.time[i], f.time[j] = f.time[j], f.time[i]
	f.value[i], f.value[j] = f.value[j], f.value[i]
}

type FloatColFloatDistinctIterator struct {
	buf        *FloatDistinctItem
	inOrdinal  int
	outOrdinal int
}

func NewFloatColFloatDistinctIterator(
	inOrdinal, outOrdinal int,
) *FloatColFloatDistinctIterator {
	return &FloatColFloatDistinctIterator{
		buf:        NewFloatDistinctItem(),
		inOrdinal:  inOrdinal,
		outOrdinal: outOrdinal,
	}
}

func (r *FloatColFloatDistinctIterator) processFirstWindow(
	inChunk, outChunk Chunk, sameInterval, hasMultiInterval bool, start, end int,
) {
	r.buf.appendItem(inChunk.Time()[start:end], inChunk.Column(r.inOrdinal).FloatValues()[start:end])
	if hasMultiInterval || !sameInterval {
		sort.Sort(r.buf)
		if r.buf.Len() > 0 {
			for j := range r.buf.time {
				outChunk.AppendTime(r.buf.time[j])
				outChunk.Column(r.outOrdinal).AppendFloatValues(r.buf.value[j])
				outChunk.Column(r.outOrdinal).AppendNilsV2(true)
			}
			outChunk.AppendIntervalIndex(outChunk.Len() - r.buf.Len())
		}
		r.buf.Reset()
	}
}

func (r *FloatColFloatDistinctIterator) processLastWindow(
	inChunk Chunk, start, end int,
) {
	r.buf.appendItem(inChunk.Time()[start:end], inChunk.Column(r.inOrdinal).FloatValues()[start:end])
}

func (r *FloatColFloatDistinctIterator) processMiddleWindow(
	inChunk, outChunk Chunk, start, end int,
) {
	r.buf.appendItem(inChunk.Time()[start:end], inChunk.Column(r.inOrdinal).FloatValues()[start:end])
	sort.Sort(r.buf)
	if r.buf.Len() > 0 {
		for j := range r.buf.time {
			outChunk.AppendTime(r.buf.time[j])
			outChunk.Column(r.outOrdinal).AppendFloatValues(r.buf.value[j])
			outChunk.Column(r.outOrdinal).AppendNilsV2(true)
		}
		outChunk.AppendIntervalIndex(outChunk.Len() - r.buf.Len())
	}
	r.buf.Reset()
}

func (r *FloatColFloatDistinctIterator) Next(ie *IteratorEndpoint, p *IteratorParams) {
	inChunk, outChunk := ie.InputPoint.Chunk, ie.OutputPoint.Chunk
	if inChunk.Column(r.inOrdinal).IsEmpty() {
		return
	}

	var end int
	firstIndex, lastIndex := 0, len(inChunk.IntervalIndex())-1
	for i, start := range inChunk.IntervalIndex() {
		if i < lastIndex {
			end = inChunk.IntervalIndex()[i+1]
		} else {
			end = inChunk.NumberOfRows()
		}

		if i == firstIndex && !r.buf.Nil() {
			r.processFirstWindow(inChunk, outChunk, p.sameInterval,
				firstIndex != lastIndex, start, end)
		} else if i == lastIndex && p.sameInterval {
			r.processLastWindow(inChunk, start, end)
		} else {
			r.processMiddleWindow(inChunk, outChunk, start, end)
		}
	}
}

type IntegerColIntegerDistinctIterator struct {
	buf        *IntegerDistinctItem
	inOrdinal  int
	outOrdinal int
}

func NewIntegerColIntegerDistinctIterator(
	inOrdinal, outOrdinal int,
) *IntegerColIntegerDistinctIterator {
	return &IntegerColIntegerDistinctIterator{
		buf:        NewIntegerDistinctItem(),
		inOrdinal:  inOrdinal,
		outOrdinal: outOrdinal,
	}
}

func (r *IntegerColIntegerDistinctIterator) processFirstWindow(
	inChunk, outChunk Chunk, sameInterval, hasMultiInterval bool, start, end int,
) {
	r.buf.appendItem(inChunk.Time()[start:end], inChunk.Column(r.inOrdinal).IntegerValues()[start:end])
	if hasMultiInterval || !sameInterval {
		sort.Sort(r.buf)
		if r.buf.Len() > 0 {
			for j := range r.buf.time {
				outChunk.AppendTime(r.buf.time[j])
				outChunk.Column(r.outOrdinal).AppendIntegerValues(r.buf.value[j])
				outChunk.Column(r.outOrdinal).AppendNilsV2(true)
			}
			outChunk.AppendIntervalIndex(outChunk.Len() - r.buf.Len())
		}
		r.buf.Reset()
	}
}

func (r *IntegerColIntegerDistinctIterator) processLastWindow(
	inChunk Chunk, start, end int,
) {
	r.buf.appendItem(inChunk.Time()[start:end], inChunk.Column(r.inOrdinal).IntegerValues()[start:end])
}

func (r *IntegerColIntegerDistinctIterator) processMiddleWindow(
	inChunk, outChunk Chunk, start, end int,
) {
	r.buf.appendItem(inChunk.Time()[start:end], inChunk.Column(r.inOrdinal).IntegerValues()[start:end])
	sort.Sort(r.buf)
	if r.buf.Len() > 0 {
		for j := range r.buf.time {
			outChunk.AppendTime(r.buf.time[j])
			outChunk.Column(r.outOrdinal).AppendIntegerValues(r.buf.value[j])
			outChunk.Column(r.outOrdinal).AppendNilsV2(true)
		}
		outChunk.AppendIntervalIndex(outChunk.Len() - r.buf.Len())
	}
	r.buf.Reset()
}

func (r *IntegerColIntegerDistinctIterator) Next(ie *IteratorEndpoint, p *IteratorParams) {
	inChunk, outChunk := ie.InputPoint.Chunk, ie.OutputPoint.Chunk
	if inChunk.Column(r.inOrdinal).IsEmpty() {
		return
	}

	var end int
	firstIndex, lastIndex := 0, len(inChunk.IntervalIndex())-1
	for i, start := range inChunk.IntervalIndex() {
		if i < lastIndex {
			end = inChunk.IntervalIndex()[i+1]
		} else {
			end = inChunk.NumberOfRows()
		}

		if i == firstIndex && !r.buf.Nil() {
			r.processFirstWindow(inChunk, outChunk, p.sameInterval,
				firstIndex != lastIndex, start, end)
		} else if i == lastIndex && p.sameInterval {
			r.processLastWindow(inChunk, start, end)
		} else {
			r.processMiddleWindow(inChunk, outChunk, start, end)
		}
	}
}

type StringColStringDistinctIterator struct {
	buf        *StringDistinctItem
	inOrdinal  int
	outOrdinal int
	stringBuff []string
}

func NewStringColStringDistinctIterator(
	inOrdinal, outOrdinal int,
) *StringColStringDistinctIterator {
	return &StringColStringDistinctIterator{
		buf:        NewStringDistinctItem(),
		inOrdinal:  inOrdinal,
		outOrdinal: outOrdinal,
	}
}

func (r *StringColStringDistinctIterator) processFirstWindow(
	inChunk, outChunk Chunk, sameInterval, hasMultiInterval bool, start, end int,
) {
	r.buf.appendItem(inChunk.Time()[start:end], inChunk.Column(r.inOrdinal).StringValuesRange(r.stringBuff[:0], start, end))
	if hasMultiInterval || !sameInterval {
		sort.Sort(r.buf)
		if r.buf.Len() > 0 {
			for j := range r.buf.time {
				outChunk.AppendTime(r.buf.time[j])
				outChunk.Column(r.outOrdinal).AppendStringValues(r.buf.value[j])
				outChunk.Column(r.outOrdinal).AppendNilsV2(true)
			}
			outChunk.AppendIntervalIndex(outChunk.Len() - r.buf.Len())
		}
		r.buf.Reset()
	}
}

func (r *StringColStringDistinctIterator) processLastWindow(
	inChunk Chunk, start, end int,
) {
	r.buf.appendItem(inChunk.Time()[start:end], inChunk.Column(r.inOrdinal).StringValuesRange(r.stringBuff[:0], start, end))
}

func (r *StringColStringDistinctIterator) processMiddleWindow(
	inChunk, outChunk Chunk, start, end int,
) {
	r.buf.appendItem(inChunk.Time()[start:end], inChunk.Column(r.inOrdinal).StringValuesRange(r.stringBuff[:0], start, end))
	sort.Sort(r.buf)
	if r.buf.Len() > 0 {
		for j := range r.buf.time {
			outChunk.AppendTime(r.buf.time[j])
			outChunk.Column(r.outOrdinal).AppendStringValues(r.buf.value[j])
			outChunk.Column(r.outOrdinal).AppendNilsV2(true)
		}
		outChunk.AppendIntervalIndex(outChunk.Len() - r.buf.Len())
	}
	r.buf.Reset()
}

func (r *StringColStringDistinctIterator) Next(ie *IteratorEndpoint, p *IteratorParams) {
	inChunk, outChunk := ie.InputPoint.Chunk, ie.OutputPoint.Chunk
	if inChunk.Column(r.inOrdinal).IsEmpty() {
		return
	}

	var end int
	firstIndex, lastIndex := 0, len(inChunk.IntervalIndex())-1
	for i, start := range inChunk.IntervalIndex() {
		if i < lastIndex {
			end = inChunk.IntervalIndex()[i+1]
		} else {
			end = inChunk.NumberOfRows()
		}

		if i == firstIndex && !r.buf.Nil() {
			r.processFirstWindow(inChunk, outChunk, p.sameInterval,
				firstIndex != lastIndex, start, end)
		} else if i == lastIndex && p.sameInterval {
			r.processLastWindow(inChunk, start, end)
		} else {
			r.processMiddleWindow(inChunk, outChunk, start, end)
		}
	}
}

type BooleanColBooleanDistinctIterator struct {
	buf        *BooleanDistinctItem
	inOrdinal  int
	outOrdinal int
}

func NewBooleanColBooleanDistinctIterator(
	inOrdinal, outOrdinal int,
) *BooleanColBooleanDistinctIterator {
	return &BooleanColBooleanDistinctIterator{
		buf:        NewBooleanDistinctItem(),
		inOrdinal:  inOrdinal,
		outOrdinal: outOrdinal,
	}
}

func (r *BooleanColBooleanDistinctIterator) processFirstWindow(
	inChunk, outChunk Chunk, sameInterval, hasMultiInterval bool, start, end int,
) {
	r.buf.appendItem(inChunk.Time()[start:end], inChunk.Column(r.inOrdinal).BooleanValues()[start:end])
	if hasMultiInterval || !sameInterval {
		sort.Sort(r.buf)
		if r.buf.Len() > 0 {
			for j := range r.buf.time {
				outChunk.AppendTime(r.buf.time[j])
				outChunk.Column(r.outOrdinal).AppendBooleanValues(r.buf.value[j])
				outChunk.Column(r.outOrdinal).AppendNilsV2(true)
			}
			outChunk.AppendIntervalIndex(outChunk.Len() - r.buf.Len())
		}
		r.buf.Reset()
	}
}

func (r *BooleanColBooleanDistinctIterator) processLastWindow(
	inChunk Chunk, start, end int,
) {
	r.buf.appendItem(inChunk.Time()[start:end], inChunk.Column(r.inOrdinal).BooleanValues()[start:end])
}

func (r *BooleanColBooleanDistinctIterator) processMiddleWindow(
	inChunk, outChunk Chunk, start, end int,
) {
	r.buf.appendItem(inChunk.Time()[start:end], inChunk.Column(r.inOrdinal).BooleanValues()[start:end])
	sort.Sort(r.buf)
	if r.buf.Len() > 0 {
		for j := range r.buf.time {
			outChunk.AppendTime(r.buf.time[j])
			outChunk.Column(r.outOrdinal).AppendBooleanValues(r.buf.value[j])
			outChunk.Column(r.outOrdinal).AppendNilsV2(true)
		}
		outChunk.AppendIntervalIndex(outChunk.Len() - r.buf.Len())
	}
	r.buf.Reset()
}

func (r *BooleanColBooleanDistinctIterator) Next(ie *IteratorEndpoint, p *IteratorParams) {
	inChunk, outChunk := ie.InputPoint.Chunk, ie.OutputPoint.Chunk
	if inChunk.Column(r.inOrdinal).IsEmpty() {
		return
	}

	var end int
	firstIndex, lastIndex := 0, len(inChunk.IntervalIndex())-1
	for i, start := range inChunk.IntervalIndex() {
		if i < lastIndex {
			end = inChunk.IntervalIndex()[i+1]
		} else {
			end = inChunk.NumberOfRows()
		}

		if i == firstIndex && !r.buf.Nil() {
			r.processFirstWindow(inChunk, outChunk, p.sameInterval,
				firstIndex != lastIndex, start, end)
		} else if i == lastIndex && p.sameInterval {
			r.processLastWindow(inChunk, start, end)
		} else {
			r.processMiddleWindow(inChunk, outChunk, start, end)
		}
	}
}

type TransItem interface {
	AppendItem(Chunk, int, int, int, bool)
	Reset()
	Len() int
	PrevNil() bool
	ResetPrev()
	GetBaseTransData() BaseTransData
}

type BaseTransData struct {
	time         []int64
	floatValue   []float64
	integerValue []int64
	nils         []bool
}

type floatDifference func(prev, curr float64) float64

type FloatDifferenceItem struct {
	isNonNegative bool
	diff          func(prev, curr float64) float64
	prev          *FloatPoint
	times         []int64
	values        []float64
	nils          []bool
}

func NewFloatDifferenceItem(isNonNegative bool, diff floatDifference) *FloatDifferenceItem {
	return &FloatDifferenceItem{isNonNegative: isNonNegative, diff: diff, prev: newFloatPoint()}
}

func (f *FloatDifferenceItem) diffComputeFast(prevValue, currValue float64, currTime int64) {
	if dv := f.diff(prevValue, currValue); !f.isNonNegative || (f.isNonNegative && dv >= 0) {
		f.times = append(f.times, currTime)
		f.values = append(f.values, dv)
		f.nils = append(f.nils, false)
	} else {
		f.times = append(f.times, currTime)
		f.values = append(f.values, 0)
		f.nils = append(f.nils, true)
	}
}

func (f *FloatDifferenceItem) AppendItemFastFunc(c Chunk, ordinal int, start, end int, sameInterval bool) {
	// fast path
	var st int64
	var si int
	col := c.Column(ordinal)
	times := c.Time()[start:end]
	values := col.FloatValues()[start:end]

	// calculate diff for middle points
	for i := 0; i < len(times); i++ {
		if i == 0 {
			if f.prev.isNil {
				st, si = times[0], 0
			} else if f.prev.time != times[0] {
				f.diffComputeFast(f.prev.value, values[0], times[0])
				st, si = times[0], 0
			} else if f.prev.time == times[0] {
				st, si = f.prev.time, -1
			}
			continue
		}

		if st == times[i] {
			continue
		}

		if si == -1 {
			f.diffComputeFast(f.prev.value, values[i], times[i])
		} else {
			f.diffComputeFast(values[si], values[i], times[i])
		}
		st, si = times[i], i
	}

	// process the last point
	if sameInterval {
		if si >= 0 {
			f.prev.Set(end, times[si], values[si])
		}
	} else {
		f.prev.Reset()
	}
}

func (f *FloatDifferenceItem) doNullWindow(times []int64, sameInterval bool) {
	var st int64
	for i, t := range times {
		if i == 0 {
			if !f.prev.isNil {
				f.times = append(f.times, times[0])
				f.values = append(f.values, 0)
				f.nils = append(f.nils, true)
			}
			st = t
			continue
		}
		if st == t {
			continue
		}
		f.times = append(f.times, times[i])
		f.values = append(f.values, 0)
		f.nils = append(f.nils, true)
		st = t
	}

	if !sameInterval {
		f.prev.Reset()
	}
}

func (f *FloatDifferenceItem) diffComputeSlow(prevValue, currValue float64, currTime int64) {
	if dv := f.diff(prevValue, currValue); !f.isNonNegative || (f.isNonNegative && dv >= 0) {
		f.times = append(f.times, currTime)
		f.values = append(f.values, dv)
		f.nils = append(f.nils, false)
	} else if f.isNonNegative && dv < 0 {
		f.times = append(f.times, currTime)
		f.values = append(f.values, 0)
		f.nils = append(f.nils, true)
	}
}

func (f *FloatDifferenceItem) AppendItemSlowFunc(c Chunk, ordinal int, start, end int, sameInterval bool) {
	// slow path
	col := c.Column(ordinal)
	times := c.Time()[start:end]
	vs, ve := col.GetRangeValueIndexV2(start, end)
	if vs == ve {
		f.doNullWindow(times, sameInterval)
		return
	}

	// calculate diff for middle points
	var vos int
	for i := start; i < end; i++ {
		isNil := col.IsNilV2(i)
		t := c.TimeByIndex(i)
		if isNil && (f.prev.isNil || (i < end-1 && t == c.TimeByIndex(i+1))) {
			continue
		}
		if i > 0 && !f.prev.isNil && f.prev.time == t {
			if !isNil {
				vos++
			}
			continue
		}
		if isNil {
			f.times = append(f.times, t)
			f.values = append(f.values, 0)
			f.nils = append(f.nils, true)
			continue
		}
		v := col.FloatValue(vs + vos)
		vos++
		if f.prev.isNil {
			f.prev.Set(i, t, v)
			continue
		}
		f.diffComputeSlow(f.prev.value, v, t)
		f.prev.Set(i, t, v)
	}

	// process the last point
	if !sameInterval {
		f.prev.Reset()
	}
}

func (f *FloatDifferenceItem) AppendItem(c Chunk, ordinal int, start, end int, sameInterval bool) {
	if c.Column(ordinal).NilCount() == 0 {
		f.AppendItemFastFunc(c, ordinal, start, end, sameInterval)
		return
	}
	f.AppendItemSlowFunc(c, ordinal, start, end, sameInterval)
}

func (f *FloatDifferenceItem) Reset() {
	f.times = f.times[:0]
	f.values = f.values[:0]
	f.nils = f.nils[:0]
}

func (f *FloatDifferenceItem) Len() int {
	return len(f.times)
}

func (f *FloatDifferenceItem) PrevNil() bool {
	return f.prev.isNil
}

func (f *FloatDifferenceItem) ResetPrev() {
	f.prev.Reset()
}

func (f *FloatDifferenceItem) GetBaseTransData() BaseTransData {
	return BaseTransData{time: f.times, floatValue: f.values, nils: f.nils}
}

type integerDifference func(prev, curr int64) int64

type IntegerDifferenceItem struct {
	isNonNegative bool
	diff          func(prev, curr int64) int64
	prev          *IntegerPoint
	times         []int64
	values        []int64
	nils          []bool
}

func NewIntegerDifferenceItem(isNonNegative bool, diff integerDifference) *IntegerDifferenceItem {
	return &IntegerDifferenceItem{isNonNegative: isNonNegative, diff: diff, prev: newIntegerPoint()}
}

func (f *IntegerDifferenceItem) diffComputeFast(prevValue, currValue int64, currTime int64) {
	if dv := f.diff(prevValue, currValue); !f.isNonNegative || (f.isNonNegative && dv >= 0) {
		f.times = append(f.times, currTime)
		f.values = append(f.values, dv)
		f.nils = append(f.nils, false)
	} else {
		f.times = append(f.times, currTime)
		f.values = append(f.values, 0)
		f.nils = append(f.nils, true)
	}
}

func (f *IntegerDifferenceItem) AppendItemFastFunc(c Chunk, ordinal int, start, end int, sameInterval bool) {
	// fast path
	var st int64
	var si int
	col := c.Column(ordinal)
	times := c.Time()[start:end]
	values := col.IntegerValues()[start:end]

	// calculate diff for middle points
	for i := 0; i < len(times); i++ {
		if i == 0 {
			if f.prev.isNil {
				st, si = times[0], 0
			} else if f.prev.time != times[0] {
				f.diffComputeFast(f.prev.value, values[0], times[0])
				st, si = times[0], 0
			} else if f.prev.time == times[0] {
				st, si = f.prev.time, -1
			}
			continue
		}

		if st == times[i] {
			continue
		}

		if si == -1 {
			f.diffComputeFast(f.prev.value, values[i], times[i])
		} else {
			f.diffComputeFast(values[si], values[i], times[i])
		}
		st, si = times[i], i
	}

	// process the last point
	if sameInterval {
		if si >= 0 {
			f.prev.Set(end, times[si], values[si])
		}
	} else {
		f.prev.Reset()
	}
}

func (f *IntegerDifferenceItem) doNullWindow(times []int64, sameInterval bool) {
	var st int64
	for i, t := range times {
		if i == 0 {
			if !f.prev.isNil {
				f.times = append(f.times, times[0])
				f.values = append(f.values, 0)
				f.nils = append(f.nils, true)
			}
			st = t
			continue
		}
		if st == t {
			continue
		}
		f.times = append(f.times, times[i])
		f.values = append(f.values, 0)
		f.nils = append(f.nils, true)
		st = t
	}

	if !sameInterval {
		f.prev.Reset()
	}
}

func (f *IntegerDifferenceItem) diffComputeSlow(prevValue, currValue int64, currTime int64) {
	if dv := f.diff(prevValue, currValue); !f.isNonNegative || (f.isNonNegative && dv >= 0) {
		f.times = append(f.times, currTime)
		f.values = append(f.values, dv)
		f.nils = append(f.nils, false)
	} else if f.isNonNegative && dv < 0 {
		f.times = append(f.times, currTime)
		f.values = append(f.values, 0)
		f.nils = append(f.nils, true)
	}
}

func (f *IntegerDifferenceItem) AppendItemSlowFunc(c Chunk, ordinal int, start, end int, sameInterval bool) {
	// slow path
	col := c.Column(ordinal)
	times := c.Time()[start:end]
	vs, ve := col.GetRangeValueIndexV2(start, end)
	if vs == ve {
		f.doNullWindow(times, sameInterval)
		return
	}

	// calculate diff for middle points
	var vos int
	for i := start; i < end; i++ {
		isNil := col.IsNilV2(i)
		t := c.TimeByIndex(i)
		if isNil && (f.prev.isNil || (i < end-1 && t == c.TimeByIndex(i+1))) {
			continue
		}
		if i > 0 && !f.prev.isNil && f.prev.time == t {
			if !isNil {
				vos++
			}
			continue
		}
		if isNil {
			f.times = append(f.times, t)
			f.values = append(f.values, 0)
			f.nils = append(f.nils, true)
			continue
		}
		v := col.IntegerValue(vs + vos)
		vos++
		if f.prev.isNil {
			f.prev.Set(i, t, v)
			continue
		}
		f.diffComputeSlow(f.prev.value, v, t)
		f.prev.Set(i, t, v)
	}

	// process the last point
	if !sameInterval {
		f.prev.Reset()
	}
}

func (f *IntegerDifferenceItem) AppendItem(c Chunk, ordinal int, start, end int, sameInterval bool) {
	if c.Column(ordinal).NilCount() == 0 {
		f.AppendItemFastFunc(c, ordinal, start, end, sameInterval)
		return
	}
	f.AppendItemSlowFunc(c, ordinal, start, end, sameInterval)
}

func (f *IntegerDifferenceItem) Reset() {
	f.times = f.times[:0]
	f.values = f.values[:0]
	f.nils = f.nils[:0]
}

func (f *IntegerDifferenceItem) Len() int {
	return len(f.times)
}

func (f *IntegerDifferenceItem) PrevNil() bool {
	return f.prev.isNil
}

func (f *IntegerDifferenceItem) ResetPrev() {
	f.prev.Reset()
}

func (f *IntegerDifferenceItem) GetBaseTransData() BaseTransData {
	return BaseTransData{time: f.times, integerValue: f.values, nils: f.nils}
}

type FloatDerivativeItem struct {
	isNonNegative bool
	ascending     bool
	prev          *FloatPoint
	times         []int64
	values        []float64
	nils          []bool
	interval      hybridqp.Interval
}

func NewFloatDerivativeItem(isNonNegative, ascending bool, interval hybridqp.Interval) *FloatDerivativeItem {
	return &FloatDerivativeItem{
		isNonNegative: isNonNegative, ascending: ascending, interval: interval, prev: newFloatPoint(),
	}
}

func (f *FloatDerivativeItem) derivativeComputeFast(prevValue, currValue float64, prevTime, currTime int64) {
	if diff, elapsed := float64(currValue-prevValue), currTime-prevTime; !f.isNonNegative || (f.isNonNegative && diff >= 0) {
		if !f.ascending {
			elapsed = -elapsed
		}
		v := diff / (float64(elapsed) / float64(f.interval.Duration))
		f.times = append(f.times, currTime)
		f.values = append(f.values, v)
		f.nils = append(f.nils, false)
	} else {
		f.times = append(f.times, currTime)
		f.values = append(f.values, 0)
		f.nils = append(f.nils, true)
	}
}

func (f *FloatDerivativeItem) AppendItemFastFunc(c Chunk, ordinal int, start, end int, sameInterval bool) {
	// fast path
	var st int64
	var si int
	col := c.Column(ordinal)
	times := c.Time()[start:end]
	values := col.FloatValues()[start:end]

	// calculate diff for middle points
	for i := 0; i < len(times); i++ {
		if i == 0 {
			if f.prev.isNil {
				st, si = times[0], 0
			} else if f.prev.time != times[0] {
				f.derivativeComputeFast(f.prev.value, values[0], f.prev.time, times[0])
				st, si = times[0], 0
			} else if f.prev.time == times[0] {
				st, si = f.prev.time, -1
			}
			continue
		}

		if st == times[i] {
			continue
		}
		if si == -1 {
			f.derivativeComputeFast(f.prev.value, values[i], f.prev.time, times[i])
		} else {
			f.derivativeComputeFast(values[si], values[i], times[si], times[i])
		}
		st, si = times[i], i
	}

	// process the last point
	if sameInterval {
		if si >= 0 {
			f.prev.Set(end, times[si], values[si])
		}
	} else {
		f.prev.Reset()
	}
}

func (f *FloatDerivativeItem) doNullWindow(times []int64, sameInterval bool) {
	var st int64
	for i, t := range times {
		if i == 0 {
			if !f.prev.isNil {
				f.times = append(f.times, times[0])
				f.values = append(f.values, 0)
				f.nils = append(f.nils, true)
			}
			st = t
			continue
		}
		if st == t {
			continue
		}
		f.times = append(f.times, times[i])
		f.values = append(f.values, 0)
		f.nils = append(f.nils, true)
		st = t
	}

	if !sameInterval {
		f.prev.Reset()
	}
}

func (f *FloatDerivativeItem) derivativeComputeSlow(prevValue, currValue float64, prevTime, currTime int64) {
	if diff, elapsed := float64(currValue-prevValue), currTime-prevTime; !f.isNonNegative || (f.isNonNegative && diff >= 0) {
		if !f.ascending {
			elapsed = -elapsed
		}
		v := diff / (float64(elapsed) / float64(f.interval.Duration))
		f.times = append(f.times, currTime)
		f.values = append(f.values, v)
		f.nils = append(f.nils, false)
	} else if f.isNonNegative && diff < 0 {
		f.times = append(f.times, currTime)
		f.values = append(f.values, 0)
		f.nils = append(f.nils, true)
	}
}

func (f *FloatDerivativeItem) AppendItemSlowFunc(c Chunk, ordinal int, start, end int, sameInterval bool) {
	// slow path
	col := c.Column(ordinal)
	times := c.Time()[start:end]
	vs, ve := col.GetRangeValueIndexV2(start, end)
	if vs == ve {
		f.doNullWindow(times, sameInterval)
		return
	}

	// calculate diff for middle points
	var vos int
	for i := start; i < end; i++ {
		isNil := col.IsNilV2(i)
		t := c.TimeByIndex(i)
		if isNil && (f.prev.isNil || (i < end-1 && t == c.TimeByIndex(i+1))) {
			continue
		}
		if i > 0 && !f.prev.isNil && f.prev.time == t {
			if !isNil {
				vos++
			}
			continue
		}
		if isNil {
			f.times = append(f.times, t)
			f.values = append(f.values, 0)
			f.nils = append(f.nils, true)
			continue
		}
		v := col.FloatValue(vs + vos)
		vos++
		if f.prev.isNil {
			f.prev.Set(i, t, v)
			continue
		}
		f.derivativeComputeSlow(f.prev.value, v, f.prev.time, t)
		f.prev.Set(i, t, v)
	}

	// process the last point
	if !sameInterval {
		f.prev.Reset()
	}
}

func (f *FloatDerivativeItem) AppendItem(c Chunk, ordinal int, start, end int, sameInterval bool) {
	if c.Column(ordinal).NilCount() == 0 {
		f.AppendItemFastFunc(c, ordinal, start, end, sameInterval)
		return
	}
	f.AppendItemSlowFunc(c, ordinal, start, end, sameInterval)
}

func (f *FloatDerivativeItem) Reset() {
	f.times = f.times[:0]
	f.values = f.values[:0]
	f.nils = f.nils[:0]
}

func (f *FloatDerivativeItem) Len() int {
	return len(f.times)
}

func (f *FloatDerivativeItem) PrevNil() bool {
	return f.prev.isNil
}

func (f *FloatDerivativeItem) ResetPrev() {
	f.prev.Reset()
}

func (f *FloatDerivativeItem) GetBaseTransData() BaseTransData {
	return BaseTransData{time: f.times, floatValue: f.values, nils: f.nils}
}

type IntegerDerivativeItem struct {
	isNonNegative bool
	ascending     bool
	prev          *IntegerPoint
	times         []int64
	values        []float64
	nils          []bool
	interval      hybridqp.Interval
}

func NewIntegerDerivativeItem(isNonNegative, ascending bool, interval hybridqp.Interval) *IntegerDerivativeItem {
	return &IntegerDerivativeItem{
		isNonNegative: isNonNegative, ascending: ascending, interval: interval, prev: newIntegerPoint(),
	}
}

func (f *IntegerDerivativeItem) derivativeComputeFast(prevValue, currValue int64, prevTime, currTime int64) {
	if diff, elapsed := float64(currValue-prevValue), currTime-prevTime; !f.isNonNegative || (f.isNonNegative && diff >= 0) {
		if !f.ascending {
			elapsed = -elapsed
		}
		v := diff / (float64(elapsed) / float64(f.interval.Duration))
		f.times = append(f.times, currTime)
		f.values = append(f.values, v)
		f.nils = append(f.nils, false)
	} else {
		f.times = append(f.times, currTime)
		f.values = append(f.values, 0)
		f.nils = append(f.nils, true)
	}
}

func (f *IntegerDerivativeItem) AppendItemFastFunc(c Chunk, ordinal int, start, end int, sameInterval bool) {
	// fast path
	var st int64
	var si int
	col := c.Column(ordinal)
	times := c.Time()[start:end]
	values := col.IntegerValues()[start:end]

	// calculate diff for middle points
	for i := 0; i < len(times); i++ {
		if i == 0 {
			if f.prev.isNil {
				st, si = times[0], 0
			} else if f.prev.time != times[0] {
				f.derivativeComputeFast(f.prev.value, values[0], f.prev.time, times[0])
				st, si = times[0], 0
			} else if f.prev.time == times[0] {
				st, si = f.prev.time, -1
			}
			continue
		}

		if st == times[i] {
			continue
		}
		if si == -1 {
			f.derivativeComputeFast(f.prev.value, values[i], f.prev.time, times[i])
		} else {
			f.derivativeComputeFast(values[si], values[i], times[si], times[i])
		}
		st, si = times[i], i
	}

	// process the last point
	if sameInterval {
		if si >= 0 {
			f.prev.Set(end, times[si], values[si])
		}
	} else {
		f.prev.Reset()
	}
}

func (f *IntegerDerivativeItem) doNullWindow(times []int64, sameInterval bool) {
	var st int64
	for i, t := range times {
		if i == 0 {
			if !f.prev.isNil {
				f.times = append(f.times, times[0])
				f.values = append(f.values, 0)
				f.nils = append(f.nils, true)
			}
			st = t
			continue
		}
		if st == t {
			continue
		}
		f.times = append(f.times, times[i])
		f.values = append(f.values, 0)
		f.nils = append(f.nils, true)
		st = t
	}

	if !sameInterval {
		f.prev.Reset()
	}
}

func (f *IntegerDerivativeItem) derivativeComputeSlow(prevValue, currValue int64, prevTime, currTime int64) {
	if diff, elapsed := float64(currValue-prevValue), currTime-prevTime; !f.isNonNegative || (f.isNonNegative && diff >= 0) {
		if !f.ascending {
			elapsed = -elapsed
		}
		v := diff / (float64(elapsed) / float64(f.interval.Duration))
		f.times = append(f.times, currTime)
		f.values = append(f.values, v)
		f.nils = append(f.nils, false)
	} else if f.isNonNegative && diff < 0 {
		f.times = append(f.times, currTime)
		f.values = append(f.values, 0)
		f.nils = append(f.nils, true)
	}
}

func (f *IntegerDerivativeItem) AppendItemSlowFunc(c Chunk, ordinal int, start, end int, sameInterval bool) {
	// slow path
	col := c.Column(ordinal)
	times := c.Time()[start:end]
	vs, ve := col.GetRangeValueIndexV2(start, end)
	if vs == ve {
		f.doNullWindow(times, sameInterval)
		return
	}

	// calculate diff for middle points
	var vos int
	for i := start; i < end; i++ {
		isNil := col.IsNilV2(i)
		t := c.TimeByIndex(i)
		if isNil && (f.prev.isNil || (i < end-1 && t == c.TimeByIndex(i+1))) {
			continue
		}
		if i > 0 && !f.prev.isNil && f.prev.time == t {
			if !isNil {
				vos++
			}
			continue
		}
		if isNil {
			f.times = append(f.times, t)
			f.values = append(f.values, 0)
			f.nils = append(f.nils, true)
			continue
		}
		v := col.IntegerValue(vs + vos)
		vos++
		if f.prev.isNil {
			f.prev.Set(i, t, v)
			continue
		}
		f.derivativeComputeSlow(f.prev.value, v, f.prev.time, t)
		f.prev.Set(i, t, v)
	}

	// process the last point
	if !sameInterval {
		f.prev.Reset()
	}
}

func (f *IntegerDerivativeItem) AppendItem(c Chunk, ordinal int, start, end int, sameInterval bool) {
	if c.Column(ordinal).NilCount() == 0 {
		f.AppendItemFastFunc(c, ordinal, start, end, sameInterval)
		return
	}
	f.AppendItemSlowFunc(c, ordinal, start, end, sameInterval)
}

func (f *IntegerDerivativeItem) Reset() {
	f.times = f.times[:0]
	f.values = f.values[:0]
	f.nils = f.nils[:0]
}

func (f *IntegerDerivativeItem) Len() int {
	return len(f.times)
}

func (f *IntegerDerivativeItem) PrevNil() bool {
	return f.prev.isNil
}

func (f *IntegerDerivativeItem) ResetPrev() {
	f.prev.Reset()
}

func (f *IntegerDerivativeItem) GetBaseTransData() BaseTransData {
	return BaseTransData{time: f.times, floatValue: f.values, nils: f.nils}
}

func linearFloat(windowTime, previousTime, nextTime int64, previousValue, nextValue float64) float64 {
	m := (nextValue - previousValue) / float64(nextTime-previousTime) // the slope of the line
	x := float64(windowTime - previousTime)                           // how far into the interval we are
	b := previousValue
	return m*x + b
}

type FloatIntegralItem struct {
	sameTag      bool
	sameInterval bool
	pointNum     int
	sum          float64
	window       struct {
		start int64
		end   int64
	}
	prev     *FloatPoint
	time     []int64
	value    []float64
	interval hybridqp.Interval
	opt      query.ProcessorOptions
}

func NewFloatIntegralItem(interval hybridqp.Interval, opt query.ProcessorOptions) *FloatIntegralItem {
	return &FloatIntegralItem{interval: interval, prev: newFloatPoint(), opt: opt, sameTag: false}
}

func (f *FloatIntegralItem) CalculateUnit(index int, time int64, value float64) {
	if f.prev.time == time {
		f.prev.Set(index, time, value)
	} else {
		f.sum += 0.5 * (value + f.prev.value) * float64(time-f.prev.time) / float64(f.interval.Duration)
		f.prev.Set(index, time, value)
	}
}

func (f *FloatIntegralItem) StartNewInterval(time int64) {
	f.value = append(f.value, f.sum)
	if f.opt.Interval.IsZero() {
		f.time = append(f.time, 0)
	} else {
		f.time = append(f.time, f.window.start)
		if f.opt.Ascending {
			f.window.start, f.window.end = f.opt.Window(time)
		} else {
			f.window.end, f.window.start = f.opt.Window(time)
		}
	}
	f.sum = 0.0
}

func (f *FloatIntegralItem) doNullWindow(sameInterval, sameTag bool) {
	if !f.sameTag {
		if f.pointNum > 1 {
			f.value = append(f.value, f.sum)
			if f.opt.Interval.IsZero() {
				f.time = append(f.time, 0)
			} else {
				f.time = append(f.time, f.window.start)
			}
		}
		f.sum = 0.0
		f.pointNum = 0
	} else {
		f.sameInterval = sameInterval
		f.sameTag = sameTag
	}
}

func (f *FloatIntegralItem) AppendItemFastFunc(c Chunk, ordinal int, start, end int, sameInterval bool, sameTag bool) {
	// fast path
	col := c.Column(ordinal)
	time := c.Time()[start:end]
	value := col.FloatValues()[start:end]

	// process the first point
	if f.prev.isNil {
		f.prev.Set(0, time[0], float64(value[0]))
		if !f.opt.Interval.IsZero() {
			if f.opt.Ascending {
				f.window.start, f.window.end = f.opt.Window(time[0])
			} else {
				f.window.end, f.window.start = f.opt.Window(time[0])
			}
		}
	} else {
		// process the last point of front window and the first point of this window
		if !f.sameTag { // not sametag
			if !(f.pointNum == 1 && f.prev.time == f.window.start) && !(f.pointNum == 0) {
				f.StartNewInterval(time[0])
			} else {
				if !f.opt.Interval.IsZero() {
					if f.opt.Ascending {
						f.window.start, f.window.end = f.opt.Window(time[0])
					} else {
						f.window.end, f.window.start = f.opt.Window(time[0])
					}
				}
				f.sum = 0.0
			}
			f.prev.Set(0, time[0], float64(value[0]))
		} else if !f.sameInterval { // sametag not sameinterval
			if f.prev.time != f.window.end && !f.opt.Interval.IsZero() {
				value := linearFloat(f.window.end, f.prev.time, time[0], f.prev.value, float64(value[0]))
				f.sum += 0.5 * (value + f.prev.value) * float64(f.window.end-f.prev.time) / float64(f.interval.Duration)

				f.prev.value = value
				f.prev.time = f.window.end
			}
			f.StartNewInterval(time[0])
			f.CalculateUnit(0, time[0], float64(value[0]))
		} else { // sametag sameinterval
			f.CalculateUnit(0, time[0], float64(value[0]))
		}
	}
	// process the rest ponints
	for i := 1; i < len(time); i++ {
		f.CalculateUnit(i, time[i], float64(value[i]))
	}
	f.pointNum = end - start
	f.sameTag = sameTag
	f.sameInterval = sameInterval
}

func (f *FloatIntegralItem) AppendItemSlowFunc(c Chunk, ordinal int, vs, ve int, sameInterval, sameTag bool) {
	// slow path
	col := c.Column(ordinal)
	getTimeIndex := col.GetTimeIndex
	if vs == ve {
		f.doNullWindow(sameInterval, sameTag)
		return
	}

	// process the first point
	if f.prev.isNil {
		f.prev.Set(0, c.TimeByIndex(getTimeIndex(vs)), float64(col.FloatValues()[vs]))
		if !f.opt.Interval.IsZero() {
			if f.opt.Ascending {
				f.window.start, f.window.end = f.opt.Window(c.TimeByIndex(getTimeIndex(vs)))
			} else {
				f.window.end, f.window.start = f.opt.Window(c.TimeByIndex(getTimeIndex(vs)))
			}
		}
	} else {
		// process the last point of front window and the first point of this window
		if !f.sameTag {
			if !(f.pointNum == 1 && f.prev.time == f.window.start) && !(f.pointNum == 0) {
				f.StartNewInterval(c.TimeByIndex(getTimeIndex(vs)))
			} else {
				if !f.opt.Interval.IsZero() {
					if f.opt.Ascending {
						f.window.start, f.window.end = f.opt.Window(c.TimeByIndex(getTimeIndex(vs)))
					} else {
						f.window.end, f.window.start = f.opt.Window(c.TimeByIndex(getTimeIndex(vs)))
					}
				}
				f.sum = 0.0
			}
			f.prev.Set(0, c.TimeByIndex(getTimeIndex(vs)), float64(col.FloatValues()[vs]))
		} else if !f.sameInterval {
			if f.prev.time != f.window.end && !f.opt.Interval.IsZero() {
				value := linearFloat(f.window.end, f.prev.time, c.TimeByIndex(getTimeIndex(vs)), f.prev.value, float64(col.FloatValues()[vs]))
				f.sum += 0.5 * (value + f.prev.value) * float64(f.window.end-f.prev.time) / float64(f.interval.Duration)

				f.prev.value = value
				f.prev.time = f.window.end
			}
			f.StartNewInterval(c.TimeByIndex(getTimeIndex(vs)))
			f.CalculateUnit(0, c.TimeByIndex(getTimeIndex(vs)), float64(col.FloatValues()[vs]))
		} else {
			f.CalculateUnit(0, c.TimeByIndex(getTimeIndex(vs)), float64(col.FloatValues()[vs]))
		}
	}
	// process the rest ponints
	for i := vs + 1; i < ve; i++ {
		f.CalculateUnit(i-vs, c.TimeByIndex(getTimeIndex(i)), float64(col.FloatValues()[i]))
	}
	f.pointNum = ve - vs
	f.sameTag = sameTag
	f.sameInterval = sameInterval
}

func (f *FloatIntegralItem) AppendItem(c Chunk, ordinal int, start, end int, sameInterval, sameTag bool) {
	if c.Column(ordinal).NilCount() == 0 {
		f.AppendItemFastFunc(c, ordinal, start, end, sameInterval, sameTag)
		return
	}
	f.AppendItemSlowFunc(c, ordinal, start, end, sameInterval, sameTag)
}

func (f *FloatIntegralItem) Reset() {
	f.time = f.time[:0]
	f.value = f.value[:0]
}

func (f *FloatIntegralItem) Len() int {
	return len(f.time)
}

func (f *FloatIntegralItem) Nil() bool {
	return f.prev.isNil
}

type IntegerIntegralItem struct {
	sameTag      bool
	sameInterval bool
	pointNum     int
	sum          float64
	window       struct {
		start int64
		end   int64
	}
	prev     *FloatPoint
	time     []int64
	value    []float64
	interval hybridqp.Interval
	opt      query.ProcessorOptions
}

func NewIntegerIntegralItem(interval hybridqp.Interval, opt query.ProcessorOptions) *IntegerIntegralItem {
	return &IntegerIntegralItem{interval: interval, prev: newFloatPoint(), opt: opt, sameTag: false}
}

func (f *IntegerIntegralItem) CalculateUnit(index int, time int64, value float64) {
	if f.prev.time == time {
		f.prev.Set(index, time, value)
	} else {
		f.sum += 0.5 * (value + f.prev.value) * float64(time-f.prev.time) / float64(f.interval.Duration)
		f.prev.Set(index, time, value)
	}
}

func (f *IntegerIntegralItem) StartNewInterval(time int64) {
	f.value = append(f.value, f.sum)
	if f.opt.Interval.IsZero() {
		f.time = append(f.time, 0)
	} else {
		f.time = append(f.time, f.window.start)
		if f.opt.Ascending {
			f.window.start, f.window.end = f.opt.Window(time)
		} else {
			f.window.end, f.window.start = f.opt.Window(time)
		}
	}
	f.sum = 0.0
}

func (f *IntegerIntegralItem) doNullWindow(sameInterval, sameTag bool) {
	if !f.sameTag {
		if f.pointNum > 1 {
			f.value = append(f.value, f.sum)
			if f.opt.Interval.IsZero() {
				f.time = append(f.time, 0)
			} else {
				f.time = append(f.time, f.window.start)
			}
		}
		f.sum = 0.0
		f.pointNum = 0
	} else {
		f.sameInterval = sameInterval
		f.sameTag = sameTag
	}
}

func (f *IntegerIntegralItem) AppendItemFastFunc(c Chunk, ordinal int, start, end int, sameInterval bool, sameTag bool) {
	// fast path
	col := c.Column(ordinal)
	time := c.Time()[start:end]
	value := col.IntegerValues()[start:end]

	// process the first point
	if f.prev.isNil {
		f.prev.Set(0, time[0], float64(value[0]))
		if !f.opt.Interval.IsZero() {
			if f.opt.Ascending {
				f.window.start, f.window.end = f.opt.Window(time[0])
			} else {
				f.window.end, f.window.start = f.opt.Window(time[0])
			}
		}
	} else {
		// process the last point of front window and the first point of this window
		if !f.sameTag { // not sametag
			if !(f.pointNum == 1 && f.prev.time == f.window.start) && !(f.pointNum == 0) {
				f.StartNewInterval(time[0])
			} else {
				if !f.opt.Interval.IsZero() {
					if f.opt.Ascending {
						f.window.start, f.window.end = f.opt.Window(time[0])
					} else {
						f.window.end, f.window.start = f.opt.Window(time[0])
					}
				}
				f.sum = 0.0
			}
			f.prev.Set(0, time[0], float64(value[0]))
		} else if !f.sameInterval { // sametag not sameinterval
			if f.prev.time != f.window.end && !f.opt.Interval.IsZero() {
				value := linearFloat(f.window.end, f.prev.time, time[0], f.prev.value, float64(value[0]))
				f.sum += 0.5 * (value + f.prev.value) * float64(f.window.end-f.prev.time) / float64(f.interval.Duration)

				f.prev.value = value
				f.prev.time = f.window.end
			}
			f.StartNewInterval(time[0])
			f.CalculateUnit(0, time[0], float64(value[0]))
		} else { // sametag sameinterval
			f.CalculateUnit(0, time[0], float64(value[0]))
		}
	}
	// process the rest ponints
	for i := 1; i < len(time); i++ {
		f.CalculateUnit(i, time[i], float64(value[i]))
	}
	f.pointNum = end - start
	f.sameTag = sameTag
	f.sameInterval = sameInterval
}

func (f *IntegerIntegralItem) AppendItemSlowFunc(c Chunk, ordinal int, vs, ve int, sameInterval, sameTag bool) {
	// slow path
	col := c.Column(ordinal)
	getTimeIndex := col.GetTimeIndex
	if vs == ve {
		f.doNullWindow(sameInterval, sameTag)
		return
	}

	// process the first point
	if f.prev.isNil {
		f.prev.Set(0, c.TimeByIndex(getTimeIndex(vs)), float64(col.IntegerValues()[vs]))
		if !f.opt.Interval.IsZero() {
			if f.opt.Ascending {
				f.window.start, f.window.end = f.opt.Window(c.TimeByIndex(getTimeIndex(vs)))
			} else {
				f.window.end, f.window.start = f.opt.Window(c.TimeByIndex(getTimeIndex(vs)))
			}
		}
	} else {
		// process the last point of front window and the first point of this window
		if !f.sameTag {
			if !(f.pointNum == 1 && f.prev.time == f.window.start) && !(f.pointNum == 0) {
				f.StartNewInterval(c.TimeByIndex(getTimeIndex(vs)))
			} else {
				if !f.opt.Interval.IsZero() {
					if f.opt.Ascending {
						f.window.start, f.window.end = f.opt.Window(c.TimeByIndex(getTimeIndex(vs)))
					} else {
						f.window.end, f.window.start = f.opt.Window(c.TimeByIndex(getTimeIndex(vs)))
					}
				}
				f.sum = 0.0
			}
			f.prev.Set(0, c.TimeByIndex(getTimeIndex(vs)), float64(col.IntegerValues()[vs]))
		} else if !f.sameInterval {
			if f.prev.time != f.window.end && !f.opt.Interval.IsZero() {
				value := linearFloat(f.window.end, f.prev.time, c.TimeByIndex(getTimeIndex(vs)), f.prev.value, float64(col.IntegerValues()[vs]))
				f.sum += 0.5 * (value + f.prev.value) * float64(f.window.end-f.prev.time) / float64(f.interval.Duration)

				f.prev.value = value
				f.prev.time = f.window.end
			}
			f.StartNewInterval(c.TimeByIndex(getTimeIndex(vs)))
			f.CalculateUnit(0, c.TimeByIndex(getTimeIndex(vs)), float64(col.IntegerValues()[vs]))
		} else {
			f.CalculateUnit(0, c.TimeByIndex(getTimeIndex(vs)), float64(col.IntegerValues()[vs]))
		}
	}
	// process the rest ponints
	for i := vs + 1; i < ve; i++ {
		f.CalculateUnit(i-vs, c.TimeByIndex(getTimeIndex(i)), float64(col.IntegerValues()[i]))
	}
	f.pointNum = ve - vs
	f.sameTag = sameTag
	f.sameInterval = sameInterval
}

func (f *IntegerIntegralItem) AppendItem(c Chunk, ordinal int, start, end int, sameInterval, sameTag bool) {
	if c.Column(ordinal).NilCount() == 0 {
		f.AppendItemFastFunc(c, ordinal, start, end, sameInterval, sameTag)
		return
	}
	f.AppendItemSlowFunc(c, ordinal, start, end, sameInterval, sameTag)
}

func (f *IntegerIntegralItem) Reset() {
	f.time = f.time[:0]
	f.value = f.value[:0]
}

func (f *IntegerIntegralItem) Len() int {
	return len(f.time)
}

func (f *IntegerIntegralItem) Nil() bool {
	return f.prev.isNil
}

type FloatColFloatIntegralIterator struct {
	isSingleCall bool
	inOrdinal    int
	outOrdinal   int
	nilCount     int
	buf          *FloatIntegralItem
}

func NewFloatColFloatIntegralIterator(
	isSingleCall bool, inOrdinal, outOrdinal int, rowDataType hybridqp.RowDataType, interval hybridqp.Interval,
	opt query.ProcessorOptions,
) *FloatColFloatIntegralIterator {
	r := &FloatColFloatIntegralIterator{
		buf:          NewFloatIntegralItem(interval, opt),
		isSingleCall: isSingleCall,
		inOrdinal:    inOrdinal,
		outOrdinal:   outOrdinal,
		nilCount:     0,
	}
	return r
}

func (r *FloatColFloatIntegralIterator) processFirstWindow(
	inChunk Chunk, haveMultiInterval, sameInterval, sameTag bool, start, end int,
) {
	if haveMultiInterval {
		r.buf.AppendItem(inChunk, r.inOrdinal, start, end, false, sameTag)
	} else {
		r.buf.AppendItem(inChunk, r.inOrdinal, start, end, sameInterval, sameTag)
	}
	if !sameTag && (end-start) == 1 && r.buf.prev.time == r.buf.window.start {
		r.nilCount++
	}
}

func (r *FloatColFloatIntegralIterator) processLastWindow(
	inChunk, outChunk Chunk, start, end, tagIdx int,
) {
	r.buf.AppendItem(inChunk, r.inOrdinal, start, end, true, true)
	if r.buf.Len() > 0 {
		r.appendPrevItem(inChunk, outChunk, tagIdx)
		r.buf.Reset()
		if !r.isSingleCall {
			outChunk.Column(r.outOrdinal).AppendManyNil(r.nilCount)
			r.nilCount = 0
		}
	}
}

func (r *FloatColFloatIntegralIterator) processMiddleWindow(
	inChunk, outChunk Chunk, start, end, tagIdx int, sameTag bool,
) {
	r.buf.AppendItem(inChunk, r.inOrdinal, start, end, false, sameTag)
	if !sameTag && (end-start) == 1 && r.buf.prev.time == r.buf.window.start {
		r.nilCount++
	}
	if r.buf.Len() > 0 {
		r.appendPrevItem(inChunk, outChunk, tagIdx)
		r.buf.Reset()
		if !r.isSingleCall {
			outChunk.Column(r.outOrdinal).AppendManyNil(r.nilCount)
			r.nilCount = 0
		}
	}
}

func (r *FloatColFloatIntegralIterator) appendPrevItem(
	inChunk, outChunk Chunk, tagIdx int,
) {
	if r.isSingleCall {
		for j := range r.buf.time {
			outChunk.AppendTime(r.buf.time[j])
			outChunk.Column(r.outOrdinal).AppendFloatValues(r.buf.value[j])
			outChunk.Column(r.outOrdinal).AppendNilsV2(true)
		}
		outChunk.AppendIntervalIndex(outChunk.Len() - r.buf.Len())
		if !(outChunk.TagLen() > 0 && bytes.Equal(inChunk.Tags()[tagIdx].Subset(r.buf.opt.Dimensions),
			outChunk.Tags()[outChunk.TagLen()-1].Subset(r.buf.opt.Dimensions))) {
			outChunk.AppendTagsAndIndex(inChunk.Tags()[tagIdx], outChunk.IntervalIndex()[outChunk.IntervalLen()-1])
		}
		return
	}

	for j := range r.buf.time {
		outChunk.Column(r.outOrdinal).AppendFloatValues(r.buf.value[j])
		outChunk.Column(r.outOrdinal).AppendNilsV2(true)
	}
}

func (r *FloatColFloatIntegralIterator) appendLastItem(
	inChunk, outChunk Chunk, tagIdx int,
) {
	if r.isSingleCall {
		if r.buf.opt.Interval.IsZero() {
			outChunk.AppendTime(0)
		} else {
			outChunk.AppendTime(r.buf.window.start)
		}
		outChunk.Column(r.outOrdinal).AppendFloatValues(r.buf.sum)
		outChunk.Column(r.outOrdinal).AppendNilsV2(true)
		outChunk.AppendIntervalIndex(outChunk.Len() - 1)
		if !(outChunk.TagLen() > 0 && bytes.Equal(inChunk.Tags()[tagIdx].Subset(r.buf.opt.Dimensions),
			outChunk.Tags()[outChunk.TagLen()-1].Subset(r.buf.opt.Dimensions))) {
			outChunk.AppendTagsAndIndex(inChunk.Tags()[tagIdx], outChunk.IntervalIndex()[outChunk.IntervalLen()-1])
		}
		return
	}

	outChunk.Column(r.outOrdinal).AppendFloatValues(r.buf.sum)
	outChunk.Column(r.outOrdinal).AppendNilsV2(true)
}

func (r *FloatColFloatIntegralIterator) Next(ie *IteratorEndpoint, p *IteratorParams) {
	inChunk, outChunk := ie.InputPoint.Chunk, ie.OutputPoint.Chunk
	if inChunk.Column(r.inOrdinal).IsEmpty() && r.buf.Len() > 0 {
		return
	}

	var start, end int
	firstIndex, lastIndex := 0, len(inChunk.IntervalIndex())-1
	lastTagIndex := len(inChunk.TagIndex()) - 1
	intervali := 0
	var subIntervalIndexEnd int
	for i, _ := range inChunk.TagIndex() {
		if i == lastTagIndex {
			subIntervalIndexEnd = inChunk.NumberOfRows()
		} else {
			subIntervalIndexEnd = inChunk.TagIndex()[i+1]
		}
		for inChunk.IntervalIndex()[intervali] < subIntervalIndexEnd {
			start = inChunk.IntervalIndex()[intervali]
			if intervali < lastIndex {
				end = inChunk.IntervalIndex()[intervali+1]
			} else {
				end = subIntervalIndexEnd
			}
			var sametag bool
			if end == inChunk.NumberOfRows() {
				sametag = !(end == subIntervalIndexEnd) || p.sameTag
			} else {
				sametag = !(end == subIntervalIndexEnd)
			}
			if !r.isSingleCall {
				start, end = inChunk.Column(r.inOrdinal).GetRangeValueIndexV2(start, end)
				if start == end {
					if r.buf.Nil() {
						outChunk.Column(r.outOrdinal).AppendNilsV2(false)
						intervali++
						if intervali >= len(inChunk.IntervalIndex()) {
							break
						}
						continue
					} else {
						r.nilCount++
					}
				}
			}
			if intervali == firstIndex && r.buf.sameInterval {
				r.processFirstWindow(inChunk, firstIndex != lastIndex, p.sameInterval, sametag, start, end)
			} else if intervali == lastIndex && p.sameInterval {
				r.processLastWindow(inChunk, outChunk, start, end, i)
			} else {
				r.processMiddleWindow(inChunk, outChunk, start, end, i, sametag)
			}
			intervali++
			if intervali >= len(inChunk.IntervalIndex()) {
				break
			}
		}
	}
	if p.lastChunk {
		if !(r.buf.pointNum == 1 && r.buf.prev.time == r.buf.window.start) && !(r.buf.pointNum == 0) {
			r.appendLastItem(inChunk, outChunk, inChunk.TagLen()-1)
		}
		if !r.isSingleCall {
			outChunk.Column(r.outOrdinal).AppendManyNil(r.nilCount)
			r.nilCount = 0
		}
	}
}

type IntegerColFloatIntegralIterator struct {
	isSingleCall bool
	inOrdinal    int
	outOrdinal   int
	nilCount     int
	buf          *IntegerIntegralItem
}

func NewIntegerColFloatIntegralIterator(
	isSingleCall bool, inOrdinal, outOrdinal int, rowDataType hybridqp.RowDataType, interval hybridqp.Interval,
	opt query.ProcessorOptions,
) *IntegerColFloatIntegralIterator {
	r := &IntegerColFloatIntegralIterator{
		buf:          NewIntegerIntegralItem(interval, opt),
		isSingleCall: isSingleCall,
		inOrdinal:    inOrdinal,
		outOrdinal:   outOrdinal,
		nilCount:     0,
	}
	return r
}

func (r *IntegerColFloatIntegralIterator) processFirstWindow(
	inChunk Chunk, haveMultiInterval, sameInterval, sameTag bool, start, end int,
) {
	if haveMultiInterval {
		r.buf.AppendItem(inChunk, r.inOrdinal, start, end, false, sameTag)
	} else {
		r.buf.AppendItem(inChunk, r.inOrdinal, start, end, sameInterval, sameTag)
	}
	if !sameTag && (end-start) == 1 && r.buf.prev.time == r.buf.window.start {
		r.nilCount++
	}
}

func (r *IntegerColFloatIntegralIterator) processLastWindow(
	inChunk, outChunk Chunk, start, end, tagIdx int,
) {
	r.buf.AppendItem(inChunk, r.inOrdinal, start, end, true, true)
	if r.buf.Len() > 0 {
		r.appendPrevItem(inChunk, outChunk, tagIdx)
		r.buf.Reset()
		if !r.isSingleCall {
			outChunk.Column(r.outOrdinal).AppendManyNil(r.nilCount)
			r.nilCount = 0
		}
	}
}

func (r *IntegerColFloatIntegralIterator) processMiddleWindow(
	inChunk, outChunk Chunk, start, end, tagIdx int, sameTag bool,
) {
	r.buf.AppendItem(inChunk, r.inOrdinal, start, end, false, sameTag)
	if !sameTag && (end-start) == 1 && r.buf.prev.time == r.buf.window.start {
		r.nilCount++
	}
	if r.buf.Len() > 0 {
		r.appendPrevItem(inChunk, outChunk, tagIdx)
		r.buf.Reset()
		if !r.isSingleCall {
			outChunk.Column(r.outOrdinal).AppendManyNil(r.nilCount)
			r.nilCount = 0
		}
	}
}

func (r *IntegerColFloatIntegralIterator) appendPrevItem(
	inChunk, outChunk Chunk, tagIdx int,
) {
	if r.isSingleCall {
		for j := range r.buf.time {
			outChunk.AppendTime(r.buf.time[j])
			outChunk.Column(r.outOrdinal).AppendFloatValues(r.buf.value[j])
			outChunk.Column(r.outOrdinal).AppendNilsV2(true)
		}
		outChunk.AppendIntervalIndex(outChunk.Len() - r.buf.Len())
		if !(outChunk.TagLen() > 0 && bytes.Equal(inChunk.Tags()[tagIdx].Subset(r.buf.opt.Dimensions),
			outChunk.Tags()[outChunk.TagLen()-1].Subset(r.buf.opt.Dimensions))) {
			outChunk.AppendTagsAndIndex(inChunk.Tags()[tagIdx], outChunk.IntervalIndex()[outChunk.IntervalLen()-1])
		}
		return
	}

	for j := range r.buf.time {
		outChunk.Column(r.outOrdinal).AppendFloatValues(r.buf.value[j])
		outChunk.Column(r.outOrdinal).AppendNilsV2(true)
	}
}

func (r *IntegerColFloatIntegralIterator) appendLastItem(
	inChunk, outChunk Chunk, tagIdx int,
) {
	if r.isSingleCall {
		if r.buf.opt.Interval.IsZero() {
			outChunk.AppendTime(0)
		} else {
			outChunk.AppendTime(r.buf.window.start)
		}
		outChunk.Column(r.outOrdinal).AppendFloatValues(r.buf.sum)
		outChunk.Column(r.outOrdinal).AppendNilsV2(true)
		outChunk.AppendIntervalIndex(outChunk.Len() - 1)
		if !(outChunk.TagLen() > 0 && bytes.Equal(inChunk.Tags()[tagIdx].Subset(r.buf.opt.Dimensions),
			outChunk.Tags()[outChunk.TagLen()-1].Subset(r.buf.opt.Dimensions))) {
			outChunk.AppendTagsAndIndex(inChunk.Tags()[tagIdx], outChunk.IntervalIndex()[outChunk.IntervalLen()-1])
		}
		return
	}

	outChunk.Column(r.outOrdinal).AppendFloatValues(r.buf.sum)
	outChunk.Column(r.outOrdinal).AppendNilsV2(true)
}

func (r *IntegerColFloatIntegralIterator) Next(ie *IteratorEndpoint, p *IteratorParams) {
	inChunk, outChunk := ie.InputPoint.Chunk, ie.OutputPoint.Chunk
	if inChunk.Column(r.inOrdinal).IsEmpty() && r.buf.Len() > 0 {
		return
	}

	var start, end int
	firstIndex, lastIndex := 0, len(inChunk.IntervalIndex())-1
	lastTagIndex := len(inChunk.TagIndex()) - 1
	intervali := 0
	var subIntervalIndexEnd int
	for i, _ := range inChunk.TagIndex() {
		if i == lastTagIndex {
			subIntervalIndexEnd = inChunk.NumberOfRows()
		} else {
			subIntervalIndexEnd = inChunk.TagIndex()[i+1]
		}
		for inChunk.IntervalIndex()[intervali] < subIntervalIndexEnd {
			start = inChunk.IntervalIndex()[intervali]
			if intervali < lastIndex {
				end = inChunk.IntervalIndex()[intervali+1]
			} else {
				end = subIntervalIndexEnd
			}
			var sametag bool
			if end == inChunk.NumberOfRows() {
				sametag = !(end == subIntervalIndexEnd) || p.sameTag
			} else {
				sametag = !(end == subIntervalIndexEnd)
			}
			if !r.isSingleCall {
				start, end = inChunk.Column(r.inOrdinal).GetRangeValueIndexV2(start, end)
				if start == end {
					if r.buf.Nil() {
						outChunk.Column(r.outOrdinal).AppendNilsV2(false)
						intervali++
						if intervali >= len(inChunk.IntervalIndex()) {
							break
						}
						continue
					} else {
						r.nilCount++
					}
				}
			}
			if intervali == firstIndex && r.buf.sameInterval {
				r.processFirstWindow(inChunk, firstIndex != lastIndex, p.sameInterval, sametag, start, end)
			} else if intervali == lastIndex && p.sameInterval {
				r.processLastWindow(inChunk, outChunk, start, end, i)
			} else {
				r.processMiddleWindow(inChunk, outChunk, start, end, i, sametag)
			}
			intervali++
			if intervali >= len(inChunk.IntervalIndex()) {
				break
			}
		}
	}
	if p.lastChunk {
		if !(r.buf.pointNum == 1 && r.buf.prev.time == r.buf.window.start) && !(r.buf.pointNum == 0) {
			r.appendLastItem(inChunk, outChunk, inChunk.TagLen()-1)
		}
		if !r.isSingleCall {
			outChunk.Column(r.outOrdinal).AppendManyNil(r.nilCount)
			r.nilCount = 0
		}
	}
}

type ElapsedItem struct {
	prev     int64
	time     []int64
	nils     []bool
	value    []int64
	interval hybridqp.Interval
}

func NewElapsedItem(interval hybridqp.Interval) *ElapsedItem {
	return &ElapsedItem{
		interval: interval, prev: -1,
	}
}

func (f *ElapsedItem) AppendItemFastFunc(c Chunk, _ int, start, end int, sameInterval bool) {
	// fast path
	time := c.Time()[start:end]

	// process the first point
	if f.prev > 0 {
		elapsed := time[0] - f.prev
		v := elapsed / int64(f.interval.Duration)
		f.time = append(f.time, time[0])
		f.value = append(f.value, v)
		f.nils = append(f.nils, false)
	}

	// calculate diff for middle points
	for i := 1; i < len(time); i++ {
		elapsed := time[i] - time[i-1]
		v := elapsed / int64(f.interval.Duration)
		f.time = append(f.time, time[i])
		f.value = append(f.value, v)
		f.nils = append(f.nils, false)
	}

	// process the last point
	if sameInterval {
		f.prev = time[len(time)-1]
	} else {
		f.prev = -1
	}
}

func (f *ElapsedItem) doNullWindow(time []int64, sameInterval bool) {
	if f.prev == -1 {
		f.time = append(f.time, time[1:]...)
		f.value = append(f.value, make([]int64, len(time)-1)...)
		f.nils = append(f.nils, make([]bool, len(time)-1)...)
		for i := len(f.nils) - 1; i >= (len(f.nils) - len(time) + 1); i-- {
			f.nils[i] = true
		}
	} else {
		f.time = append(f.time, time...)
		f.value = append(f.value, make([]int64, len(time))...)
		f.nils = append(f.nils, make([]bool, len(time))...)
		for i := len(f.nils) - 1; i >= (len(f.nils) - len(time)); i-- {
			f.nils[i] = true
		}
	}

	if !sameInterval {
		f.prev = -1
	}
}

func (f *ElapsedItem) AppendItemSlowFunc(c Chunk, ordinal int, start, end int, sameInterval bool) {
	// slow path
	col := c.Column(ordinal)
	time := c.Time()[start:end]
	vs, ve := col.GetRangeValueIndexV2(start, end)
	if vs == ve {
		f.doNullWindow(time, sameInterval)
		return
	}

	// calculate diff for middle points
	for i := start; i < end; i++ {
		t := c.TimeByIndex(i)
		if col.IsNilV2(i) {
			f.time = append(f.time, t)
			f.value = append(f.value, 0)
			f.nils = append(f.nils, true)
			continue
		}

		if f.prev == -1 {
			f.prev = t
			continue
		}
		elapsed := t - f.prev
		v := elapsed / int64(f.interval.Duration)
		f.time = append(f.time, t)
		f.value = append(f.value, v)
		f.nils = append(f.nils, false)
		f.prev = t
	}

	// process the last point
	if !sameInterval {
		f.prev = -1
	}
}

func (f *ElapsedItem) AppendItem(c Chunk, ordinal int, start, end int, sameInterval bool) {
	if c.Column(ordinal).NilCount() == 0 {
		f.AppendItemFastFunc(c, ordinal, start, end, sameInterval)
		return
	}
	f.AppendItemSlowFunc(c, ordinal, start, end, sameInterval)
}

func (f *ElapsedItem) Reset() {
	f.time = f.time[:0]
	f.value = f.value[:0]
	f.nils = f.nils[:0]
}

func (f *ElapsedItem) Len() int {
	return len(f.time)
}

func (f *ElapsedItem) PrevNil() bool {
	return f.prev == -1
}

func (f *ElapsedItem) ResetPrev() {
	f.prev = -1
}

func (f *ElapsedItem) GetBaseTransData() BaseTransData {
	return BaseTransData{time: f.time, integerValue: f.value, nils: f.nils}
}

type FloatMovingAverageItem struct {
	window []FloatPoint
	cur    int
	pos    int
	sum    float64
	time   []int64
	value  []float64
	nils   []bool
	n      int
}

func NewFloatMovingAverageItem(n int) *FloatMovingAverageItem {
	return &FloatMovingAverageItem{window: make([]FloatPoint, 0, n), pos: 0, cur: 0, sum: 0, n: n}
}

func (f *FloatMovingAverageItem) AppendItemFastFunc(c Chunk, ordinal int, start, end int, sameInterval bool) {
	// fast path
	col := c.Column(ordinal)
	time := c.Time()[start:end]
	value := col.FloatValues()[start:end]
	for i := 0; i < len(time); i++ {
		f.cur += 1
		if len(f.window) == f.n {
			f.sum = f.sum - f.window[f.pos].value + value[i]
			f.window[f.pos] = FloatPoint{time: time[i], value: value[i], isNil: false}
			f.pos = (f.pos + 1) % f.n
			f.value = append(f.value, f.sum/float64(f.n))
			f.time = append(f.time, f.window[(f.pos+f.n-1)%f.n].time)
			f.nils = append(f.nils, false)
		} else if len(f.window) == f.n-1 {
			f.sum += value[i]
			f.window = append(f.window, FloatPoint{time: time[i], value: value[i], isNil: false})
			f.value = append(f.value, f.sum/float64(f.n))
			f.time = append(f.time, f.window[(f.pos+f.n-1)%f.n].time)
			f.nils = append(f.nils, false)
		} else {
			f.sum += value[i]
			f.window = append(f.window, FloatPoint{time: time[i], value: value[i], isNil: false})
			if f.cur >= f.n {
				f.nils = append(f.nils, true)
				f.time = append(f.time, time[0])
				f.value = append(f.value, 0)
			}
		}
	}
	if !sameInterval {
		f.ResetPrev()
	}
}

func (f *FloatMovingAverageItem) doNullWindow(time []int64, sameInterval bool) {
	if f.cur+1 >= f.n {
		nils := make([]bool, len(time))
		for i := 0; i < len(time); i++ {
			nils[i] = true
		}
		f.nils = append(f.nils, nils...)
		f.value = append(f.value, make([]float64, len(time))...)
		f.time = append(f.time, time...)
	} else {
		windowNeed := f.n - f.cur - 1
		if len(time) > windowNeed {
			nils := make([]bool, len(time)-windowNeed)
			for i := 0; i < len(time)-windowNeed; i++ {
				nils[i] = true
			}
			f.nils = append(f.nils, nils...)
			f.value = append(f.value, make([]float64, len(time)-windowNeed)...)
			f.time = append(f.time, time[windowNeed:]...)
		}
	}
	f.cur += len(time)
	if !sameInterval {
		f.ResetPrev()
	}
}

func (f *FloatMovingAverageItem) AppendItemSlowFunc(c Chunk, ordinal int, start, end int, sameInterval bool) {
	// slow path
	col := c.Column(ordinal)
	time := c.Time()[start:end]
	vs, ve := col.GetRangeValueIndexV2(start, end)
	if vs == ve {
		f.doNullWindow(time, sameInterval)
		return
	}

	var vos int
	for i := start; i < end; i++ {
		f.cur += 1
		t := c.TimeByIndex(i)
		if col.IsNilV2(i) {
			if f.cur >= f.n {
				f.time = append(f.time, t)
				f.value = append(f.value, 0)
				f.nils = append(f.nils, true)
			}
			continue
		}

		v := col.FloatValue(vs + vos)
		vos++

		if len(f.window) == f.n {
			f.sum = f.sum - f.window[f.pos].value + v
			f.window[f.pos] = FloatPoint{time: t, value: v, isNil: false}
			f.pos = (f.pos + 1) % f.n
			f.value = append(f.value, f.sum/float64(f.n))
			f.time = append(f.time, f.window[(f.pos+f.n-1)%f.n].time)
			f.nils = append(f.nils, false)
		} else if len(f.window) == f.n-1 {
			f.sum += v
			f.window = append(f.window, FloatPoint{time: t, value: v, isNil: false})
			f.value = append(f.value, f.sum/float64(f.n))
			f.time = append(f.time, f.window[(f.pos+f.n-1)%f.n].time)
			f.nils = append(f.nils, false)
		} else {
			f.sum += v
			f.window = append(f.window, FloatPoint{time: t, value: v, isNil: false})
			if f.cur >= f.n {
				f.nils = append(f.nils, true)
				f.time = append(f.time, t)
				f.value = append(f.value, 0)
			}
		}
	}
	if !sameInterval {
		f.ResetPrev()
	}
}

func (f *FloatMovingAverageItem) AppendItem(c Chunk, ordinal int, start, end int, sameInterval bool) {
	if c.Column(ordinal).NilCount() == 0 {
		f.AppendItemFastFunc(c, ordinal, start, end, sameInterval)
		return
	}
	f.AppendItemSlowFunc(c, ordinal, start, end, sameInterval)
}

func (f *FloatMovingAverageItem) Reset() {
	f.time = f.time[:0]
	f.value = f.value[:0]
	f.nils = f.nils[:0]
}

func (f *FloatMovingAverageItem) Len() int {
	return len(f.time)
}

func (f *FloatMovingAverageItem) PrevNil() bool {
	return len(f.window) == 0
}

func (f *FloatMovingAverageItem) ResetPrev() {
	f.window = f.window[:0]
	f.pos = 0
	f.sum = 0
	f.cur = 0
}

func (f *FloatMovingAverageItem) GetBaseTransData() BaseTransData {
	return BaseTransData{time: f.time, floatValue: f.value, nils: f.nils}
}

type IntegerMovingAverageItem struct {
	window []IntegerPoint
	cur    int
	pos    int
	sum    int64
	time   []int64
	value  []float64
	nils   []bool
	n      int
}

func NewIntegerMovingAverageItem(n int) *IntegerMovingAverageItem {
	return &IntegerMovingAverageItem{window: make([]IntegerPoint, 0, n), pos: 0, cur: 0, sum: 0, n: n}
}

func (f *IntegerMovingAverageItem) AppendItemFastFunc(c Chunk, ordinal int, start, end int, sameInterval bool) {
	// fast path
	col := c.Column(ordinal)
	time := c.Time()[start:end]
	value := col.IntegerValues()[start:end]
	for i := 0; i < len(time); i++ {
		f.cur += 1
		if len(f.window) == f.n {
			f.sum = f.sum - f.window[f.pos].value + value[i]
			f.window[f.pos] = IntegerPoint{time: time[i], value: value[i], isNil: false}
			f.pos = (f.pos + 1) % f.n
			f.value = append(f.value, float64(f.sum)/float64(f.n))
			f.time = append(f.time, f.window[(f.pos+f.n-1)%f.n].time)
			f.nils = append(f.nils, false)
		} else if len(f.window) == f.n-1 {
			f.sum += value[i]
			f.window = append(f.window, IntegerPoint{time: time[i], value: value[i], isNil: false})
			f.value = append(f.value, float64(f.sum)/float64(f.n))
			f.time = append(f.time, f.window[(f.pos+f.n-1)%f.n].time)
			f.nils = append(f.nils, false)
		} else {
			f.sum += value[i]
			f.window = append(f.window, IntegerPoint{time: time[i], value: value[i], isNil: false})
			if f.cur >= f.n {
				f.nils = append(f.nils, true)
				f.time = append(f.time, time[0])
				f.value = append(f.value, 0)
			}
		}
	}
	if !sameInterval {
		f.ResetPrev()
	}
}

func (f *IntegerMovingAverageItem) doNullWindow(time []int64, sameInterval bool) {
	if f.cur+1 >= f.n {
		nils := make([]bool, len(time))
		for i := 0; i < len(time); i++ {
			nils[i] = true
		}
		f.nils = append(f.nils, nils...)
		f.value = append(f.value, make([]float64, len(time))...)
		f.time = append(f.time, time...)
	} else {
		windowNeed := f.n - f.cur - 1
		if len(time) > windowNeed {
			nils := make([]bool, len(time)-windowNeed)
			for i := 0; i < len(time)-windowNeed; i++ {
				nils[i] = true
			}
			f.nils = append(f.nils, nils...)
			f.value = append(f.value, make([]float64, len(time)-windowNeed)...)
			f.time = append(f.time, time[windowNeed:]...)
		}
	}
	f.cur += len(time)
	if !sameInterval {
		f.ResetPrev()
	}
}

func (f *IntegerMovingAverageItem) AppendItemSlowFunc(c Chunk, ordinal int, start, end int, sameInterval bool) {
	// slow path
	col := c.Column(ordinal)
	time := c.Time()[start:end]
	vs, ve := col.GetRangeValueIndexV2(start, end)
	if vs == ve {
		f.doNullWindow(time, sameInterval)
		return
	}

	var vos int
	for i := start; i < end; i++ {
		f.cur += 1
		t := c.TimeByIndex(i)
		if col.IsNilV2(i) {
			if f.cur >= f.n {
				f.time = append(f.time, t)
				f.value = append(f.value, 0)
				f.nils = append(f.nils, true)
			}
			continue
		}

		v := col.IntegerValue(vs + vos)
		vos++

		if len(f.window) == f.n {
			f.sum = f.sum - f.window[f.pos].value + v
			f.window[f.pos] = IntegerPoint{time: t, value: v, isNil: false}
			f.pos = (f.pos + 1) % f.n
			f.value = append(f.value, float64(f.sum)/float64(f.n))
			f.time = append(f.time, f.window[(f.pos+f.n-1)%f.n].time)
			f.nils = append(f.nils, false)
		} else if len(f.window) == f.n-1 {
			f.sum += v
			f.window = append(f.window, IntegerPoint{time: t, value: v, isNil: false})
			f.value = append(f.value, float64(f.sum)/float64(f.n))
			f.time = append(f.time, f.window[(f.pos+f.n-1)%f.n].time)
			f.nils = append(f.nils, false)
		} else {
			f.sum += v
			f.window = append(f.window, IntegerPoint{time: t, value: v, isNil: false})
			if f.cur >= f.n {
				f.nils = append(f.nils, true)
				f.time = append(f.time, t)
				f.value = append(f.value, 0)
			}
		}
	}
	if !sameInterval {
		f.ResetPrev()
	}
}

func (f *IntegerMovingAverageItem) AppendItem(c Chunk, ordinal int, start, end int, sameInterval bool) {
	if c.Column(ordinal).NilCount() == 0 {
		f.AppendItemFastFunc(c, ordinal, start, end, sameInterval)
		return
	}
	f.AppendItemSlowFunc(c, ordinal, start, end, sameInterval)
}

func (f *IntegerMovingAverageItem) Reset() {
	f.time = f.time[:0]
	f.value = f.value[:0]
	f.nils = f.nils[:0]
}

func (f *IntegerMovingAverageItem) Len() int {
	return len(f.time)
}

func (f *IntegerMovingAverageItem) PrevNil() bool {
	return len(f.window) == 0
}

func (f *IntegerMovingAverageItem) ResetPrev() {
	f.window = f.window[:0]
	f.pos = 0
	f.sum = 0
	f.cur = 0
}

func (f *IntegerMovingAverageItem) GetBaseTransData() BaseTransData {
	return BaseTransData{time: f.time, floatValue: f.value, nils: f.nils}
}

type FloatCumulativeSumItem struct {
	sum   float64
	time  []int64
	value []float64
	nils  []bool
}

func NewFloatCumulativeSumItem() *FloatCumulativeSumItem {
	return &FloatCumulativeSumItem{sum: 0}
}

func (f *FloatCumulativeSumItem) AppendItemFastFunc(c Chunk, ordinal int, start, end int, sameInterval bool) {
	// fast path
	col := c.Column(ordinal)
	time := c.Time()[start:end]
	value := col.FloatValues()[start:end]

	for i := 0; i < len(time); i++ {
		f.sum += value[i]
		f.time = append(f.time, time[i])
		f.value = append(f.value, f.sum)
		f.nils = append(f.nils, false)
	}

	if !sameInterval {
		f.sum = 0
	}
}

func (f *FloatCumulativeSumItem) doNullWindow(time []int64, sameInterval bool) {
	f.time = append(f.time, time[:]...)
	f.value = append(f.value, make([]float64, len(time))...)
	f.nils = append(f.nils, make([]bool, len(time))...)
	for i := len(f.nils) - 1; i >= len(f.nils)-len(time); i-- {
		f.nils[i] = true
	}
	if !sameInterval {
		f.sum = 0
	}
}

func (f *FloatCumulativeSumItem) AppendItemSlowFunc(c Chunk, ordinal int, start, end int, sameInterval bool) {
	// slow path
	col := c.Column(ordinal)
	time := c.Time()[start:end]
	vs, ve := col.GetRangeValueIndexV2(start, end)
	if vs == ve {
		f.doNullWindow(time, sameInterval)
		return
	}

	var vos int
	for i := start; i < end; i++ {
		t := c.TimeByIndex(i)
		if col.IsNilV2(i) {
			f.time = append(f.time, t)
			f.value = append(f.value, 0)
			f.nils = append(f.nils, true)
			continue
		}

		v := col.FloatValue(vs + vos)
		vos++
		f.sum += v
		f.time = append(f.time, t)
		f.value = append(f.value, f.sum)
		f.nils = append(f.nils, false)
	}

	if !sameInterval {
		f.sum = 0
	}
}

func (f *FloatCumulativeSumItem) AppendItem(c Chunk, ordinal int, start, end int, sameInterval bool) {
	if c.Column(ordinal).NilCount() == 0 {
		f.AppendItemFastFunc(c, ordinal, start, end, sameInterval)
		return
	}
	f.AppendItemSlowFunc(c, ordinal, start, end, sameInterval)
}

func (f *FloatCumulativeSumItem) Reset() {
	f.time = f.time[:0]
	f.value = f.value[:0]
	f.nils = f.nils[:0]
}

func (f *FloatCumulativeSumItem) Len() int {
	return len(f.time)
}

func (f *FloatCumulativeSumItem) PrevNil() bool {
	return f.sum == 0
}

func (f *FloatCumulativeSumItem) ResetPrev() {
	f.sum = 0
}

func (f *FloatCumulativeSumItem) GetBaseTransData() BaseTransData {
	return BaseTransData{time: f.time, floatValue: f.value, nils: f.nils}
}

type IntegerCumulativeSumItem struct {
	sum   int64
	time  []int64
	value []int64
	nils  []bool
}

func NewIntegerCumulativeSumItem() *IntegerCumulativeSumItem {
	return &IntegerCumulativeSumItem{sum: 0}
}

func (f *IntegerCumulativeSumItem) AppendItemFastFunc(c Chunk, ordinal int, start, end int, sameInterval bool) {
	// fast path
	col := c.Column(ordinal)
	time := c.Time()[start:end]
	value := col.IntegerValues()[start:end]

	for i := 0; i < len(time); i++ {
		f.sum += value[i]
		f.time = append(f.time, time[i])
		f.value = append(f.value, f.sum)
		f.nils = append(f.nils, false)
	}

	if !sameInterval {
		f.sum = 0
	}
}

func (f *IntegerCumulativeSumItem) doNullWindow(time []int64, sameInterval bool) {
	f.time = append(f.time, time[:]...)
	f.value = append(f.value, make([]int64, len(time))...)
	f.nils = append(f.nils, make([]bool, len(time))...)
	for i := len(f.nils) - 1; i >= len(f.nils)-len(time); i-- {
		f.nils[i] = true
	}
	if !sameInterval {
		f.sum = 0
	}
}

func (f *IntegerCumulativeSumItem) AppendItemSlowFunc(c Chunk, ordinal int, start, end int, sameInterval bool) {
	// slow path
	col := c.Column(ordinal)
	time := c.Time()[start:end]
	vs, ve := col.GetRangeValueIndexV2(start, end)
	if vs == ve {
		f.doNullWindow(time, sameInterval)
		return
	}

	var vos int
	for i := start; i < end; i++ {
		t := c.TimeByIndex(i)
		if col.IsNilV2(i) {
			f.time = append(f.time, t)
			f.value = append(f.value, 0)
			f.nils = append(f.nils, true)
			continue
		}

		v := col.IntegerValue(vs + vos)
		vos++
		f.sum += v
		f.time = append(f.time, t)
		f.value = append(f.value, f.sum)
		f.nils = append(f.nils, false)
	}

	if !sameInterval {
		f.sum = 0
	}
}

func (f *IntegerCumulativeSumItem) AppendItem(c Chunk, ordinal int, start, end int, sameInterval bool) {
	if c.Column(ordinal).NilCount() == 0 {
		f.AppendItemFastFunc(c, ordinal, start, end, sameInterval)
		return
	}
	f.AppendItemSlowFunc(c, ordinal, start, end, sameInterval)
}

func (f *IntegerCumulativeSumItem) Reset() {
	f.time = f.time[:0]
	f.value = f.value[:0]
	f.nils = f.nils[:0]
}

func (f *IntegerCumulativeSumItem) Len() int {
	return len(f.time)
}

func (f *IntegerCumulativeSumItem) PrevNil() bool {
	return f.sum == 0
}

func (f *IntegerCumulativeSumItem) ResetPrev() {
	f.sum = 0
}

func (f *IntegerCumulativeSumItem) GetBaseTransData() BaseTransData {
	return BaseTransData{time: f.time, integerValue: f.value, nils: f.nils}
}

type FloatColFloatTransIterator struct {
	isSingleCall bool
	inOrdinal    int
	outOrdinal   int
	buf          TransItem
}

func NewFloatColFloatTransIterator(
	isSingleCall bool, inOrdinal, outOrdinal int, rowDataType hybridqp.RowDataType, transItem TransItem,
) *FloatColFloatTransIterator {
	r := &FloatColFloatTransIterator{
		buf:          transItem,
		isSingleCall: isSingleCall,
		inOrdinal:    inOrdinal,
		outOrdinal:   outOrdinal,
	}
	return r
}

func (r *FloatColFloatTransIterator) processFirstWindow(
	inChunk, outChunk Chunk, haveMultiInterval, sameInterval bool, start, end, i int,
) {
	if haveMultiInterval {
		r.buf.AppendItem(inChunk, r.inOrdinal, start, end, false)
	} else {
		r.buf.AppendItem(inChunk, r.inOrdinal, start, end, sameInterval)
	}
	if r.buf.Len() > 0 {
		r.appendCurrItem(inChunk, outChunk, i)
	}
	r.buf.Reset()
}

func (r *FloatColFloatTransIterator) processLastWindow(
	inChunk, outChunk Chunk, start, end, i int,
) {
	r.buf.AppendItem(inChunk, r.inOrdinal, start, end, true)
	if r.buf.Len() > 0 {
		r.appendCurrItem(inChunk, outChunk, i)
	}
	r.buf.Reset()
}

func (r *FloatColFloatTransIterator) processMiddleWindow(
	inChunk, outChunk Chunk, start, end, i int,
) {
	r.buf.AppendItem(inChunk, r.inOrdinal, start, end, false)
	if r.buf.Len() > 0 {
		r.appendCurrItem(inChunk, outChunk, i)
	}
	r.buf.Reset()
}

func (r *FloatColFloatTransIterator) appendCurrItem(inChunk, outChunk Chunk, i int) {
	transData := r.buf.GetBaseTransData()
	time := transData.time
	value := transData.floatValue
	nils := transData.nils
	if r.isSingleCall {
		var nilCount int
		for j := range time {
			if nils[j] {
				nilCount++
				continue
			}
			outChunk.AppendTime(time[j])
			outChunk.Column(r.outOrdinal).AppendFloatValues(value[j])
			outChunk.Column(r.outOrdinal).AppendNilsV2(true)
		}
		if nilCount == r.buf.Len() {
			return
		}
		idx := outChunk.Len() - r.buf.Len() + nilCount
		outChunk.AppendIntervalIndex(idx)
		outChunk.AppendTagsAndIndex(inChunk.Tags()[i], idx)
		return
	}
	for j := range time {
		if nils[j] {
			outChunk.Column(r.outOrdinal).AppendNil()
			continue
		}
		outChunk.Column(r.outOrdinal).AppendFloatValues(value[j])
		outChunk.Column(r.outOrdinal).AppendNilsV2(true)
	}
}

func (r *FloatColFloatTransIterator) Next(ie *IteratorEndpoint, p *IteratorParams) {
	var end int
	inChunk, outChunk := ie.InputPoint.Chunk, ie.OutputPoint.Chunk
	firstIndex, lastIndex := 0, len(inChunk.TagIndex())-1
	for i, start := range inChunk.TagIndex() {
		if i < lastIndex {
			end = inChunk.TagIndex()[i+1]
		} else {
			end = inChunk.NumberOfRows()
		}

		if i == firstIndex && !r.buf.PrevNil() {
			r.processFirstWindow(inChunk, outChunk, firstIndex != lastIndex, p.sameInterval, start, end, i)
		} else if i == lastIndex && p.sameInterval {
			r.processLastWindow(inChunk, outChunk, start, end, i)
		} else {
			r.processMiddleWindow(inChunk, outChunk, start, end, i)
		}
	}
}

type IntegerColFloatTransIterator struct {
	isSingleCall bool
	inOrdinal    int
	outOrdinal   int
	buf          TransItem
}

func NewIntegerColFloatTransIterator(
	isSingleCall bool, inOrdinal, outOrdinal int, rowDataType hybridqp.RowDataType, transItem TransItem,
) *IntegerColFloatTransIterator {
	r := &IntegerColFloatTransIterator{
		buf:          transItem,
		isSingleCall: isSingleCall,
		inOrdinal:    inOrdinal,
		outOrdinal:   outOrdinal,
	}
	return r
}

func (r *IntegerColFloatTransIterator) processFirstWindow(
	inChunk, outChunk Chunk, haveMultiInterval, sameInterval bool, start, end, i int,
) {
	if haveMultiInterval {
		r.buf.AppendItem(inChunk, r.inOrdinal, start, end, false)
	} else {
		r.buf.AppendItem(inChunk, r.inOrdinal, start, end, sameInterval)
	}
	if r.buf.Len() > 0 {
		r.appendCurrItem(inChunk, outChunk, i)
	}
	r.buf.Reset()
}

func (r *IntegerColFloatTransIterator) processLastWindow(
	inChunk, outChunk Chunk, start, end, i int,
) {
	r.buf.AppendItem(inChunk, r.inOrdinal, start, end, true)
	if r.buf.Len() > 0 {
		r.appendCurrItem(inChunk, outChunk, i)
	}
	r.buf.Reset()
}

func (r *IntegerColFloatTransIterator) processMiddleWindow(
	inChunk, outChunk Chunk, start, end, i int,
) {
	r.buf.AppendItem(inChunk, r.inOrdinal, start, end, false)
	if r.buf.Len() > 0 {
		r.appendCurrItem(inChunk, outChunk, i)
	}
	r.buf.Reset()
}

func (r *IntegerColFloatTransIterator) appendCurrItem(inChunk, outChunk Chunk, i int) {
	transData := r.buf.GetBaseTransData()
	time := transData.time
	value := transData.floatValue
	nils := transData.nils
	if r.isSingleCall {
		var nilCount int
		for j := range time {
			if nils[j] {
				nilCount++
				continue
			}
			outChunk.AppendTime(time[j])
			outChunk.Column(r.outOrdinal).AppendFloatValues(value[j])
			outChunk.Column(r.outOrdinal).AppendNilsV2(true)
		}
		if nilCount == r.buf.Len() {
			return
		}
		idx := outChunk.Len() - r.buf.Len() + nilCount
		outChunk.AppendIntervalIndex(idx)
		outChunk.AppendTagsAndIndex(inChunk.Tags()[i], idx)
		return
	}
	for j := range time {
		if nils[j] {
			outChunk.Column(r.outOrdinal).AppendNil()
			continue
		}
		outChunk.Column(r.outOrdinal).AppendFloatValues(value[j])
		outChunk.Column(r.outOrdinal).AppendNilsV2(true)
	}
}

func (r *IntegerColFloatTransIterator) Next(ie *IteratorEndpoint, p *IteratorParams) {
	var end int
	inChunk, outChunk := ie.InputPoint.Chunk, ie.OutputPoint.Chunk
	firstIndex, lastIndex := 0, len(inChunk.TagIndex())-1
	for i, start := range inChunk.TagIndex() {
		if i < lastIndex {
			end = inChunk.TagIndex()[i+1]
		} else {
			end = inChunk.NumberOfRows()
		}

		if i == firstIndex && !r.buf.PrevNil() {
			r.processFirstWindow(inChunk, outChunk, firstIndex != lastIndex, p.sameInterval, start, end, i)
		} else if i == lastIndex && p.sameInterval {
			r.processLastWindow(inChunk, outChunk, start, end, i)
		} else {
			r.processMiddleWindow(inChunk, outChunk, start, end, i)
		}
	}
}

type IntegerColIntegerTransIterator struct {
	isSingleCall bool
	inOrdinal    int
	outOrdinal   int
	buf          TransItem
}

func NewIntegerColIntegerTransIterator(
	isSingleCall bool, inOrdinal, outOrdinal int, rowDataType hybridqp.RowDataType, transItem TransItem,
) *IntegerColIntegerTransIterator {
	r := &IntegerColIntegerTransIterator{
		buf:          transItem,
		isSingleCall: isSingleCall,
		inOrdinal:    inOrdinal,
		outOrdinal:   outOrdinal,
	}
	return r
}

func (r *IntegerColIntegerTransIterator) processFirstWindow(
	inChunk, outChunk Chunk, haveMultiInterval, sameInterval bool, start, end, i int,
) {
	if haveMultiInterval {
		r.buf.AppendItem(inChunk, r.inOrdinal, start, end, false)
	} else {
		r.buf.AppendItem(inChunk, r.inOrdinal, start, end, sameInterval)
	}
	if r.buf.Len() > 0 {
		r.appendCurrItem(inChunk, outChunk, i)
	}
	r.buf.Reset()
}

func (r *IntegerColIntegerTransIterator) processLastWindow(
	inChunk, outChunk Chunk, start, end, i int,
) {
	r.buf.AppendItem(inChunk, r.inOrdinal, start, end, true)
	if r.buf.Len() > 0 {
		r.appendCurrItem(inChunk, outChunk, i)
	}
	r.buf.Reset()
}

func (r *IntegerColIntegerTransIterator) processMiddleWindow(
	inChunk, outChunk Chunk, start, end, i int,
) {
	r.buf.AppendItem(inChunk, r.inOrdinal, start, end, false)
	if r.buf.Len() > 0 {
		r.appendCurrItem(inChunk, outChunk, i)
	}
	r.buf.Reset()
}

func (r *IntegerColIntegerTransIterator) appendCurrItem(inChunk, outChunk Chunk, i int) {
	transData := r.buf.GetBaseTransData()
	time := transData.time
	value := transData.integerValue
	nils := transData.nils
	if r.isSingleCall {
		var nilCount int
		for j := range time {
			if nils[j] {
				nilCount++
				continue
			}
			outChunk.AppendTime(time[j])
			outChunk.Column(r.outOrdinal).AppendIntegerValues(value[j])
			outChunk.Column(r.outOrdinal).AppendNilsV2(true)
		}
		if nilCount == r.buf.Len() {
			return
		}
		idx := outChunk.Len() - r.buf.Len() + nilCount
		outChunk.AppendIntervalIndex(idx)
		outChunk.AppendTagsAndIndex(inChunk.Tags()[i], idx)
		return
	}
	for j := range time {
		if nils[j] {
			outChunk.Column(r.outOrdinal).AppendNil()
			continue
		}
		outChunk.Column(r.outOrdinal).AppendIntegerValues(value[j])
		outChunk.Column(r.outOrdinal).AppendNilsV2(true)
	}
}

func (r *IntegerColIntegerTransIterator) Next(ie *IteratorEndpoint, p *IteratorParams) {
	var end int
	inChunk, outChunk := ie.InputPoint.Chunk, ie.OutputPoint.Chunk
	firstIndex, lastIndex := 0, len(inChunk.TagIndex())-1
	for i, start := range inChunk.TagIndex() {
		if i < lastIndex {
			end = inChunk.TagIndex()[i+1]
		} else {
			end = inChunk.NumberOfRows()
		}

		if i == firstIndex && !r.buf.PrevNil() {
			r.processFirstWindow(inChunk, outChunk, firstIndex != lastIndex, p.sameInterval, start, end, i)
		} else if i == lastIndex && p.sameInterval {
			r.processLastWindow(inChunk, outChunk, start, end, i)
		} else {
			r.processMiddleWindow(inChunk, outChunk, start, end, i)
		}
	}
}

type FloatColFloatRateMiddleReduce func(c Chunk, ordinal, start, end int) (firstIndex, lastIndex int, firstValue, lastValue float64, isNil bool)

type FloatColFloatRateFinalReduce func(firstTime, lastTime int64, firstValue, lastValue float64, interval *hybridqp.Interval) (v float64, isNil bool)

type FloatColFloatRateUpdate func(prevPoints, currPoints [2]*FloatPoint)

type FloatColFloatRateMerge func(prevPoints [2]*FloatPoint, interval *hybridqp.Interval) (v float64, isNil bool)

type FloatColFloatRateIterator struct {
	isSingleCall bool
	inOrdinal    int
	outOrdinal   int
	interval     *hybridqp.Interval
	fn           FloatColFloatRateMiddleReduce
	fv           FloatColFloatRateFinalReduce
	fu           FloatColFloatRateUpdate
	fm           FloatColFloatRateMerge
	prevPoints   [2]*FloatPoint
	currPoints   [2]*FloatPoint
}

func NewFloatColFloatRateIterator(fn FloatColFloatRateMiddleReduce, fv FloatColFloatRateFinalReduce,
	fu FloatColFloatRateUpdate, fm FloatColFloatRateMerge,
	isSingleCall bool, inOrdinal, outOrdinal int, rowDataType hybridqp.RowDataType,
	interval *hybridqp.Interval,
) *FloatColFloatRateIterator {
	r := &FloatColFloatRateIterator{
		fn:           fn,
		fv:           fv,
		fu:           fu,
		fm:           fm,
		isSingleCall: isSingleCall,
		inOrdinal:    inOrdinal,
		outOrdinal:   outOrdinal,
		interval:     interval,
		prevPoints:   [2]*FloatPoint{newFloatPoint(), newFloatPoint()},
		currPoints:   [2]*FloatPoint{newFloatPoint(), newFloatPoint()},
	}
	return r
}

func (r *FloatColFloatRateIterator) mergePrevItem(outChunk Chunk, v float64, isNil bool) {
	if r.isSingleCall && !isNil {
		outChunk.AppendTime(r.prevPoints[0].time)
		outChunk.AppendIntervalIndex(outChunk.Len() - 1)
	}
	if isNil {
		outChunk.Column(r.outOrdinal).AppendNil()
	} else {
		outChunk.Column(r.outOrdinal).AppendNilsV2(true)
		outChunk.Column(r.outOrdinal).AppendFloatValues(v)
	}
}

func (r *FloatColFloatRateIterator) doFirstWindowForNull(outChunk Chunk) {
	if r.prevPoints[0].isNil || r.prevPoints[1].isNil {
		outChunk.Column(r.outOrdinal).AppendNil()
	} else {
		v, isNils := r.fm(r.prevPoints, r.interval)
		r.mergePrevItem(outChunk, v, isNils)
	}
	r.prevPoints[0].Reset()
	r.prevPoints[1].Reset()
}

func (r *FloatColFloatRateIterator) processNullWindow(outChunk Chunk, sameInterval, onlyOneInterval bool,
	i, firstIndex, lastIndex int) {
	if onlyOneInterval {
		if !sameInterval {
			r.doFirstWindowForNull(outChunk)
		}
	} else {
		if i == firstIndex {
			r.doFirstWindowForNull(outChunk)
		} else if i == lastIndex {
			if !sameInterval {
				outChunk.Column(r.outOrdinal).AppendNil()
			}
		} else {
			outChunk.Column(r.outOrdinal).AppendNil()
		}
	}
}

func (r *FloatColFloatRateIterator) processFirstWindow(outChunk Chunk, sameInterval, onlyOneInterval bool) {
	if !onlyOneInterval || !sameInterval {
		if !r.prevPoints[0].isNil && !r.prevPoints[1].isNil {
			v, isNil := r.fm(r.prevPoints, r.interval)
			r.mergePrevItem(outChunk, v, isNil)
		}
		r.prevPoints[0].Reset()
		r.prevPoints[1].Reset()
	}
	r.currPoints[0].Reset()
	r.currPoints[1].Reset()
}

func (r *FloatColFloatRateIterator) processLastWindow(inChunk Chunk, fi, si int, fv, sv float64) {
	r.prevPoints[0].Set(fi, inChunk.TimeByIndex(fi), fv)
	r.prevPoints[1].Set(si, inChunk.TimeByIndex(si), sv)
}

func (r *FloatColFloatRateIterator) processMiddleWindow(inChunk, outChunk Chunk, fi, si int, fv, sv float64) {
	v, isNil := r.fv(inChunk.TimeByIndex(fi), inChunk.TimeByIndex(si), fv, sv, r.interval)
	if r.isSingleCall && !isNil {
		outChunk.AppendTime(inChunk.TimeByIndex(fi))
		outChunk.AppendIntervalIndex(outChunk.Len() - 1)
	}
	if isNil {
		outChunk.Column(r.outOrdinal).AppendNil()
	} else {
		outChunk.Column(r.outOrdinal).AppendNilsV2(true)
		outChunk.Column(r.outOrdinal).AppendFloatValues(v)
	}
}

func (r *FloatColFloatRateIterator) Next(ie *IteratorEndpoint, p *IteratorParams) {
	var end int
	inChunk, outChunk := ie.InputPoint.Chunk, ie.OutputPoint.Chunk
	firstIndex, lastIndex := 0, len(inChunk.IntervalIndex())-1
	onlyOneInterval := inChunk.IntervalLen() == 1
	for i, start := range inChunk.IntervalIndex() {
		if i < lastIndex {
			end = inChunk.IntervalIndex()[i+1]
		} else {
			end = inChunk.NumberOfRows()
		}

		fi, si, fv, sv, isNil := r.fn(inChunk, r.inOrdinal, start, end)
		if isNil {
			r.processNullWindow(outChunk, p.sameInterval, onlyOneInterval, i, firstIndex, lastIndex)
			continue
		}

		if i == firstIndex && (!r.prevPoints[0].isNil || !r.prevPoints[1].isNil) {
			r.currPoints[0].Set(fi, inChunk.TimeByIndex(fi), fv)
			r.currPoints[1].Set(si, inChunk.TimeByIndex(si), sv)
			r.fu(r.prevPoints, r.currPoints)
			r.processFirstWindow(outChunk, p.sameInterval, onlyOneInterval)
		} else if i == lastIndex && p.sameInterval {
			r.processLastWindow(inChunk, fi, si, fv, sv)
		} else {
			r.processMiddleWindow(inChunk, outChunk, fi, si, fv, sv)
		}
	}
}

type IntegerColFloatRateMiddleReduce func(c Chunk, ordinal, start, end int) (firstIndex, lastIndex int, firstValue, lastValue int64, isNil bool)

type IntegerColFloatRateFinalReduce func(firstTime, lastTime int64, firstValue, lastValue int64, interval *hybridqp.Interval) (v float64, isNil bool)

type IntegerColFloatRateUpdate func(prevPoints, currPoints [2]*IntegerPoint)

type IntegerColFloatRateMerge func(prevPoints [2]*IntegerPoint, interval *hybridqp.Interval) (v float64, isNil bool)

type IntegerColFloatRateIterator struct {
	isSingleCall bool
	inOrdinal    int
	outOrdinal   int
	interval     *hybridqp.Interval
	fn           IntegerColFloatRateMiddleReduce
	fv           IntegerColFloatRateFinalReduce
	fu           IntegerColFloatRateUpdate
	fm           IntegerColFloatRateMerge
	prevPoints   [2]*IntegerPoint
	currPoints   [2]*IntegerPoint
}

func NewIntegerColFloatRateIterator(fn IntegerColFloatRateMiddleReduce, fv IntegerColFloatRateFinalReduce,
	fu IntegerColFloatRateUpdate, fm IntegerColFloatRateMerge,
	isSingleCall bool, inOrdinal, outOrdinal int, rowDataType hybridqp.RowDataType,
	interval *hybridqp.Interval,
) *IntegerColFloatRateIterator {
	r := &IntegerColFloatRateIterator{
		fn:           fn,
		fv:           fv,
		fu:           fu,
		fm:           fm,
		isSingleCall: isSingleCall,
		inOrdinal:    inOrdinal,
		outOrdinal:   outOrdinal,
		interval:     interval,
		prevPoints:   [2]*IntegerPoint{newIntegerPoint(), newIntegerPoint()},
		currPoints:   [2]*IntegerPoint{newIntegerPoint(), newIntegerPoint()},
	}
	return r
}

func (r *IntegerColFloatRateIterator) mergePrevItem(outChunk Chunk, v float64, isNil bool) {
	if r.isSingleCall && !isNil {
		outChunk.AppendTime(r.prevPoints[0].time)
		outChunk.AppendIntervalIndex(outChunk.Len() - 1)
	}
	if isNil {
		outChunk.Column(r.outOrdinal).AppendNil()
	} else {
		outChunk.Column(r.outOrdinal).AppendNilsV2(true)
		outChunk.Column(r.outOrdinal).AppendFloatValues(v)
	}
}

func (r *IntegerColFloatRateIterator) doFirstWindowForNull(outChunk Chunk) {
	if r.prevPoints[0].isNil || r.prevPoints[1].isNil {
		outChunk.Column(r.outOrdinal).AppendNil()
	} else {
		v, isNils := r.fm(r.prevPoints, r.interval)
		r.mergePrevItem(outChunk, v, isNils)
	}
	r.prevPoints[0].Reset()
	r.prevPoints[1].Reset()
}

func (r *IntegerColFloatRateIterator) processNullWindow(outChunk Chunk, sameInterval, onlyOneInterval bool,
	i, firstIndex, lastIndex int) {
	if onlyOneInterval {
		if !sameInterval {
			r.doFirstWindowForNull(outChunk)
		}
	} else {
		if i == firstIndex {
			r.doFirstWindowForNull(outChunk)
		} else if i == lastIndex {
			if !sameInterval {
				outChunk.Column(r.outOrdinal).AppendNil()
			}
		} else {
			outChunk.Column(r.outOrdinal).AppendNil()
		}
	}
}

func (r *IntegerColFloatRateIterator) processFirstWindow(outChunk Chunk, sameInterval, onlyOneInterval bool) {
	if !onlyOneInterval || !sameInterval {
		if !r.prevPoints[0].isNil && !r.prevPoints[1].isNil {
			v, isNil := r.fm(r.prevPoints, r.interval)
			r.mergePrevItem(outChunk, v, isNil)
		}
		r.prevPoints[0].Reset()
		r.prevPoints[1].Reset()
	}
	r.currPoints[0].Reset()
	r.currPoints[1].Reset()
}

func (r *IntegerColFloatRateIterator) processLastWindow(inChunk Chunk, fi, si int, fv, sv int64) {
	r.prevPoints[0].Set(fi, inChunk.TimeByIndex(fi), fv)
	r.prevPoints[1].Set(si, inChunk.TimeByIndex(si), sv)
}

func (r *IntegerColFloatRateIterator) processMiddleWindow(inChunk, outChunk Chunk, fi, si int, fv, sv int64) {
	v, isNil := r.fv(inChunk.TimeByIndex(fi), inChunk.TimeByIndex(si), fv, sv, r.interval)
	if r.isSingleCall && !isNil {
		outChunk.AppendTime(inChunk.TimeByIndex(fi))
		outChunk.AppendIntervalIndex(outChunk.Len() - 1)
	}
	if isNil {
		outChunk.Column(r.outOrdinal).AppendNil()
	} else {
		outChunk.Column(r.outOrdinal).AppendNilsV2(true)
		outChunk.Column(r.outOrdinal).AppendFloatValues(v)
	}
}

func (r *IntegerColFloatRateIterator) Next(ie *IteratorEndpoint, p *IteratorParams) {
	var end int
	inChunk, outChunk := ie.InputPoint.Chunk, ie.OutputPoint.Chunk
	firstIndex, lastIndex := 0, len(inChunk.IntervalIndex())-1
	onlyOneInterval := inChunk.IntervalLen() == 1
	for i, start := range inChunk.IntervalIndex() {
		if i < lastIndex {
			end = inChunk.IntervalIndex()[i+1]
		} else {
			end = inChunk.NumberOfRows()
		}

		fi, si, fv, sv, isNil := r.fn(inChunk, r.inOrdinal, start, end)
		if isNil {
			r.processNullWindow(outChunk, p.sameInterval, onlyOneInterval, i, firstIndex, lastIndex)
			continue
		}

		if i == firstIndex && (!r.prevPoints[0].isNil || !r.prevPoints[1].isNil) {
			r.currPoints[0].Set(fi, inChunk.TimeByIndex(fi), fv)
			r.currPoints[1].Set(si, inChunk.TimeByIndex(si), sv)
			r.fu(r.prevPoints, r.currPoints)
			r.processFirstWindow(outChunk, p.sameInterval, onlyOneInterval)
		} else if i == lastIndex && p.sameInterval {
			r.processLastWindow(inChunk, fi, si, fv, sv)
		} else {
			r.processMiddleWindow(inChunk, outChunk, fi, si, fv, sv)
		}
	}
}

type FloatSampleItem struct {
	maxIndex int
	items    []FloatPointItem
}

func (f *FloatSampleItem) Reset() {
	f.maxIndex = 0
	f.items = f.items[:0]
}

func (f *FloatSampleItem) Len() int {
	return len(f.items)
}

func (f *FloatSampleItem) Less(i, j int) bool {
	if f.items[i].time != f.items[j].time {
		return f.items[i].time < f.items[j].time
	}
	return f.items[i].index < f.items[j].index
}

func (f *FloatSampleItem) Swap(i, j int) {
	f.items[i], f.items[j] = f.items[j], f.items[i]
}

func (f *FloatSampleItem) appendForAux(input Chunk, start, end, ordinal int) []int {
	maxIndex := f.maxIndex + 1
	f.appendForFast(input, start, end, ordinal, maxIndex)
	index := make([]int, 0)
	for i := range f.items {
		if idx := f.items[i].index + start - maxIndex; idx >= start {
			index = append(index, idx)
		}
	}
	return index
}

type IntegerSampleItem struct {
	maxIndex int
	items    []IntegerPointItem
}

func (f *IntegerSampleItem) Reset() {
	f.maxIndex = 0
	f.items = f.items[:0]
}

func (f *IntegerSampleItem) Len() int {
	return len(f.items)
}

func (f *IntegerSampleItem) Less(i, j int) bool {
	if f.items[i].time != f.items[j].time {
		return f.items[i].time < f.items[j].time
	}
	return f.items[i].index < f.items[j].index
}

func (f *IntegerSampleItem) Swap(i, j int) {
	f.items[i], f.items[j] = f.items[j], f.items[i]
}

func (f *IntegerSampleItem) appendForAux(input Chunk, start, end, ordinal int) []int {
	maxIndex := f.maxIndex + 1
	f.appendForFast(input, start, end, ordinal, maxIndex)
	index := make([]int, 0)
	for i := range f.items {
		if idx := f.items[i].index + start - maxIndex; idx >= start {
			index = append(index, idx)
		}
	}
	return index
}

type StringSampleItem struct {
	maxIndex int
	items    []StringPointItem
}

func (f *StringSampleItem) Reset() {
	f.maxIndex = 0
	f.items = f.items[:0]
}

func (f *StringSampleItem) Len() int {
	return len(f.items)
}

func (f *StringSampleItem) Less(i, j int) bool {
	if f.items[i].time != f.items[j].time {
		return f.items[i].time < f.items[j].time
	}
	return f.items[i].index < f.items[j].index
}

func (f *StringSampleItem) Swap(i, j int) {
	f.items[i], f.items[j] = f.items[j], f.items[i]
}

func (f *StringSampleItem) appendForAux(input Chunk, start, end, ordinal int) []int {
	maxIndex := f.maxIndex + 1
	f.appendForFast(input, start, end, ordinal, maxIndex)
	index := make([]int, 0)
	for i := range f.items {
		if idx := f.items[i].index + start - maxIndex; idx >= start {
			index = append(index, idx)
		}
	}
	return index
}

type BooleanSampleItem struct {
	maxIndex int
	items    []BooleanPointItem
}

func (f *BooleanSampleItem) Reset() {
	f.maxIndex = 0
	f.items = f.items[:0]
}

func (f *BooleanSampleItem) Len() int {
	return len(f.items)
}

func (f *BooleanSampleItem) Less(i, j int) bool {
	if f.items[i].time != f.items[j].time {
		return f.items[i].time < f.items[j].time
	}
	return f.items[i].index < f.items[j].index
}

func (f *BooleanSampleItem) Swap(i, j int) {
	f.items[i], f.items[j] = f.items[j], f.items[i]
}

func (f *BooleanSampleItem) appendForAux(input Chunk, start, end, ordinal int) []int {
	maxIndex := f.maxIndex + 1
	f.appendForFast(input, start, end, ordinal, maxIndex)
	index := make([]int, 0)
	for i := range f.items {
		if idx := f.items[i].index + start - maxIndex; idx >= start {
			index = append(index, idx)
		}
	}
	return index
}

func (f *FloatSampleItem) appendForFast(input Chunk, start, end, ordinal, maxIndex int) {
	for i := start; i < end; i++ {
		p := NewFloatPointItem(
			input.TimeByIndex(i),
			input.Column(ordinal).FloatValues()[i])
		p.index = maxIndex + i - start
		if f.Len() == cap(f.items) {
			rnd := rand.Intn(p.index)
			if rnd >= cap(f.items) {
				continue
			}
			if (*p).index > f.maxIndex {
				f.maxIndex = (*p).index
			}
			f.items[rnd] = *p
			continue
		} else {
			if (*p).index > f.maxIndex {
				f.maxIndex = (*p).index
			}
			f.items = append(f.items, *p)
		}
	}
}

func (f *IntegerSampleItem) appendForFast(input Chunk, start, end, ordinal, maxIndex int) {
	for i := start; i < end; i++ {
		p := NewIntegerPointItem(
			input.TimeByIndex(i),
			input.Column(ordinal).IntegerValues()[i])
		p.index = maxIndex + i - start
		if f.Len() == cap(f.items) {
			rnd := rand.Intn(p.index)
			if rnd >= cap(f.items) {
				continue
			}
			if (*p).index > f.maxIndex {
				f.maxIndex = (*p).index
			}
			f.items[rnd] = *p
			continue
		} else {
			if (*p).index > f.maxIndex {
				f.maxIndex = (*p).index
			}
			f.items = append(f.items, *p)
		}
	}
}

func (f *BooleanSampleItem) appendForFast(input Chunk, start, end, ordinal, maxIndex int) {
	for i := start; i < end; i++ {
		p := NewBooleanPointItem(
			input.TimeByIndex(i),
			input.Column(ordinal).BooleanValues()[i])
		p.index = maxIndex + i - start
		if f.Len() == cap(f.items) {
			rnd := rand.Intn(p.index)
			if rnd >= cap(f.items) {
				continue
			}
			if (*p).index > f.maxIndex {
				f.maxIndex = (*p).index
			}
			f.items[rnd] = *p
			continue
		} else {
			if (*p).index > f.maxIndex {
				f.maxIndex = (*p).index
			}
			f.items = append(f.items, *p)
		}
	}
}

func (f *StringSampleItem) appendForFast(input Chunk, start, end, ordinal, maxIndex int) {
	for i := start; i < end; i++ {
		p := NewStringPointItem(
			input.TimeByIndex(i),
			input.Column(ordinal).StringValue(i))
		p.index = maxIndex + i - start
		if f.Len() == cap(f.items) {
			rnd := rand.Intn(p.index)
			if rnd >= cap(f.items) {
				continue
			}
			if (*p).index > f.maxIndex {
				f.maxIndex = (*p).index
			}
			f.items[rnd] = *p
			continue
		} else {
			if (*p).index > f.maxIndex {
				f.maxIndex = (*p).index
			}
			f.items = append(f.items, *p)
		}
	}
}

type FloatColFloatSampleIterator struct {
	sampleNum     int
	isSingleCall  bool
	inOrdinal     int
	outOrdinal    int
	prevMaxIndex  int
	buf           *FloatSampleItem
	auxChunk      Chunk
	auxProcessor  []*AuxProcessor
	windowIndex   []int
	prevBufIndex  []int
	currBufIndex  []int
	interBufIndex []int
}

func NewFloatSampleItem(items []FloatPointItem) *FloatSampleItem {
	return &FloatSampleItem{
		items: items,
	}
}

func NewFloatColFloatSampleIterator(sampleNum int,
	isSingleCall bool, inOrdinal, outOrdinal int, auxProcessor []*AuxProcessor, rowDataType hybridqp.RowDataType,
) *FloatColFloatSampleIterator {
	r := &FloatColFloatSampleIterator{
		buf:          NewFloatSampleItem(make([]FloatPointItem, 0, sampleNum)),
		sampleNum:    sampleNum,
		isSingleCall: isSingleCall,
		inOrdinal:    inOrdinal,
		outOrdinal:   outOrdinal,
	}
	if isSingleCall && len(auxProcessor) > 0 {
		r.auxProcessor = auxProcessor
		r.auxChunk = NewChunkBuilder(rowDataType).NewChunk("")
	}
	return r
}

func (r *FloatColFloatSampleIterator) reset() {
	r.prevBufIndex = r.prevBufIndex[:0]
	r.currBufIndex = r.currBufIndex[:0]
	r.interBufIndex = r.interBufIndex[:0]
	r.windowIndex = r.windowIndex[:0]
}

func (r *FloatColFloatSampleIterator) updateAuxColBothChunk(inChunk Chunk) {
	clone := r.auxChunk.Clone()
	r.auxChunk.Reset()
	sort.Ints(r.interBufIndex)
	r.currBufIndex = r.currBufIndex[:0]
	for i := range r.prevBufIndex {
		if hybridqp.BinarySearch(r.prevBufIndex[i], r.interBufIndex) {
			r.currBufIndex = append(r.currBufIndex, i)
		}
	}
	r.prevBufIndex = r.prevBufIndex[:0]
	for i := range r.buf.items {
		r.prevBufIndex = append(r.prevBufIndex, r.buf.items[i].index-r.prevMaxIndex)
	}
	hybridqp.SortS1ByS2(r.windowIndex, r.prevBufIndex)
	cs, ws := 0, 0
	for i := range r.buf.items {
		if hybridqp.BinarySearch(r.buf.items[i].index, r.interBufIndex) {
			for j := range r.auxProcessor {
				r.auxProcessor[j].auxHelperFunc(
					clone.Column(r.auxProcessor[j].outOrdinal),
					r.auxChunk.Column(r.auxProcessor[j].outOrdinal),
					r.currBufIndex[cs],
				)
			}
			cs++
		} else {
			for j := range r.auxProcessor {
				r.auxProcessor[j].auxHelperFunc(
					inChunk.Column(r.auxProcessor[j].inOrdinal),
					r.auxChunk.Column(r.auxProcessor[j].outOrdinal),
					r.windowIndex[ws],
				)
			}
			ws++
		}
	}
	clone.Reset()
}

func (r *FloatColFloatSampleIterator) updatePrevItem(
	inChunk Chunk, start, end int,
) {
	if len(r.auxProcessor) == 0 {
		r.buf.appendForFast(inChunk, start, end, r.inOrdinal, r.buf.maxIndex+1)
	} else {
		sort.Sort(r.buf)
		for i := range r.buf.items {
			r.prevBufIndex = append(r.prevBufIndex, r.buf.items[i].index)
		}
		r.prevMaxIndex = r.buf.maxIndex + 1
		r.windowIndex = r.buf.appendForAux(inChunk, start, end, r.inOrdinal)
		for i := range r.buf.items {
			r.currBufIndex = append(r.currBufIndex, r.buf.items[i].index)
		}
		r.interBufIndex = hybridqp.Intersect(r.prevBufIndex, r.currBufIndex)
		sort.Sort(r.buf)
		if !hybridqp.CompareSlice(r.interBufIndex, r.prevBufIndex) {
			r.updateAuxColBothChunk(inChunk)
		} else {
			r.updateAuxColInChunk(inChunk)
		}
	}
	r.reset()
}

func (r *FloatColFloatSampleIterator) updateAuxColInChunk(inChunk Chunk) {
	if len(r.interBufIndex) == 0 {
		r.auxChunk.Reset()
	}
	r.currBufIndex = r.currBufIndex[:0]
	for i := range r.buf.items {
		r.currBufIndex = append(r.currBufIndex, r.buf.items[i].index-r.prevMaxIndex)
	}
	hybridqp.SortS1ByS2(r.windowIndex, r.currBufIndex)
	for j := range r.auxProcessor {
		r.auxProcessor[j].auxHelperFunc(
			inChunk.Column(r.auxProcessor[j].inOrdinal),
			r.auxChunk.Column(r.auxProcessor[j].outOrdinal),
			r.windowIndex...,
		)
	}
}

func (r *FloatColFloatSampleIterator) appendPrevItem(
	inChunk, outChunk Chunk,
) {
	for j := range r.buf.items {
		outChunk.AppendTime(r.buf.items[j].time)
		outChunk.Column(r.outOrdinal).AppendFloatValues(r.buf.items[j].value)
		outChunk.Column(r.outOrdinal).AppendNilsV2(true)
	}
	if len(r.auxProcessor) > 0 {
		for j := range r.buf.items {
			r.windowIndex = append(r.windowIndex, j)
		}
		for j := range r.auxProcessor {
			r.auxProcessor[j].auxHelperFunc(
				r.auxChunk.Column(r.auxProcessor[j].outOrdinal),
				outChunk.Column(r.auxProcessor[j].outOrdinal),
				r.windowIndex...,
			)
		}
		r.windowIndex = r.windowIndex[:0]
		r.auxChunk.Reset()
	}
	outChunk.AppendIntervalIndex(outChunk.Len() - r.buf.Len())
}

func (r *FloatColFloatSampleIterator) processFirstWindow(
	inChunk, outChunk Chunk, sameInterval, haveMultiInterval bool, start, end int,
) {
	r.updatePrevItem(inChunk, start, end)
	if haveMultiInterval || !sameInterval {
		sort.Sort(r.buf)
		if r.buf.Len() > 0 {
			r.appendPrevItem(r.auxChunk, outChunk)
		}
		r.buf.Reset()
	}
}

func (r *FloatColFloatSampleIterator) updateCurrItem(
	inChunk Chunk, start, end int,
) {
	if len(r.auxProcessor) == 0 {
		r.buf.appendForFast(inChunk, start, end, r.inOrdinal, r.buf.maxIndex+1)
	} else {
		sort.Sort(r.buf)
		r.prevMaxIndex = r.buf.maxIndex + 1
		r.windowIndex = r.buf.appendForAux(inChunk, start, end, r.inOrdinal)
		for j := range r.auxProcessor {
			r.auxProcessor[j].auxHelperFunc(
				inChunk.Column(r.auxProcessor[j].inOrdinal),
				r.auxChunk.Column(r.auxProcessor[j].outOrdinal),
				r.windowIndex...,
			)
		}
		r.windowIndex = r.windowIndex[:0]
		r.currBufIndex = r.currBufIndex[:0]
	}
}

func (r *FloatColFloatSampleIterator) processLastWindow(
	inChunk Chunk, start, end int,
) {
	r.updateCurrItem(inChunk, start, end)
}

func (r *FloatColFloatSampleIterator) appendCurrItem(
	inChunk, outChunk Chunk, start int,
) {
	for j := range r.buf.items {
		outChunk.AppendTime(r.buf.items[j].time)
		outChunk.Column(r.outOrdinal).AppendFloatValues(r.buf.items[j].value)
		outChunk.Column(r.outOrdinal).AppendNilsV2(true)
	}
	if len(r.auxProcessor) > 0 {
		for i := range r.buf.items {
			r.currBufIndex = append(r.currBufIndex, r.buf.items[i].index+start-r.prevMaxIndex)
		}
		hybridqp.SortS1ByS2(r.windowIndex, r.currBufIndex)
		for j := range r.auxProcessor {
			r.auxProcessor[j].auxHelperFunc(
				inChunk.Column(r.auxProcessor[j].inOrdinal),
				outChunk.Column(r.auxProcessor[j].outOrdinal),
				r.windowIndex...,
			)
		}
		r.windowIndex = r.windowIndex[:0]
		r.currBufIndex = r.currBufIndex[:0]
	}
	outChunk.AppendIntervalIndex(outChunk.Len() - r.buf.Len())
}

func (r *FloatColFloatSampleIterator) processMiddleWindow(
	inChunk, outChunk Chunk, start, end int,
) {
	if len(r.auxProcessor) == 0 {
		r.buf.appendForFast(inChunk, start, end, r.inOrdinal, r.buf.maxIndex+1)
	} else {
		r.prevMaxIndex = r.buf.maxIndex + 1
		r.windowIndex = r.buf.appendForAux(inChunk, start, end, r.inOrdinal)
	}
	sort.Sort(r.buf)
	if r.buf.Len() > 0 {
		r.appendCurrItem(inChunk, outChunk, start)
	}
	r.buf.Reset()
}

func (r *FloatColFloatSampleIterator) Next(ie *IteratorEndpoint, p *IteratorParams) {
	inChunk, outChunk := ie.InputPoint.Chunk, ie.OutputPoint.Chunk
	if inChunk.Column(r.inOrdinal).IsEmpty() && r.buf.Len() > 0 {
		return
	}
	var end int
	firstIndex, lastIndex := 0, len(inChunk.IntervalIndex())-1
	for i, start := range inChunk.IntervalIndex() {
		if i < lastIndex {
			end = inChunk.IntervalIndex()[i+1]
		} else {
			end = inChunk.NumberOfRows()
		}
		if i == firstIndex && r.buf.Len() > 0 {
			r.processFirstWindow(inChunk, outChunk, p.sameInterval,
				firstIndex != lastIndex, start, end)
		} else if i == lastIndex && p.sameInterval {
			r.processLastWindow(inChunk, start, end)
		} else {
			r.processMiddleWindow(inChunk, outChunk, start, end)
		}
	}
}

type IntegerColIntegerSampleIterator struct {
	sampleNum     int
	isSingleCall  bool
	inOrdinal     int
	outOrdinal    int
	prevMaxIndex  int
	buf           *IntegerSampleItem
	auxChunk      Chunk
	auxProcessor  []*AuxProcessor
	windowIndex   []int
	prevBufIndex  []int
	currBufIndex  []int
	interBufIndex []int
}

func NewIntegerSampleItem(items []IntegerPointItem) *IntegerSampleItem {
	return &IntegerSampleItem{
		items: items,
	}
}

func NewIntegerColIntegerSampleIterator(sampleNum int,
	isSingleCall bool, inOrdinal, outOrdinal int, auxProcessor []*AuxProcessor, rowDataType hybridqp.RowDataType,
) *IntegerColIntegerSampleIterator {
	r := &IntegerColIntegerSampleIterator{
		buf:          NewIntegerSampleItem(make([]IntegerPointItem, 0, sampleNum)),
		sampleNum:    sampleNum,
		isSingleCall: isSingleCall,
		inOrdinal:    inOrdinal,
		outOrdinal:   outOrdinal,
	}
	if isSingleCall && len(auxProcessor) > 0 {
		r.auxProcessor = auxProcessor
		r.auxChunk = NewChunkBuilder(rowDataType).NewChunk("")
	}
	return r
}

func (r *IntegerColIntegerSampleIterator) reset() {
	r.prevBufIndex = r.prevBufIndex[:0]
	r.currBufIndex = r.currBufIndex[:0]
	r.interBufIndex = r.interBufIndex[:0]
	r.windowIndex = r.windowIndex[:0]
}

func (r *IntegerColIntegerSampleIterator) updateAuxColBothChunk(inChunk Chunk) {
	clone := r.auxChunk.Clone()
	r.auxChunk.Reset()
	sort.Ints(r.interBufIndex)
	r.currBufIndex = r.currBufIndex[:0]
	for i := range r.prevBufIndex {
		if hybridqp.BinarySearch(r.prevBufIndex[i], r.interBufIndex) {
			r.currBufIndex = append(r.currBufIndex, i)
		}
	}
	r.prevBufIndex = r.prevBufIndex[:0]
	for i := range r.buf.items {
		r.prevBufIndex = append(r.prevBufIndex, r.buf.items[i].index-r.prevMaxIndex)
	}
	hybridqp.SortS1ByS2(r.windowIndex, r.prevBufIndex)
	cs, ws := 0, 0
	for i := range r.buf.items {
		if hybridqp.BinarySearch(r.buf.items[i].index, r.interBufIndex) {
			for j := range r.auxProcessor {
				r.auxProcessor[j].auxHelperFunc(
					clone.Column(r.auxProcessor[j].outOrdinal),
					r.auxChunk.Column(r.auxProcessor[j].outOrdinal),
					r.currBufIndex[cs],
				)
			}
			cs++
		} else {
			for j := range r.auxProcessor {
				r.auxProcessor[j].auxHelperFunc(
					inChunk.Column(r.auxProcessor[j].inOrdinal),
					r.auxChunk.Column(r.auxProcessor[j].outOrdinal),
					r.windowIndex[ws],
				)
			}
			ws++
		}
	}
	clone.Reset()
}

func (r *IntegerColIntegerSampleIterator) updatePrevItem(
	inChunk Chunk, start, end int,
) {
	if len(r.auxProcessor) == 0 {
		r.buf.appendForFast(inChunk, start, end, r.inOrdinal, r.buf.maxIndex+1)
	} else {
		sort.Sort(r.buf)
		for i := range r.buf.items {
			r.prevBufIndex = append(r.prevBufIndex, r.buf.items[i].index)
		}
		r.prevMaxIndex = r.buf.maxIndex + 1
		r.windowIndex = r.buf.appendForAux(inChunk, start, end, r.inOrdinal)
		for i := range r.buf.items {
			r.currBufIndex = append(r.currBufIndex, r.buf.items[i].index)
		}
		r.interBufIndex = hybridqp.Intersect(r.prevBufIndex, r.currBufIndex)
		sort.Sort(r.buf)
		if !hybridqp.CompareSlice(r.interBufIndex, r.prevBufIndex) {
			r.updateAuxColBothChunk(inChunk)
		} else {
			r.updateAuxColInChunk(inChunk)
		}
	}
	r.reset()
}

func (r *IntegerColIntegerSampleIterator) updateAuxColInChunk(inChunk Chunk) {
	if len(r.interBufIndex) == 0 {
		r.auxChunk.Reset()
	}
	r.currBufIndex = r.currBufIndex[:0]
	for i := range r.buf.items {
		r.currBufIndex = append(r.currBufIndex, r.buf.items[i].index-r.prevMaxIndex)
	}
	hybridqp.SortS1ByS2(r.windowIndex, r.currBufIndex)
	for j := range r.auxProcessor {
		r.auxProcessor[j].auxHelperFunc(
			inChunk.Column(r.auxProcessor[j].inOrdinal),
			r.auxChunk.Column(r.auxProcessor[j].outOrdinal),
			r.windowIndex...,
		)
	}
}

func (r *IntegerColIntegerSampleIterator) appendPrevItem(
	inChunk, outChunk Chunk,
) {
	for j := range r.buf.items {
		outChunk.AppendTime(r.buf.items[j].time)
		outChunk.Column(r.outOrdinal).AppendIntegerValues(r.buf.items[j].value)
		outChunk.Column(r.outOrdinal).AppendNilsV2(true)
	}
	if len(r.auxProcessor) > 0 {
		for j := range r.buf.items {
			r.windowIndex = append(r.windowIndex, j)
		}
		for j := range r.auxProcessor {
			r.auxProcessor[j].auxHelperFunc(
				r.auxChunk.Column(r.auxProcessor[j].outOrdinal),
				outChunk.Column(r.auxProcessor[j].outOrdinal),
				r.windowIndex...,
			)
		}
		r.windowIndex = r.windowIndex[:0]
		r.auxChunk.Reset()
	}
	outChunk.AppendIntervalIndex(outChunk.Len() - r.buf.Len())
}

func (r *IntegerColIntegerSampleIterator) processFirstWindow(
	inChunk, outChunk Chunk, sameInterval, haveMultiInterval bool, start, end int,
) {
	r.updatePrevItem(inChunk, start, end)
	if haveMultiInterval || !sameInterval {
		sort.Sort(r.buf)
		if r.buf.Len() > 0 {
			r.appendPrevItem(r.auxChunk, outChunk)
		}
		r.buf.Reset()
	}
}

func (r *IntegerColIntegerSampleIterator) updateCurrItem(
	inChunk Chunk, start, end int,
) {
	if len(r.auxProcessor) == 0 {
		r.buf.appendForFast(inChunk, start, end, r.inOrdinal, r.buf.maxIndex+1)
	} else {
		sort.Sort(r.buf)
		r.prevMaxIndex = r.buf.maxIndex + 1
		r.windowIndex = r.buf.appendForAux(inChunk, start, end, r.inOrdinal)
		for j := range r.auxProcessor {
			r.auxProcessor[j].auxHelperFunc(
				inChunk.Column(r.auxProcessor[j].inOrdinal),
				r.auxChunk.Column(r.auxProcessor[j].outOrdinal),
				r.windowIndex...,
			)
		}
		r.windowIndex = r.windowIndex[:0]
		r.currBufIndex = r.currBufIndex[:0]
	}
}

func (r *IntegerColIntegerSampleIterator) processLastWindow(
	inChunk Chunk, start, end int,
) {
	r.updateCurrItem(inChunk, start, end)
}

func (r *IntegerColIntegerSampleIterator) appendCurrItem(
	inChunk, outChunk Chunk, start int,
) {
	for j := range r.buf.items {
		outChunk.AppendTime(r.buf.items[j].time)
		outChunk.Column(r.outOrdinal).AppendIntegerValues(r.buf.items[j].value)
		outChunk.Column(r.outOrdinal).AppendNilsV2(true)
	}
	if len(r.auxProcessor) > 0 {
		for i := range r.buf.items {
			r.currBufIndex = append(r.currBufIndex, r.buf.items[i].index+start-r.prevMaxIndex)
		}
		hybridqp.SortS1ByS2(r.windowIndex, r.currBufIndex)
		for j := range r.auxProcessor {
			r.auxProcessor[j].auxHelperFunc(
				inChunk.Column(r.auxProcessor[j].inOrdinal),
				outChunk.Column(r.auxProcessor[j].outOrdinal),
				r.windowIndex...,
			)
		}
		r.windowIndex = r.windowIndex[:0]
		r.currBufIndex = r.currBufIndex[:0]
	}
	outChunk.AppendIntervalIndex(outChunk.Len() - r.buf.Len())
}

func (r *IntegerColIntegerSampleIterator) processMiddleWindow(
	inChunk, outChunk Chunk, start, end int,
) {
	if len(r.auxProcessor) == 0 {
		r.buf.appendForFast(inChunk, start, end, r.inOrdinal, r.buf.maxIndex+1)
	} else {
		r.prevMaxIndex = r.buf.maxIndex + 1
		r.windowIndex = r.buf.appendForAux(inChunk, start, end, r.inOrdinal)
	}
	sort.Sort(r.buf)
	if r.buf.Len() > 0 {
		r.appendCurrItem(inChunk, outChunk, start)
	}
	r.buf.Reset()
}

func (r *IntegerColIntegerSampleIterator) Next(ie *IteratorEndpoint, p *IteratorParams) {
	inChunk, outChunk := ie.InputPoint.Chunk, ie.OutputPoint.Chunk
	if inChunk.Column(r.inOrdinal).IsEmpty() && r.buf.Len() > 0 {
		return
	}
	var end int
	firstIndex, lastIndex := 0, len(inChunk.IntervalIndex())-1
	for i, start := range inChunk.IntervalIndex() {
		if i < lastIndex {
			end = inChunk.IntervalIndex()[i+1]
		} else {
			end = inChunk.NumberOfRows()
		}
		if i == firstIndex && r.buf.Len() > 0 {
			r.processFirstWindow(inChunk, outChunk, p.sameInterval,
				firstIndex != lastIndex, start, end)
		} else if i == lastIndex && p.sameInterval {
			r.processLastWindow(inChunk, start, end)
		} else {
			r.processMiddleWindow(inChunk, outChunk, start, end)
		}
	}
}

type StringColStringSampleIterator struct {
	sampleNum     int
	isSingleCall  bool
	inOrdinal     int
	outOrdinal    int
	prevMaxIndex  int
	buf           *StringSampleItem
	auxChunk      Chunk
	auxProcessor  []*AuxProcessor
	windowIndex   []int
	prevBufIndex  []int
	currBufIndex  []int
	interBufIndex []int
}

func NewStringSampleItem(items []StringPointItem) *StringSampleItem {
	return &StringSampleItem{
		items: items,
	}
}

func NewStringColStringSampleIterator(sampleNum int,
	isSingleCall bool, inOrdinal, outOrdinal int, auxProcessor []*AuxProcessor, rowDataType hybridqp.RowDataType,
) *StringColStringSampleIterator {
	r := &StringColStringSampleIterator{
		buf:          NewStringSampleItem(make([]StringPointItem, 0, sampleNum)),
		sampleNum:    sampleNum,
		isSingleCall: isSingleCall,
		inOrdinal:    inOrdinal,
		outOrdinal:   outOrdinal,
	}
	if isSingleCall && len(auxProcessor) > 0 {
		r.auxProcessor = auxProcessor
		r.auxChunk = NewChunkBuilder(rowDataType).NewChunk("")
	}
	return r
}

func (r *StringColStringSampleIterator) reset() {
	r.prevBufIndex = r.prevBufIndex[:0]
	r.currBufIndex = r.currBufIndex[:0]
	r.interBufIndex = r.interBufIndex[:0]
	r.windowIndex = r.windowIndex[:0]
}

func (r *StringColStringSampleIterator) updateAuxColBothChunk(inChunk Chunk) {
	clone := r.auxChunk.Clone()
	r.auxChunk.Reset()
	sort.Ints(r.interBufIndex)
	r.currBufIndex = r.currBufIndex[:0]
	for i := range r.prevBufIndex {
		if hybridqp.BinarySearch(r.prevBufIndex[i], r.interBufIndex) {
			r.currBufIndex = append(r.currBufIndex, i)
		}
	}
	r.prevBufIndex = r.prevBufIndex[:0]
	for i := range r.buf.items {
		r.prevBufIndex = append(r.prevBufIndex, r.buf.items[i].index-r.prevMaxIndex)
	}
	hybridqp.SortS1ByS2(r.windowIndex, r.prevBufIndex)
	cs, ws := 0, 0
	for i := range r.buf.items {
		if hybridqp.BinarySearch(r.buf.items[i].index, r.interBufIndex) {
			for j := range r.auxProcessor {
				r.auxProcessor[j].auxHelperFunc(
					clone.Column(r.auxProcessor[j].outOrdinal),
					r.auxChunk.Column(r.auxProcessor[j].outOrdinal),
					r.currBufIndex[cs],
				)
			}
			cs++
		} else {
			for j := range r.auxProcessor {
				r.auxProcessor[j].auxHelperFunc(
					inChunk.Column(r.auxProcessor[j].inOrdinal),
					r.auxChunk.Column(r.auxProcessor[j].outOrdinal),
					r.windowIndex[ws],
				)
			}
			ws++
		}
	}
	clone.Reset()
}

func (r *StringColStringSampleIterator) updatePrevItem(
	inChunk Chunk, start, end int,
) {
	if len(r.auxProcessor) == 0 {
		r.buf.appendForFast(inChunk, start, end, r.inOrdinal, r.buf.maxIndex+1)
	} else {
		sort.Sort(r.buf)
		for i := range r.buf.items {
			r.prevBufIndex = append(r.prevBufIndex, r.buf.items[i].index)
		}
		r.prevMaxIndex = r.buf.maxIndex + 1
		r.windowIndex = r.buf.appendForAux(inChunk, start, end, r.inOrdinal)
		for i := range r.buf.items {
			r.currBufIndex = append(r.currBufIndex, r.buf.items[i].index)
		}
		r.interBufIndex = hybridqp.Intersect(r.prevBufIndex, r.currBufIndex)
		sort.Sort(r.buf)
		if !hybridqp.CompareSlice(r.interBufIndex, r.prevBufIndex) {
			r.updateAuxColBothChunk(inChunk)
		} else {
			r.updateAuxColInChunk(inChunk)
		}
	}
	r.reset()
}

func (r *StringColStringSampleIterator) updateAuxColInChunk(inChunk Chunk) {
	if len(r.interBufIndex) == 0 {
		r.auxChunk.Reset()
	}
	r.currBufIndex = r.currBufIndex[:0]
	for i := range r.buf.items {
		r.currBufIndex = append(r.currBufIndex, r.buf.items[i].index-r.prevMaxIndex)
	}
	hybridqp.SortS1ByS2(r.windowIndex, r.currBufIndex)
	for j := range r.auxProcessor {
		r.auxProcessor[j].auxHelperFunc(
			inChunk.Column(r.auxProcessor[j].inOrdinal),
			r.auxChunk.Column(r.auxProcessor[j].outOrdinal),
			r.windowIndex...,
		)
	}
}

func (r *StringColStringSampleIterator) appendPrevItem(
	inChunk, outChunk Chunk,
) {
	for j := range r.buf.items {
		outChunk.AppendTime(r.buf.items[j].time)
		outChunk.Column(r.outOrdinal).AppendStringValues(r.buf.items[j].value)
		outChunk.Column(r.outOrdinal).AppendNilsV2(true)
	}
	if len(r.auxProcessor) > 0 {
		for j := range r.buf.items {
			r.windowIndex = append(r.windowIndex, j)
		}
		for j := range r.auxProcessor {
			r.auxProcessor[j].auxHelperFunc(
				r.auxChunk.Column(r.auxProcessor[j].outOrdinal),
				outChunk.Column(r.auxProcessor[j].outOrdinal),
				r.windowIndex...,
			)
		}
		r.windowIndex = r.windowIndex[:0]
		r.auxChunk.Reset()
	}
	outChunk.AppendIntervalIndex(outChunk.Len() - r.buf.Len())
}

func (r *StringColStringSampleIterator) processFirstWindow(
	inChunk, outChunk Chunk, sameInterval, haveMultiInterval bool, start, end int,
) {
	r.updatePrevItem(inChunk, start, end)
	if haveMultiInterval || !sameInterval {
		sort.Sort(r.buf)
		if r.buf.Len() > 0 {
			r.appendPrevItem(r.auxChunk, outChunk)
		}
		r.buf.Reset()
	}
}

func (r *StringColStringSampleIterator) updateCurrItem(
	inChunk Chunk, start, end int,
) {
	if len(r.auxProcessor) == 0 {
		r.buf.appendForFast(inChunk, start, end, r.inOrdinal, r.buf.maxIndex+1)
	} else {
		sort.Sort(r.buf)
		r.prevMaxIndex = r.buf.maxIndex + 1
		r.windowIndex = r.buf.appendForAux(inChunk, start, end, r.inOrdinal)
		for j := range r.auxProcessor {
			r.auxProcessor[j].auxHelperFunc(
				inChunk.Column(r.auxProcessor[j].inOrdinal),
				r.auxChunk.Column(r.auxProcessor[j].outOrdinal),
				r.windowIndex...,
			)
		}
		r.windowIndex = r.windowIndex[:0]
		r.currBufIndex = r.currBufIndex[:0]
	}
}

func (r *StringColStringSampleIterator) processLastWindow(
	inChunk Chunk, start, end int,
) {
	r.updateCurrItem(inChunk, start, end)
}

func (r *StringColStringSampleIterator) appendCurrItem(
	inChunk, outChunk Chunk, start int,
) {
	for j := range r.buf.items {
		outChunk.AppendTime(r.buf.items[j].time)
		outChunk.Column(r.outOrdinal).AppendStringValues(r.buf.items[j].value)
		outChunk.Column(r.outOrdinal).AppendNilsV2(true)
	}
	if len(r.auxProcessor) > 0 {
		for i := range r.buf.items {
			r.currBufIndex = append(r.currBufIndex, r.buf.items[i].index+start-r.prevMaxIndex)
		}
		hybridqp.SortS1ByS2(r.windowIndex, r.currBufIndex)
		for j := range r.auxProcessor {
			r.auxProcessor[j].auxHelperFunc(
				inChunk.Column(r.auxProcessor[j].inOrdinal),
				outChunk.Column(r.auxProcessor[j].outOrdinal),
				r.windowIndex...,
			)
		}
		r.windowIndex = r.windowIndex[:0]
		r.currBufIndex = r.currBufIndex[:0]
	}
	outChunk.AppendIntervalIndex(outChunk.Len() - r.buf.Len())
}

func (r *StringColStringSampleIterator) processMiddleWindow(
	inChunk, outChunk Chunk, start, end int,
) {
	if len(r.auxProcessor) == 0 {
		r.buf.appendForFast(inChunk, start, end, r.inOrdinal, r.buf.maxIndex+1)
	} else {
		r.prevMaxIndex = r.buf.maxIndex + 1
		r.windowIndex = r.buf.appendForAux(inChunk, start, end, r.inOrdinal)
	}
	sort.Sort(r.buf)
	if r.buf.Len() > 0 {
		r.appendCurrItem(inChunk, outChunk, start)
	}
	r.buf.Reset()
}

func (r *StringColStringSampleIterator) Next(ie *IteratorEndpoint, p *IteratorParams) {
	inChunk, outChunk := ie.InputPoint.Chunk, ie.OutputPoint.Chunk
	if inChunk.Column(r.inOrdinal).IsEmpty() && r.buf.Len() > 0 {
		return
	}
	var end int
	firstIndex, lastIndex := 0, len(inChunk.IntervalIndex())-1
	for i, start := range inChunk.IntervalIndex() {
		if i < lastIndex {
			end = inChunk.IntervalIndex()[i+1]
		} else {
			end = inChunk.NumberOfRows()
		}
		if i == firstIndex && r.buf.Len() > 0 {
			r.processFirstWindow(inChunk, outChunk, p.sameInterval,
				firstIndex != lastIndex, start, end)
		} else if i == lastIndex && p.sameInterval {
			r.processLastWindow(inChunk, start, end)
		} else {
			r.processMiddleWindow(inChunk, outChunk, start, end)
		}
	}
}

type BooleanColBooleanSampleIterator struct {
	sampleNum     int
	isSingleCall  bool
	inOrdinal     int
	outOrdinal    int
	prevMaxIndex  int
	buf           *BooleanSampleItem
	auxChunk      Chunk
	auxProcessor  []*AuxProcessor
	windowIndex   []int
	prevBufIndex  []int
	currBufIndex  []int
	interBufIndex []int
}

func NewBooleanSampleItem(items []BooleanPointItem) *BooleanSampleItem {
	return &BooleanSampleItem{
		items: items,
	}
}

func NewBooleanColBooleanSampleIterator(sampleNum int,
	isSingleCall bool, inOrdinal, outOrdinal int, auxProcessor []*AuxProcessor, rowDataType hybridqp.RowDataType,
) *BooleanColBooleanSampleIterator {
	r := &BooleanColBooleanSampleIterator{
		buf:          NewBooleanSampleItem(make([]BooleanPointItem, 0, sampleNum)),
		sampleNum:    sampleNum,
		isSingleCall: isSingleCall,
		inOrdinal:    inOrdinal,
		outOrdinal:   outOrdinal,
	}
	if isSingleCall && len(auxProcessor) > 0 {
		r.auxProcessor = auxProcessor
		r.auxChunk = NewChunkBuilder(rowDataType).NewChunk("")
	}
	return r
}

func (r *BooleanColBooleanSampleIterator) reset() {
	r.prevBufIndex = r.prevBufIndex[:0]
	r.currBufIndex = r.currBufIndex[:0]
	r.interBufIndex = r.interBufIndex[:0]
	r.windowIndex = r.windowIndex[:0]
}

func (r *BooleanColBooleanSampleIterator) updateAuxColBothChunk(inChunk Chunk) {
	clone := r.auxChunk.Clone()
	r.auxChunk.Reset()
	sort.Ints(r.interBufIndex)
	r.currBufIndex = r.currBufIndex[:0]
	for i := range r.prevBufIndex {
		if hybridqp.BinarySearch(r.prevBufIndex[i], r.interBufIndex) {
			r.currBufIndex = append(r.currBufIndex, i)
		}
	}
	r.prevBufIndex = r.prevBufIndex[:0]
	for i := range r.buf.items {
		r.prevBufIndex = append(r.prevBufIndex, r.buf.items[i].index-r.prevMaxIndex)
	}
	hybridqp.SortS1ByS2(r.windowIndex, r.prevBufIndex)
	cs, ws := 0, 0
	for i := range r.buf.items {
		if hybridqp.BinarySearch(r.buf.items[i].index, r.interBufIndex) {
			for j := range r.auxProcessor {
				r.auxProcessor[j].auxHelperFunc(
					clone.Column(r.auxProcessor[j].outOrdinal),
					r.auxChunk.Column(r.auxProcessor[j].outOrdinal),
					r.currBufIndex[cs],
				)
			}
			cs++
		} else {
			for j := range r.auxProcessor {
				r.auxProcessor[j].auxHelperFunc(
					inChunk.Column(r.auxProcessor[j].inOrdinal),
					r.auxChunk.Column(r.auxProcessor[j].outOrdinal),
					r.windowIndex[ws],
				)
			}
			ws++
		}
	}
	clone.Reset()
}

func (r *BooleanColBooleanSampleIterator) updatePrevItem(
	inChunk Chunk, start, end int,
) {
	if len(r.auxProcessor) == 0 {
		r.buf.appendForFast(inChunk, start, end, r.inOrdinal, r.buf.maxIndex+1)
	} else {
		sort.Sort(r.buf)
		for i := range r.buf.items {
			r.prevBufIndex = append(r.prevBufIndex, r.buf.items[i].index)
		}
		r.prevMaxIndex = r.buf.maxIndex + 1
		r.windowIndex = r.buf.appendForAux(inChunk, start, end, r.inOrdinal)
		for i := range r.buf.items {
			r.currBufIndex = append(r.currBufIndex, r.buf.items[i].index)
		}
		r.interBufIndex = hybridqp.Intersect(r.prevBufIndex, r.currBufIndex)
		sort.Sort(r.buf)
		if !hybridqp.CompareSlice(r.interBufIndex, r.prevBufIndex) {
			r.updateAuxColBothChunk(inChunk)
		} else {
			r.updateAuxColInChunk(inChunk)
		}
	}
	r.reset()
}

func (r *BooleanColBooleanSampleIterator) updateAuxColInChunk(inChunk Chunk) {
	if len(r.interBufIndex) == 0 {
		r.auxChunk.Reset()
	}
	r.currBufIndex = r.currBufIndex[:0]
	for i := range r.buf.items {
		r.currBufIndex = append(r.currBufIndex, r.buf.items[i].index-r.prevMaxIndex)
	}
	hybridqp.SortS1ByS2(r.windowIndex, r.currBufIndex)
	for j := range r.auxProcessor {
		r.auxProcessor[j].auxHelperFunc(
			inChunk.Column(r.auxProcessor[j].inOrdinal),
			r.auxChunk.Column(r.auxProcessor[j].outOrdinal),
			r.windowIndex...,
		)
	}
}

func (r *BooleanColBooleanSampleIterator) appendPrevItem(
	inChunk, outChunk Chunk,
) {
	for j := range r.buf.items {
		outChunk.AppendTime(r.buf.items[j].time)
		outChunk.Column(r.outOrdinal).AppendBooleanValues(r.buf.items[j].value)
		outChunk.Column(r.outOrdinal).AppendNilsV2(true)
	}
	if len(r.auxProcessor) > 0 {
		for j := range r.buf.items {
			r.windowIndex = append(r.windowIndex, j)
		}
		for j := range r.auxProcessor {
			r.auxProcessor[j].auxHelperFunc(
				r.auxChunk.Column(r.auxProcessor[j].outOrdinal),
				outChunk.Column(r.auxProcessor[j].outOrdinal),
				r.windowIndex...,
			)
		}
		r.windowIndex = r.windowIndex[:0]
		r.auxChunk.Reset()
	}
	outChunk.AppendIntervalIndex(outChunk.Len() - r.buf.Len())
}

func (r *BooleanColBooleanSampleIterator) processFirstWindow(
	inChunk, outChunk Chunk, sameInterval, haveMultiInterval bool, start, end int,
) {
	r.updatePrevItem(inChunk, start, end)
	if haveMultiInterval || !sameInterval {
		sort.Sort(r.buf)
		if r.buf.Len() > 0 {
			r.appendPrevItem(r.auxChunk, outChunk)
		}
		r.buf.Reset()
	}
}

func (r *BooleanColBooleanSampleIterator) updateCurrItem(
	inChunk Chunk, start, end int,
) {
	if len(r.auxProcessor) == 0 {
		r.buf.appendForFast(inChunk, start, end, r.inOrdinal, r.buf.maxIndex+1)
	} else {
		sort.Sort(r.buf)
		r.prevMaxIndex = r.buf.maxIndex + 1
		r.windowIndex = r.buf.appendForAux(inChunk, start, end, r.inOrdinal)
		for j := range r.auxProcessor {
			r.auxProcessor[j].auxHelperFunc(
				inChunk.Column(r.auxProcessor[j].inOrdinal),
				r.auxChunk.Column(r.auxProcessor[j].outOrdinal),
				r.windowIndex...,
			)
		}
		r.windowIndex = r.windowIndex[:0]
		r.currBufIndex = r.currBufIndex[:0]
	}
}

func (r *BooleanColBooleanSampleIterator) processLastWindow(
	inChunk Chunk, start, end int,
) {
	r.updateCurrItem(inChunk, start, end)
}

func (r *BooleanColBooleanSampleIterator) appendCurrItem(
	inChunk, outChunk Chunk, start int,
) {
	for j := range r.buf.items {
		outChunk.AppendTime(r.buf.items[j].time)
		outChunk.Column(r.outOrdinal).AppendBooleanValues(r.buf.items[j].value)
		outChunk.Column(r.outOrdinal).AppendNilsV2(true)
	}
	if len(r.auxProcessor) > 0 {
		for i := range r.buf.items {
			r.currBufIndex = append(r.currBufIndex, r.buf.items[i].index+start-r.prevMaxIndex)
		}
		hybridqp.SortS1ByS2(r.windowIndex, r.currBufIndex)
		for j := range r.auxProcessor {
			r.auxProcessor[j].auxHelperFunc(
				inChunk.Column(r.auxProcessor[j].inOrdinal),
				outChunk.Column(r.auxProcessor[j].outOrdinal),
				r.windowIndex...,
			)
		}
		r.windowIndex = r.windowIndex[:0]
		r.currBufIndex = r.currBufIndex[:0]
	}
	outChunk.AppendIntervalIndex(outChunk.Len() - r.buf.Len())
}

func (r *BooleanColBooleanSampleIterator) processMiddleWindow(
	inChunk, outChunk Chunk, start, end int,
) {
	if len(r.auxProcessor) == 0 {
		r.buf.appendForFast(inChunk, start, end, r.inOrdinal, r.buf.maxIndex+1)
	} else {
		r.prevMaxIndex = r.buf.maxIndex + 1
		r.windowIndex = r.buf.appendForAux(inChunk, start, end, r.inOrdinal)
	}
	sort.Sort(r.buf)
	if r.buf.Len() > 0 {
		r.appendCurrItem(inChunk, outChunk, start)
	}
	r.buf.Reset()
}

func (r *BooleanColBooleanSampleIterator) Next(ie *IteratorEndpoint, p *IteratorParams) {
	inChunk, outChunk := ie.InputPoint.Chunk, ie.OutputPoint.Chunk
	if inChunk.Column(r.inOrdinal).IsEmpty() && r.buf.Len() > 0 {
		return
	}
	var end int
	firstIndex, lastIndex := 0, len(inChunk.IntervalIndex())-1
	for i, start := range inChunk.IntervalIndex() {
		if i < lastIndex {
			end = inChunk.IntervalIndex()[i+1]
		} else {
			end = inChunk.NumberOfRows()
		}
		if i == firstIndex && r.buf.Len() > 0 {
			r.processFirstWindow(inChunk, outChunk, p.sameInterval,
				firstIndex != lastIndex, start, end)
		} else if i == lastIndex && p.sameInterval {
			r.processLastWindow(inChunk, start, end)
		} else {
			r.processMiddleWindow(inChunk, outChunk, start, end)
		}
	}
}

type StringPointItem struct {
	time  int64
	value string
	index int
}

func NewStringPointItem(time int64, value string) *StringPointItem {
	return &StringPointItem{
		time:  time,
		value: value,
	}
}

type BooleanPointItem struct {
	time  int64
	value bool
	index int
}

func NewBooleanPointItem(time int64, value bool) *BooleanPointItem {
	return &BooleanPointItem{
		time:  time,
		value: value,
	}
}

type FloatSlidingWindow struct {
	isNil      bool
	slidingNum int
	points     []*FloatPoint
}

func NewFloatSlidingWindow(slidingNum int) *FloatSlidingWindow {
	sw := &FloatSlidingWindow{
		isNil:      true,
		slidingNum: slidingNum,
	}
	for i := 0; i < slidingNum; i++ {
		sw.points = append(sw.points, newFloatPoint())
	}
	return sw
}

func (w *FloatSlidingWindow) Len() int {
	return w.slidingNum
}

func (w *FloatSlidingWindow) IsNil() bool {
	return w.isNil
}

func (w *FloatSlidingWindow) SetPoint(value float64, isNil bool, index int) {
	w.points[index].value = value
	w.points[index].isNil = isNil
	if index == w.slidingNum-1 {
		w.isNil = false
	}
}

func (w *FloatSlidingWindow) Reset() {
	w.isNil = true
}

type IntegerSlidingWindow struct {
	isNil      bool
	slidingNum int
	points     []*IntegerPoint
}

func NewIntegerSlidingWindow(slidingNum int) *IntegerSlidingWindow {
	sw := &IntegerSlidingWindow{
		isNil:      true,
		slidingNum: slidingNum,
	}
	for i := 0; i < slidingNum; i++ {
		sw.points = append(sw.points, newIntegerPoint())
	}
	return sw
}

func (w *IntegerSlidingWindow) Len() int {
	return w.slidingNum
}

func (w *IntegerSlidingWindow) IsNil() bool {
	return w.isNil
}

func (w *IntegerSlidingWindow) SetPoint(value int64, isNil bool, index int) {
	w.points[index].value = value
	w.points[index].isNil = isNil
	if index == w.slidingNum-1 {
		w.isNil = false
	}
}

func (w *IntegerSlidingWindow) Reset() {
	w.isNil = true
}

type BooleanSlidingWindow struct {
	isNil      bool
	slidingNum int
	points     []*BooleanPoint
}

func NewBooleanSlidingWindow(slidingNum int) *BooleanSlidingWindow {
	sw := &BooleanSlidingWindow{
		isNil:      true,
		slidingNum: slidingNum,
	}
	for i := 0; i < slidingNum; i++ {
		sw.points = append(sw.points, newBooleanPoint())
	}
	return sw
}

func (w *BooleanSlidingWindow) Len() int {
	return w.slidingNum
}

func (w *BooleanSlidingWindow) IsNil() bool {
	return w.isNil
}

func (w *BooleanSlidingWindow) SetPoint(value bool, isNil bool, index int) {
	w.points[index].value = value
	w.points[index].isNil = isNil
	if index == w.slidingNum-1 {
		w.isNil = false
	}
}

func (w *BooleanSlidingWindow) Reset() {
	w.isNil = true
}

type FloatColFloatWindowReduce func(c Chunk, ordinal, start, end int) (index int, value float64, isNil bool)

type FloatPointMerge func(prevPoint, currPoint *FloatPoint)

type FloatWindowMerge func(prevWindow, currWindow *FloatSlidingWindow, fpm FloatPointMerge)

type FloatSlidingWindowFloatIterator struct {
	slidingNum int
	inOrdinal  int
	outOrdinal int
	prevWindow *FloatSlidingWindow
	currWindow *FloatSlidingWindow
	fwr        FloatColFloatWindowReduce
	fpm        FloatPointMerge
	fwm        FloatWindowMerge
}

func NewFloatSlidingWindowFloatIterator(
	fwr FloatColFloatWindowReduce,
	fpm FloatPointMerge,
	fwm FloatWindowMerge,
	inOrdinal, outOrdinal int, slidingNum int,
) *FloatSlidingWindowFloatIterator {
	r := &FloatSlidingWindowFloatIterator{
		fwr:        fwr,
		fpm:        fpm,
		fwm:        fwm,
		slidingNum: slidingNum,
		inOrdinal:  inOrdinal,
		outOrdinal: outOrdinal,
		prevWindow: NewFloatSlidingWindow(slidingNum),
		currWindow: NewFloatSlidingWindow(slidingNum),
	}
	return r
}

func (r *FloatSlidingWindowFloatIterator) mergePrevWindow(
	outChunk Chunk,
) {
	for i := 0; i < r.slidingNum; i++ {
		if r.prevWindow.points[i].isNil {
			outChunk.Column(r.outOrdinal).AppendNilsV2(false)
		} else {
			outChunk.Column(r.outOrdinal).AppendNilsV2(true)
			outChunk.Column(r.outOrdinal).AppendFloatValues(r.prevWindow.points[i].value)
		}
	}
}

func (r *FloatSlidingWindowFloatIterator) processFirstWindow(
	outChunk Chunk, value float64, isNil, sameTag, onlyOneWindow bool, n int,
) {
	r.currWindow.SetPoint(value, isNil, n)
	if n < r.slidingNum-1 {
		return
	}
	r.fwm(r.prevWindow, r.currWindow, r.fpm)
	if !onlyOneWindow || !sameTag {
		r.mergePrevWindow(outChunk)
		r.prevWindow.Reset()
	}
	r.currWindow.Reset()
}

func (r *FloatSlidingWindowFloatIterator) processLastWindow(
	value float64, isNil bool, index int,
) {
	r.prevWindow.SetPoint(value, isNil, index)
}

func (r *FloatSlidingWindowFloatIterator) processMiddleWindow(
	outChunk Chunk, value float64, isNil bool,
) {
	if isNil {
		outChunk.Column(r.outOrdinal).AppendNilsV2(false)
	} else {
		outChunk.Column(r.outOrdinal).AppendNilsV2(true)
		outChunk.Column(r.outOrdinal).AppendFloatValues(value)
	}
}

func (r *FloatSlidingWindowFloatIterator) Next(ie *IteratorEndpoint, p *IteratorParams) {
	var (
		start, end int
		value      float64
		isNil      bool
	)
	firstIndex, lastIndex := 0, len(p.winIdx)/r.slidingNum-1
	inChunk, outChunk := ie.InputPoint.Chunk, ie.OutputPoint.Chunk
	for i := range p.winIdx {
		m, n := i/r.slidingNum, i%r.slidingNum
		start, end = p.winIdx[i][0], p.winIdx[i][1]
		if start == -1 || end == -1 || start >= end {
			value, isNil = 0, true
		} else {
			_, value, isNil = r.fwr(inChunk, r.inOrdinal, start, end)
		}
		if m == firstIndex && !r.prevWindow.IsNil() {
			r.processFirstWindow(outChunk, value, isNil,
				p.sameTag, firstIndex == lastIndex, n)
		} else if m == lastIndex && p.sameTag {
			r.processLastWindow(value, isNil, n)
		} else {
			r.processMiddleWindow(outChunk, value, isNil)
		}
	}
}

type BooleanColBooleanWindowReduce func(c Chunk, ordinal, start, end int) (index int, value bool, isNil bool)

type BooleanPointMerge func(prevPoint, currPoint *BooleanPoint)

type BooleanWindowMerge func(prevWindow, currWindow *BooleanSlidingWindow, fpm BooleanPointMerge)

type BooleanSlidingWindowBooleanIterator struct {
	slidingNum int
	inOrdinal  int
	outOrdinal int
	prevWindow *BooleanSlidingWindow
	currWindow *BooleanSlidingWindow
	fwr        BooleanColBooleanWindowReduce
	fpm        BooleanPointMerge
	fwm        BooleanWindowMerge
}

func NewBooleanSlidingWindowBooleanIterator(
	fwr BooleanColBooleanWindowReduce,
	fpm BooleanPointMerge,
	fwm BooleanWindowMerge,
	inOrdinal, outOrdinal int, slidingNum int,
) *BooleanSlidingWindowBooleanIterator {
	r := &BooleanSlidingWindowBooleanIterator{
		fwr:        fwr,
		fpm:        fpm,
		fwm:        fwm,
		slidingNum: slidingNum,
		inOrdinal:  inOrdinal,
		outOrdinal: outOrdinal,
		prevWindow: NewBooleanSlidingWindow(slidingNum),
		currWindow: NewBooleanSlidingWindow(slidingNum),
	}
	return r
}

func (r *BooleanSlidingWindowBooleanIterator) mergePrevWindow(
	outChunk Chunk,
) {
	for i := 0; i < r.slidingNum; i++ {
		if r.prevWindow.points[i].isNil {
			outChunk.Column(r.outOrdinal).AppendNilsV2(false)
		} else {
			outChunk.Column(r.outOrdinal).AppendNilsV2(true)
			outChunk.Column(r.outOrdinal).AppendBooleanValues(r.prevWindow.points[i].value)
		}
	}
}

func (r *BooleanSlidingWindowBooleanIterator) processFirstWindow(
	outChunk Chunk, value bool, isNil, sameTag, onlyOneWindow bool, n int,
) {
	r.currWindow.SetPoint(value, isNil, n)
	if n < r.slidingNum-1 {
		return
	}
	r.fwm(r.prevWindow, r.currWindow, r.fpm)
	if !onlyOneWindow || !sameTag {
		r.mergePrevWindow(outChunk)
		r.prevWindow.Reset()
	}
	r.currWindow.Reset()
}

func (r *BooleanSlidingWindowBooleanIterator) processLastWindow(
	value bool, isNil bool, index int,
) {
	r.prevWindow.SetPoint(value, isNil, index)
}

func (r *BooleanSlidingWindowBooleanIterator) processMiddleWindow(
	outChunk Chunk, value bool, isNil bool,
) {
	if isNil {
		outChunk.Column(r.outOrdinal).AppendNilsV2(false)
	} else {
		outChunk.Column(r.outOrdinal).AppendNilsV2(true)
		outChunk.Column(r.outOrdinal).AppendBooleanValues(value)
	}
}

func (r *BooleanSlidingWindowBooleanIterator) Next(ie *IteratorEndpoint, p *IteratorParams) {
	var (
		start, end int
		value      bool
		isNil      bool
	)
	firstIndex, lastIndex := 0, len(p.winIdx)/r.slidingNum-1
	inChunk, outChunk := ie.InputPoint.Chunk, ie.OutputPoint.Chunk
	for i := range p.winIdx {
		m, n := i/r.slidingNum, i%r.slidingNum
		start, end = p.winIdx[i][0], p.winIdx[i][1]
		if start == -1 || end == -1 || start >= end {
			value, isNil = false, true
		} else {
			_, value, isNil = r.fwr(inChunk, r.inOrdinal, start, end)
		}
		if m == firstIndex && !r.prevWindow.IsNil() {
			r.processFirstWindow(outChunk, value, isNil,
				p.sameTag, firstIndex == lastIndex, n)
		} else if m == lastIndex && p.sameTag {
			r.processLastWindow(value, isNil, n)
		} else {
			r.processMiddleWindow(outChunk, value, isNil)
		}
	}
}

type IntegerPointMerge func(prevPoint, currPoint *IntegerPoint)

type IntegerWindowMerge func(prevWindow, currWindow *IntegerSlidingWindow, fpm IntegerPointMerge)

type IntegerColIntegerWindowReduce func(c Chunk, ordinal, start, end int) (index int, value int64, isNil bool)

type IntegerSlidingWindowIntegerIterator struct {
	slidingNum int
	inOrdinal  int
	outOrdinal int
	prevWindow *IntegerSlidingWindow
	currWindow *IntegerSlidingWindow
	fwr        IntegerColIntegerWindowReduce
	fpm        IntegerPointMerge
	fwm        IntegerWindowMerge
}

func NewIntegerSlidingWindowIntegerIterator(
	fwr IntegerColIntegerWindowReduce,
	fpm IntegerPointMerge,
	fwm IntegerWindowMerge,
	inOrdinal, outOrdinal int, slidingNum int,
) *IntegerSlidingWindowIntegerIterator {
	r := &IntegerSlidingWindowIntegerIterator{
		fwr:        fwr,
		fpm:        fpm,
		fwm:        fwm,
		slidingNum: slidingNum,
		inOrdinal:  inOrdinal,
		outOrdinal: outOrdinal,
		prevWindow: NewIntegerSlidingWindow(slidingNum),
		currWindow: NewIntegerSlidingWindow(slidingNum),
	}
	return r
}

func (r *IntegerSlidingWindowIntegerIterator) mergePrevWindow(
	outChunk Chunk,
) {
	for i := 0; i < r.slidingNum; i++ {
		if r.prevWindow.points[i].isNil {
			outChunk.Column(r.outOrdinal).AppendNilsV2(false)
		} else {
			outChunk.Column(r.outOrdinal).AppendNilsV2(true)
			outChunk.Column(r.outOrdinal).AppendIntegerValues(r.prevWindow.points[i].value)
		}
	}
}

func (r *IntegerSlidingWindowIntegerIterator) processFirstWindow(
	outChunk Chunk, value int64, isNil, sameTag, onlyOneWindow bool, n int,
) {
	r.currWindow.SetPoint(value, isNil, n)
	if n < r.slidingNum-1 {
		return
	}
	r.fwm(r.prevWindow, r.currWindow, r.fpm)
	if !onlyOneWindow || !sameTag {
		r.mergePrevWindow(outChunk)
		r.prevWindow.Reset()
	}
	r.currWindow.Reset()
}

func (r *IntegerSlidingWindowIntegerIterator) processLastWindow(
	value int64, isNil bool, index int,
) {
	r.prevWindow.SetPoint(value, isNil, index)
}

func (r *IntegerSlidingWindowIntegerIterator) processMiddleWindow(
	outChunk Chunk, value int64, isNil bool,
) {
	if isNil {
		outChunk.Column(r.outOrdinal).AppendNilsV2(false)
	} else {
		outChunk.Column(r.outOrdinal).AppendNilsV2(true)
		outChunk.Column(r.outOrdinal).AppendIntegerValues(value)
	}
}

func (r *IntegerSlidingWindowIntegerIterator) Next(ie *IteratorEndpoint, p *IteratorParams) {
	var (
		start, end int
		value      int64
		isNil      bool
	)
	firstIndex, lastIndex := 0, len(p.winIdx)/r.slidingNum-1
	inChunk, outChunk := ie.InputPoint.Chunk, ie.OutputPoint.Chunk
	for i := range p.winIdx {
		m, n := i/r.slidingNum, i%r.slidingNum
		start, end = p.winIdx[i][0], p.winIdx[i][1]
		if start == -1 || end == -1 || start >= end {
			value, isNil = 0, true
		} else {
			_, value, isNil = r.fwr(inChunk, r.inOrdinal, start, end)
		}
		if m == firstIndex && !r.prevWindow.IsNil() {
			r.processFirstWindow(outChunk, value, isNil,
				p.sameTag, firstIndex == lastIndex, n)
		} else if m == lastIndex && p.sameTag {
			r.processLastWindow(value, isNil, n)
		} else {
			r.processMiddleWindow(outChunk, value, isNil)
		}
	}
}

type BooleanColIntegerWindowReduce func(c Chunk, ordinal, start, end int) (index int, value int64, isNil bool)

type BooleanSlidingWindowIntegerIterator struct {
	slidingNum int
	inOrdinal  int
	outOrdinal int
	prevWindow *IntegerSlidingWindow
	currWindow *IntegerSlidingWindow
	fwr        BooleanColIntegerWindowReduce
	fpm        IntegerPointMerge
	fwm        IntegerWindowMerge
}

func NewBooleanSlidingWindowIntegerIterator(
	fwr BooleanColIntegerWindowReduce,
	fpm IntegerPointMerge,
	fwm IntegerWindowMerge,
	inOrdinal, outOrdinal int, slidingNum int,
) *BooleanSlidingWindowIntegerIterator {
	r := &BooleanSlidingWindowIntegerIterator{
		fwr:        fwr,
		fpm:        fpm,
		fwm:        fwm,
		slidingNum: slidingNum,
		inOrdinal:  inOrdinal,
		outOrdinal: outOrdinal,
		prevWindow: NewIntegerSlidingWindow(slidingNum),
		currWindow: NewIntegerSlidingWindow(slidingNum),
	}
	return r
}

func (r *BooleanSlidingWindowIntegerIterator) mergePrevWindow(
	outChunk Chunk,
) {
	for i := 0; i < r.slidingNum; i++ {
		if r.prevWindow.points[i].isNil {
			outChunk.Column(r.outOrdinal).AppendNilsV2(false)
		} else {
			outChunk.Column(r.outOrdinal).AppendNilsV2(true)
			outChunk.Column(r.outOrdinal).AppendIntegerValues(r.prevWindow.points[i].value)
		}
	}
}

func (r *BooleanSlidingWindowIntegerIterator) processFirstWindow(
	outChunk Chunk, value int64, isNil, sameTag, onlyOneWindow bool, n int,
) {
	r.currWindow.SetPoint(value, isNil, n)
	if n < r.slidingNum-1 {
		return
	}
	r.fwm(r.prevWindow, r.currWindow, r.fpm)
	if !onlyOneWindow || !sameTag {
		r.mergePrevWindow(outChunk)
		r.prevWindow.Reset()
	}
	r.currWindow.Reset()
}

func (r *BooleanSlidingWindowIntegerIterator) processLastWindow(
	value int64, isNil bool, index int,
) {
	r.prevWindow.SetPoint(value, isNil, index)
}

func (r *BooleanSlidingWindowIntegerIterator) processMiddleWindow(
	outChunk Chunk, value int64, isNil bool,
) {
	if isNil {
		outChunk.Column(r.outOrdinal).AppendNilsV2(false)
	} else {
		outChunk.Column(r.outOrdinal).AppendNilsV2(true)
		outChunk.Column(r.outOrdinal).AppendIntegerValues(value)
	}
}

func (r *BooleanSlidingWindowIntegerIterator) Next(ie *IteratorEndpoint, p *IteratorParams) {
	var (
		start, end int
		value      int64
		isNil      bool
	)
	firstIndex, lastIndex := 0, len(p.winIdx)/r.slidingNum-1
	inChunk, outChunk := ie.InputPoint.Chunk, ie.OutputPoint.Chunk
	for i := range p.winIdx {
		m, n := i/r.slidingNum, i%r.slidingNum
		start, end = p.winIdx[i][0], p.winIdx[i][1]
		if start == -1 || end == -1 || start >= end {
			value, isNil = 0, true
		} else {
			_, value, isNil = r.fwr(inChunk, r.inOrdinal, start, end)
		}
		if m == firstIndex && !r.prevWindow.IsNil() {
			r.processFirstWindow(outChunk, value, isNil,
				p.sameTag, firstIndex == lastIndex, n)
		} else if m == lastIndex && p.sameTag {
			r.processLastWindow(value, isNil, n)
		} else {
			r.processMiddleWindow(outChunk, value, isNil)
		}
	}
}

type OGSketchItem interface {
	UpdateCluster(inChunk Chunk, start, end int)
	WriteResult(outChunk Chunk, time int64)
	IsNil() bool
	Reset()
}

type FloatOGSketchInsertItem struct {
	isSingleCall bool
	inOrdinal    int
	outOrdinal   int
	clusterNum   int
	percentile   float64
	sketch       OGSketch
	clusters     ClusterSet
}

func NewFloatOGSketchInsertIem(isSingleCall bool, inOrdinal, outOrdinal, clusterNum int, percentile float64) *FloatOGSketchInsertItem {
	return &FloatOGSketchInsertItem{
		isSingleCall: isSingleCall,
		inOrdinal:    inOrdinal,
		outOrdinal:   outOrdinal,
		clusterNum:   clusterNum,
		percentile:   percentile,
		sketch:       NewOGSketchImpl(float64(clusterNum)),
	}
}

func (o *FloatOGSketchInsertItem) UpdateCluster(inChunk Chunk, start, end int) {
	o.sketch.InsertPoints(inChunk.Column(o.inOrdinal).FloatValues()[start:end]...)
}

func (o *FloatOGSketchInsertItem) WriteResult(outChunk Chunk, time int64) {
	o.clusters = o.sketch.Clusters()
	clusterNum := len(o.clusters)
	if o.isSingleCall {
		for i := 0; i < clusterNum; i++ {
			outChunk.AppendTime(time)
		}
		outChunk.AppendIntervalIndex(outChunk.Len() - clusterNum)
	}

	for i := 0; i < clusterNum; i++ {
		outChunk.Column(o.outOrdinal).AppendFloatTuples(floatTuple{values: []float64{o.clusters[i].Mean, o.clusters[i].Weight}})
	}
	outChunk.Column(o.outOrdinal).AppendManyNotNil(clusterNum)

	if !o.isSingleCall && o.clusterNum > clusterNum {
		outChunk.Column(o.outOrdinal).AppendManyNil(o.clusterNum - clusterNum)
	}
}

func (o *FloatOGSketchInsertItem) IsNil() bool {
	return o.sketch.Len() == 0
}

func (o *FloatOGSketchInsertItem) Reset() {
	o.sketch.Reset()
}

type FloatOGSketchPercentileItem struct {
	isSingleCall bool
	inOrdinal    int
	outOrdinal   int
	clusterNum   int
	percentile   float64
	sketch       OGSketch
}

func NewFloatOGSketchPercentileItem(isSingleCall bool, inOrdinal, outOrdinal, clusterNum int, percentile float64) *FloatOGSketchPercentileItem {
	return &FloatOGSketchPercentileItem{
		isSingleCall: isSingleCall,
		inOrdinal:    inOrdinal,
		outOrdinal:   outOrdinal,
		clusterNum:   clusterNum,
		percentile:   percentile,
		sketch:       NewOGSketchImpl(float64(clusterNum)),
	}
}

func (o *FloatOGSketchPercentileItem) UpdateCluster(inChunk Chunk, start, end int) {
	tuples := inChunk.Column(o.inOrdinal).FloatTuples()[start:end]
	o.sketch.InsertClusters(tuples...)

}

func (o *FloatOGSketchPercentileItem) WriteResult(outChunk Chunk, time int64) {
	value := o.sketch.Percentile(o.percentile)
	if o.isSingleCall {
		outChunk.AppendTime(time)
		outChunk.AppendIntervalIndex(outChunk.Len() - 1)
	}
	outChunk.Column(o.outOrdinal).AppendFloatValues(value)
	outChunk.Column(o.outOrdinal).AppendNilsV2(true)
}

func (o *FloatOGSketchPercentileItem) IsNil() bool {
	return o.sketch.Len() == 0
}

func (o *FloatOGSketchPercentileItem) Reset() {
	o.sketch.Reset()
}

type FloatPercentileApproxItem struct {
	isSingleCall bool
	inOrdinal    int
	outOrdinal   int
	clusterNum   int
	percentile   float64
	sketch       OGSketch
}

func NewFloatPercentileApproxItem(isSingleCall bool, inOrdinal, outOrdinal, clusterNum int, percentile float64) *FloatPercentileApproxItem {
	return &FloatPercentileApproxItem{
		isSingleCall: isSingleCall,
		inOrdinal:    inOrdinal,
		outOrdinal:   outOrdinal,
		clusterNum:   clusterNum,
		percentile:   percentile,
		sketch:       NewOGSketchImpl(float64(clusterNum)),
	}
}

func (o *FloatPercentileApproxItem) UpdateCluster(inChunk Chunk, start, end int) {
	o.sketch.InsertPoints(inChunk.Column(o.inOrdinal).FloatValues()[start:end]...)
}

func (o *FloatPercentileApproxItem) WriteResult(outChunk Chunk, time int64) {
	value := o.sketch.Percentile(o.percentile)
	if o.isSingleCall {
		outChunk.AppendTime(time)
		outChunk.AppendIntervalIndex(outChunk.Len() - 1)
	}
	outChunk.Column(o.outOrdinal).AppendFloatValues(value)
	outChunk.Column(o.outOrdinal).AppendNilsV2(true)
}

func (o *FloatPercentileApproxItem) IsNil() bool {
	return o.sketch.Len() == 0
}

func (o *FloatPercentileApproxItem) Reset() {
	o.sketch.Reset()
}

type IntegerOGSketchInsertItem struct {
	isSingleCall bool
	inOrdinal    int
	outOrdinal   int
	clusterNum   int
	percentile   float64
	sketch       OGSketch
	clusters     ClusterSet
}

func NewIntegerOGSketchInsertIem(isSingleCall bool, inOrdinal, outOrdinal, clusterNum int, percentile float64) *IntegerOGSketchInsertItem {
	return &IntegerOGSketchInsertItem{
		isSingleCall: isSingleCall,
		inOrdinal:    inOrdinal,
		outOrdinal:   outOrdinal,
		clusterNum:   clusterNum,
		percentile:   percentile,
		sketch:       NewOGSketchImpl(float64(clusterNum)),
	}
}

func (o *IntegerOGSketchInsertItem) UpdateCluster(inChunk Chunk, start, end int) {
	values := inChunk.Column(o.inOrdinal).IntegerValues()[start:end]
	for i := range values {
		o.sketch.InsertPoints(float64(values[i]))
	}
}

func (o *IntegerOGSketchInsertItem) WriteResult(outChunk Chunk, time int64) {
	o.clusters = o.sketch.Clusters()
	clusterNum := len(o.clusters)
	if o.isSingleCall {
		for i := 0; i < clusterNum; i++ {
			outChunk.AppendTime(time)
		}
		outChunk.AppendIntervalIndex(outChunk.Len() - clusterNum)
	}

	for i := 0; i < clusterNum; i++ {
		outChunk.Column(o.outOrdinal).AppendFloatTuples(floatTuple{values: []float64{o.clusters[i].Mean, o.clusters[i].Weight}})
	}
	outChunk.Column(o.outOrdinal).AppendManyNotNil(clusterNum)

	if !o.isSingleCall && o.clusterNum > clusterNum {
		outChunk.Column(o.outOrdinal).AppendManyNil(o.clusterNum - clusterNum)
	}
}

func (o *IntegerOGSketchInsertItem) IsNil() bool {
	return o.sketch.Len() == 0
}

func (o *IntegerOGSketchInsertItem) Reset() {
	o.sketch.Reset()
}

type IntegerOGSketchPercentileItem struct {
	isSingleCall bool
	inOrdinal    int
	outOrdinal   int
	clusterNum   int
	percentile   float64
	sketch       OGSketch
}

func NewIntegerOGSketchPercentileItem(isSingleCall bool, inOrdinal, outOrdinal, clusterNum int, percentile float64) *IntegerOGSketchPercentileItem {
	return &IntegerOGSketchPercentileItem{
		isSingleCall: isSingleCall,
		inOrdinal:    inOrdinal,
		outOrdinal:   outOrdinal,
		clusterNum:   clusterNum,
		percentile:   percentile,
		sketch:       NewOGSketchImpl(float64(clusterNum)),
	}
}

func (o *IntegerOGSketchPercentileItem) UpdateCluster(inChunk Chunk, start, end int) {
	tuples := inChunk.Column(o.inOrdinal).FloatTuples()[start:end]
	o.sketch.InsertClusters(tuples...)

}

func (o *IntegerOGSketchPercentileItem) WriteResult(outChunk Chunk, time int64) {
	value := o.sketch.Percentile(o.percentile)
	if o.isSingleCall {
		outChunk.AppendTime(time)
		outChunk.AppendIntervalIndex(outChunk.Len() - 1)
	}
	outChunk.Column(o.outOrdinal).AppendIntegerValues(int64(value))
	outChunk.Column(o.outOrdinal).AppendNilsV2(true)
}

func (o *IntegerOGSketchPercentileItem) IsNil() bool {
	return o.sketch.Len() == 0
}

func (o *IntegerOGSketchPercentileItem) Reset() {
	o.sketch.Reset()
}

type IntegerPercentileApproxItem struct {
	isSingleCall bool
	inOrdinal    int
	outOrdinal   int
	clusterNum   int
	percentile   float64
	sketch       OGSketch
}

func NewIntegerPercentileApproxItem(isSingleCall bool, inOrdinal, outOrdinal, clusterNum int, percentile float64) *IntegerPercentileApproxItem {
	return &IntegerPercentileApproxItem{
		isSingleCall: isSingleCall,
		inOrdinal:    inOrdinal,
		outOrdinal:   outOrdinal,
		clusterNum:   clusterNum,
		percentile:   percentile,
		sketch:       NewOGSketchImpl(float64(clusterNum)),
	}
}

func (o *IntegerPercentileApproxItem) UpdateCluster(inChunk Chunk, start, end int) {
	values := inChunk.Column(o.inOrdinal).IntegerValues()[start:end]
	for i := range values {
		o.sketch.InsertPoints(float64(values[i]))
	}
}

func (o *IntegerPercentileApproxItem) WriteResult(outChunk Chunk, time int64) {
	value := o.sketch.Percentile(o.percentile)
	if o.isSingleCall {
		outChunk.AppendTime(time)
		outChunk.AppendIntervalIndex(outChunk.Len() - 1)
	}
	outChunk.Column(o.outOrdinal).AppendIntegerValues(int64(value))
	outChunk.Column(o.outOrdinal).AppendNilsV2(true)
}

func (o *IntegerPercentileApproxItem) IsNil() bool {
	return o.sketch.Len() == 0
}

func (o *IntegerPercentileApproxItem) Reset() {
	o.sketch.Reset()
}

type OGSketchMergeItem struct {
	isSingleCall bool
	inOrdinal    int
	outOrdinal   int
	clusterNum   int
	percentile   float64
	sketch       OGSketch
	clusters     ClusterSet
}

func NewOGSketchMergeItem(isSingleCall bool, inOrdinal, outOrdinal, clusterNum int, percentile float64) *OGSketchMergeItem {
	return &OGSketchMergeItem{
		isSingleCall: isSingleCall,
		inOrdinal:    inOrdinal,
		outOrdinal:   outOrdinal,
		clusterNum:   clusterNum,
		percentile:   percentile,
		sketch:       NewOGSketchImpl(float64(clusterNum)),
	}
}

func (o *OGSketchMergeItem) UpdateCluster(inChunk Chunk, start, end int) {
	tuples := inChunk.Column(o.inOrdinal).FloatTuples()[start:end]
	o.sketch.InsertClusters(tuples...)
}

func (o *OGSketchMergeItem) WriteResult(outChunk Chunk, time int64) {
	o.clusters = o.sketch.Clusters()
	clusterNum := len(o.clusters)
	if o.isSingleCall {
		for i := 0; i < clusterNum; i++ {
			outChunk.AppendTime(time)
		}
		outChunk.AppendIntervalIndex(outChunk.Len() - clusterNum)
	}

	for i := 0; i < clusterNum; i++ {
		outChunk.Column(o.outOrdinal).AppendFloatTuples(floatTuple{values: []float64{o.clusters[i].Mean, o.clusters[i].Weight}})
	}
	outChunk.Column(o.outOrdinal).AppendManyNotNil(clusterNum)

	if !o.isSingleCall && o.clusterNum > clusterNum {
		outChunk.Column(o.outOrdinal).AppendManyNil(o.clusterNum - clusterNum)
	}
}

func (o *OGSketchMergeItem) IsNil() bool {
	return o.sketch.Len() == 0
}

func (o *OGSketchMergeItem) Reset() {
	o.sketch.Reset()
}

type OGSketchIterator struct {
	isSingleCall bool
	inOrdinal    int
	outOrdinal   int
	clusterNum   int
	opt          *query.ProcessorOptions
	sketch       OGSketchItem
}

func NewOGSketchIterator(
	isSingleCall bool, inOrdinal, outOrdinal int, clusterNum int, opt *query.ProcessorOptions, sketch OGSketchItem,
) *OGSketchIterator {
	r := &OGSketchIterator{
		isSingleCall: isSingleCall,
		inOrdinal:    inOrdinal,
		outOrdinal:   outOrdinal,
		clusterNum:   clusterNum,
		opt:          opt,
		sketch:       sketch,
	}
	return r
}

func (r *OGSketchIterator) processFirstWindow(
	inChunk, outChunk Chunk, sameInterval, haveMultiInterval bool, start, end int, time int64,
) {
	r.sketch.UpdateCluster(inChunk, start, end)
	if haveMultiInterval || !sameInterval {
		r.sketch.WriteResult(outChunk, time)
		r.sketch.Reset()
	}
}

func (r *OGSketchIterator) processLastWindow(
	inChunk Chunk, start, end int,
) {
	r.sketch.UpdateCluster(inChunk, start, end)
}

func (r *OGSketchIterator) processMiddleWindow(
	inChunk, outChunk Chunk, start, end int, time int64,
) {
	r.sketch.UpdateCluster(inChunk, start, end)
	r.sketch.WriteResult(outChunk, time)
	r.sketch.Reset()
}

func (r *OGSketchIterator) Next(ie *IteratorEndpoint, p *IteratorParams) {
	var end int
	inChunk, outChunk := ie.InputPoint.Chunk, ie.OutputPoint.Chunk
	firstIndex, lastIndex := 0, len(inChunk.IntervalIndex())-1
	for i, start := range inChunk.IntervalIndex() {
		if i < lastIndex {
			end = inChunk.IntervalIndex()[i+1]
		} else {
			end = inChunk.NumberOfRows()
		}
		var time int64
		if r.opt.Interval.IsZero() {
			time = hybridqp.MaxInt64(r.opt.StartTime, 0)
		} else {
			time, _ = r.opt.Window(inChunk.TimeByIndex(start))
		}
		start, end = inChunk.Column(r.inOrdinal).GetRangeValueIndexV2(start, end)
		if !r.isSingleCall {
			if start == end && r.sketch.IsNil() && (i < lastIndex || (i == lastIndex && !p.sameInterval)) {
				outChunk.Column(r.outOrdinal).AppendManyNil(r.clusterNum)
				continue
			}
		}
		if i == firstIndex && !r.sketch.IsNil() {
			r.processFirstWindow(inChunk, outChunk, p.sameInterval, firstIndex != lastIndex, start, end, time)
		} else if i == lastIndex && p.sameInterval {
			r.processLastWindow(inChunk, start, end)
		} else {
			r.processMiddleWindow(inChunk, outChunk, start, end, time)
		}
	}
}
