// Code generated by tmpl; DO NOT EDIT.
// https://github.com/benbjohnson/tmpl
//
// Source: eval_generator.gen.go.tmpl

/*
Copyright 2022 Huawei Cloud Computing Technologies Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package binaryfilterfunc

import (
	"bytes"

	"github.com/openGemini/openGemini/lib/bitmap"
	"github.com/openGemini/openGemini/lib/record"
	"github.com/openGemini/openGemini/lib/util"
)

func GetFloatLTConditionBitMap(col *record.ColVal, compare interface{}, bitMap, pos []byte, offset int) []byte {
	if col.NilCount == 0 {
		return GetFloatLTConditionBitMapWithoutNull(col, compare, bitMap, pos, offset)
	}
	return GetFloatLTConditionBitMapWithNull(col, compare, bitMap, pos, offset)
}

func GetIntegerLTConditionBitMap(col *record.ColVal, compare interface{}, bitMap, pos []byte, offset int) []byte {
	if col.NilCount == 0 {
		return GetIntegerLTConditionBitMapWithoutNull(col, compare, bitMap, pos, offset)
	}
	return GetIntegerLTConditionBitMapWithNull(col, compare, bitMap, pos, offset)
}

func GetStringLTConditionBitMap(col *record.ColVal, compare interface{}, bitMap, pos []byte, offset int) []byte {
	if col.NilCount == 0 {
		return GetStringLTConditionBitMapWithoutNull(col, compare, bitMap, pos, offset)
	}
	return GetStringLTConditionBitMapWithNull(col, compare, bitMap, pos, offset)
}

func GetFloatLTConditionBitMapWithoutNull(col *record.ColVal, compare interface{}, bitMap, pos []byte, offset int) []byte {
	var idx int
	values := col.FloatValues()
	cmpData, _ := compare.(float64)
	for i := 0; i < col.Len; i++ {
		idx = offset + i
		if bitmap.IsNil(pos, idx) {
			continue
		}
		if values[idx] >= cmpData {
			bitmap.SetBitMap(pos, idx)
		}
	}
	return pos
}

func GetIntegerLTConditionBitMapWithoutNull(col *record.ColVal, compare interface{}, bitMap, pos []byte, offset int) []byte {
	var idx int
	values := col.IntegerValues()
	cmpData, _ := compare.(int64)
	for i := 0; i < col.Len; i++ {
		idx = offset + i
		if bitmap.IsNil(pos, idx) {
			continue
		}
		if values[idx] >= cmpData {
			bitmap.SetBitMap(pos, idx)
		}
	}
	return pos
}

func GetStringLTConditionBitMapWithoutNull(col *record.ColVal, compare interface{}, bitMap, pos []byte, offset int) []byte {
	var idx int
	cmpData := util.Str2bytes(compare.(string))
	for i := 0; i < col.Len-1; i++ {
		idx = offset + i
		if bitmap.IsNil(pos, idx) {
			continue
		}
		if bytes.Compare(col.Val[col.Offset[i]:col.Offset[i+1]], cmpData) >= 0 {
			bitmap.SetBitMap(pos, idx)
		}
	}
	idx = offset + col.Len - 1
	if bitmap.IsNil(pos, idx) {
		return pos
	}
	if bytes.Compare(col.Val[col.Offset[col.Len-1]:], cmpData) >= 0 {
		bitmap.SetBitMap(pos, idx)
	}
	return pos
}

func GetFloatLTConditionBitMapWithNull(col *record.ColVal, compare interface{}, bitMap, pos []byte, offset int) []byte {
	values := col.FloatValues()
	var idx int
	var index int
	cmpData, _ := compare.(float64)
	for i := 0; i < col.Len; i++ {
		idx = offset + i
		if bitmap.IsNil(pos, idx) {
			if !bitmap.IsNil(bitMap, idx) {
				index++
			}
			continue
		}

		if bitmap.IsNil(bitMap, idx) {
			bitmap.SetBitMap(pos, idx)
			continue
		}
		if values[index] >= cmpData {
			bitmap.SetBitMap(pos, idx)
		}
		index++
	}
	return pos
}

func GetIntegerLTConditionBitMapWithNull(col *record.ColVal, compare interface{}, bitMap, pos []byte, offset int) []byte {
	values := col.IntegerValues()
	var idx int
	var index int
	cmpData, _ := compare.(int64)
	for i := 0; i < col.Len; i++ {
		idx = offset + i
		if bitmap.IsNil(pos, idx) {
			if !bitmap.IsNil(bitMap, idx) {
				index++
			}
			continue
		}

		if bitmap.IsNil(bitMap, idx) {
			bitmap.SetBitMap(pos, idx)
			continue
		}
		if values[index] >= cmpData {
			bitmap.SetBitMap(pos, idx)
		}
		index++
	}
	return pos
}

func GetStringLTConditionBitMapWithNull(col *record.ColVal, compare interface{}, bitMap, pos []byte, offset int) []byte {
	var idx int
	cmpData := util.Str2bytes(compare.(string))
	for i := 0; i < col.Len-1; i++ {
		idx = offset + i
		if bitmap.IsNil(pos, idx) {
			continue
		}

		if bitmap.IsNil(bitMap, idx) {
			bitmap.SetBitMap(pos, idx)
			continue
		}
		if bytes.Compare(col.Val[col.Offset[i]:col.Offset[i+1]], cmpData) >= 0 {
			bitmap.SetBitMap(pos, idx)
		}
	}
	idx = offset + col.Len - 1
	if bitmap.IsNil(pos, idx) {
		return pos
	}
	if bitmap.IsNil(bitMap, idx) || bytes.Compare(col.Val[col.Offset[col.Len-1]:], cmpData) >= 0 {
		bitmap.SetBitMap(pos, idx)
	}
	return pos
}

func GetFloatLTEConditionBitMap(col *record.ColVal, compare interface{}, bitMap, pos []byte, offset int) []byte {
	if col.NilCount == 0 {
		return GetFloatLTEConditionBitMapWithoutNull(col, compare, bitMap, pos, offset)
	}
	return GetFloatLTEConditionBitMapWithNull(col, compare, bitMap, pos, offset)
}

func GetIntegerLTEConditionBitMap(col *record.ColVal, compare interface{}, bitMap, pos []byte, offset int) []byte {
	if col.NilCount == 0 {
		return GetIntegerLTEConditionBitMapWithoutNull(col, compare, bitMap, pos, offset)
	}
	return GetIntegerLTEConditionBitMapWithNull(col, compare, bitMap, pos, offset)
}

func GetStringLTEConditionBitMap(col *record.ColVal, compare interface{}, bitMap, pos []byte, offset int) []byte {
	if col.NilCount == 0 {
		return GetStringLTEConditionBitMapWithoutNull(col, compare, bitMap, pos, offset)
	}
	return GetStringLTEConditionBitMapWithNull(col, compare, bitMap, pos, offset)
}

func GetFloatLTEConditionBitMapWithoutNull(col *record.ColVal, compare interface{}, bitMap, pos []byte, offset int) []byte {
	var idx int
	values := col.FloatValues()
	cmpData, _ := compare.(float64)
	for i := 0; i < col.Len; i++ {
		idx = offset + i
		if bitmap.IsNil(pos, idx) {
			continue
		}
		if values[idx] > cmpData {
			bitmap.SetBitMap(pos, idx)
		}
	}
	return pos
}

func GetIntegerLTEConditionBitMapWithoutNull(col *record.ColVal, compare interface{}, bitMap, pos []byte, offset int) []byte {
	var idx int
	values := col.IntegerValues()
	cmpData, _ := compare.(int64)
	for i := 0; i < col.Len; i++ {
		idx = offset + i
		if bitmap.IsNil(pos, idx) {
			continue
		}
		if values[idx] > cmpData {
			bitmap.SetBitMap(pos, idx)
		}
	}
	return pos
}

func GetStringLTEConditionBitMapWithoutNull(col *record.ColVal, compare interface{}, bitMap, pos []byte, offset int) []byte {
	var idx int
	cmpData := util.Str2bytes(compare.(string))
	for i := 0; i < col.Len-1; i++ {
		idx = offset + i
		if bitmap.IsNil(pos, idx) {
			continue
		}
		if bytes.Compare(col.Val[col.Offset[i]:col.Offset[i+1]], cmpData) > 0 {
			bitmap.SetBitMap(pos, idx)
		}
	}
	idx = offset + col.Len - 1
	if bitmap.IsNil(pos, idx) {
		return pos
	}
	if bytes.Compare(col.Val[col.Offset[col.Len-1]:], cmpData) > 0 {
		bitmap.SetBitMap(pos, idx)
	}
	return pos
}

func GetFloatLTEConditionBitMapWithNull(col *record.ColVal, compare interface{}, bitMap, pos []byte, offset int) []byte {
	values := col.FloatValues()
	var idx int
	var index int
	cmpData, _ := compare.(float64)
	for i := 0; i < col.Len; i++ {
		idx = offset + i
		if bitmap.IsNil(pos, idx) {
			if !bitmap.IsNil(bitMap, idx) {
				index++
			}
			continue
		}

		if bitmap.IsNil(bitMap, idx) {
			bitmap.SetBitMap(pos, idx)
			continue
		}
		if values[index] > cmpData {
			bitmap.SetBitMap(pos, idx)
		}
		index++
	}
	return pos
}

func GetIntegerLTEConditionBitMapWithNull(col *record.ColVal, compare interface{}, bitMap, pos []byte, offset int) []byte {
	values := col.IntegerValues()
	var idx int
	var index int
	cmpData, _ := compare.(int64)
	for i := 0; i < col.Len; i++ {
		idx = offset + i
		if bitmap.IsNil(pos, idx) {
			if !bitmap.IsNil(bitMap, idx) {
				index++
			}
			continue
		}

		if bitmap.IsNil(bitMap, idx) {
			bitmap.SetBitMap(pos, idx)
			continue
		}
		if values[index] > cmpData {
			bitmap.SetBitMap(pos, idx)
		}
		index++
	}
	return pos
}

func GetStringLTEConditionBitMapWithNull(col *record.ColVal, compare interface{}, bitMap, pos []byte, offset int) []byte {
	var idx int
	cmpData := util.Str2bytes(compare.(string))
	for i := 0; i < col.Len-1; i++ {
		idx = offset + i
		if bitmap.IsNil(pos, idx) {
			continue
		}

		if bitmap.IsNil(bitMap, idx) {
			bitmap.SetBitMap(pos, idx)
			continue
		}
		if bytes.Compare(col.Val[col.Offset[i]:col.Offset[i+1]], cmpData) > 0 {
			bitmap.SetBitMap(pos, idx)
		}
	}
	idx = offset + col.Len - 1
	if bitmap.IsNil(pos, idx) {
		return pos
	}
	if bitmap.IsNil(bitMap, idx) || bytes.Compare(col.Val[col.Offset[col.Len-1]:], cmpData) > 0 {
		bitmap.SetBitMap(pos, idx)
	}
	return pos
}

func GetFloatGTConditionBitMap(col *record.ColVal, compare interface{}, bitMap, pos []byte, offset int) []byte {
	if col.NilCount == 0 {
		return GetFloatGTConditionBitMapWithoutNull(col, compare, bitMap, pos, offset)
	}
	return GetFloatGTConditionBitMapWithNull(col, compare, bitMap, pos, offset)
}

func GetIntegerGTConditionBitMap(col *record.ColVal, compare interface{}, bitMap, pos []byte, offset int) []byte {
	if col.NilCount == 0 {
		return GetIntegerGTConditionBitMapWithoutNull(col, compare, bitMap, pos, offset)
	}
	return GetIntegerGTConditionBitMapWithNull(col, compare, bitMap, pos, offset)
}

func GetStringGTConditionBitMap(col *record.ColVal, compare interface{}, bitMap, pos []byte, offset int) []byte {
	if col.NilCount == 0 {
		return GetStringGTConditionBitMapWithoutNull(col, compare, bitMap, pos, offset)
	}
	return GetStringGTConditionBitMapWithNull(col, compare, bitMap, pos, offset)
}

func GetFloatGTConditionBitMapWithoutNull(col *record.ColVal, compare interface{}, bitMap, pos []byte, offset int) []byte {
	var idx int
	values := col.FloatValues()
	cmpData, _ := compare.(float64)
	for i := 0; i < col.Len; i++ {
		idx = offset + i
		if bitmap.IsNil(pos, idx) {
			continue
		}
		if values[idx] <= cmpData {
			bitmap.SetBitMap(pos, idx)
		}
	}
	return pos
}

func GetIntegerGTConditionBitMapWithoutNull(col *record.ColVal, compare interface{}, bitMap, pos []byte, offset int) []byte {
	var idx int
	values := col.IntegerValues()
	cmpData, _ := compare.(int64)
	for i := 0; i < col.Len; i++ {
		idx = offset + i
		if bitmap.IsNil(pos, idx) {
			continue
		}
		if values[idx] <= cmpData {
			bitmap.SetBitMap(pos, idx)
		}
	}
	return pos
}

func GetStringGTConditionBitMapWithoutNull(col *record.ColVal, compare interface{}, bitMap, pos []byte, offset int) []byte {
	var idx int
	cmpData := util.Str2bytes(compare.(string))
	for i := 0; i < col.Len-1; i++ {
		idx = offset + i
		if bitmap.IsNil(pos, idx) {
			continue
		}
		if bytes.Compare(col.Val[col.Offset[i]:col.Offset[i+1]], cmpData) <= 0 {
			bitmap.SetBitMap(pos, idx)
		}
	}
	idx = offset + col.Len - 1
	if bitmap.IsNil(pos, idx) {
		return pos
	}
	if bytes.Compare(col.Val[col.Offset[col.Len-1]:], cmpData) <= 0 {
		bitmap.SetBitMap(pos, idx)
	}
	return pos
}

func GetFloatGTConditionBitMapWithNull(col *record.ColVal, compare interface{}, bitMap, pos []byte, offset int) []byte {
	values := col.FloatValues()
	var idx int
	var index int
	cmpData, _ := compare.(float64)
	for i := 0; i < col.Len; i++ {
		idx = offset + i
		if bitmap.IsNil(pos, idx) {
			if !bitmap.IsNil(bitMap, idx) {
				index++
			}
			continue
		}

		if bitmap.IsNil(bitMap, idx) {
			bitmap.SetBitMap(pos, idx)
			continue
		}
		if values[index] <= cmpData {
			bitmap.SetBitMap(pos, idx)
		}
		index++
	}
	return pos
}

func GetIntegerGTConditionBitMapWithNull(col *record.ColVal, compare interface{}, bitMap, pos []byte, offset int) []byte {
	values := col.IntegerValues()
	var idx int
	var index int
	cmpData, _ := compare.(int64)
	for i := 0; i < col.Len; i++ {
		idx = offset + i
		if bitmap.IsNil(pos, idx) {
			if !bitmap.IsNil(bitMap, idx) {
				index++
			}
			continue
		}

		if bitmap.IsNil(bitMap, idx) {
			bitmap.SetBitMap(pos, idx)
			continue
		}
		if values[index] <= cmpData {
			bitmap.SetBitMap(pos, idx)
		}
		index++
	}
	return pos
}

func GetStringGTConditionBitMapWithNull(col *record.ColVal, compare interface{}, bitMap, pos []byte, offset int) []byte {
	var idx int
	cmpData := util.Str2bytes(compare.(string))
	for i := 0; i < col.Len-1; i++ {
		idx = offset + i
		if bitmap.IsNil(pos, idx) {
			continue
		}

		if bitmap.IsNil(bitMap, idx) {
			bitmap.SetBitMap(pos, idx)
			continue
		}
		if bytes.Compare(col.Val[col.Offset[i]:col.Offset[i+1]], cmpData) <= 0 {
			bitmap.SetBitMap(pos, idx)
		}
	}
	idx = offset + col.Len - 1
	if bitmap.IsNil(pos, idx) {
		return pos
	}
	if bitmap.IsNil(bitMap, idx) || bytes.Compare(col.Val[col.Offset[col.Len-1]:], cmpData) <= 0 {
		bitmap.SetBitMap(pos, idx)
	}
	return pos
}

func GetFloatGTEConditionBitMap(col *record.ColVal, compare interface{}, bitMap, pos []byte, offset int) []byte {
	if col.NilCount == 0 {
		return GetFloatGTEConditionBitMapWithoutNull(col, compare, bitMap, pos, offset)
	}
	return GetFloatGTEConditionBitMapWithNull(col, compare, bitMap, pos, offset)
}

func GetIntegerGTEConditionBitMap(col *record.ColVal, compare interface{}, bitMap, pos []byte, offset int) []byte {
	if col.NilCount == 0 {
		return GetIntegerGTEConditionBitMapWithoutNull(col, compare, bitMap, pos, offset)
	}
	return GetIntegerGTEConditionBitMapWithNull(col, compare, bitMap, pos, offset)
}

func GetStringGTEConditionBitMap(col *record.ColVal, compare interface{}, bitMap, pos []byte, offset int) []byte {
	if col.NilCount == 0 {
		return GetStringGTEConditionBitMapWithoutNull(col, compare, bitMap, pos, offset)
	}
	return GetStringGTEConditionBitMapWithNull(col, compare, bitMap, pos, offset)
}

func GetFloatGTEConditionBitMapWithoutNull(col *record.ColVal, compare interface{}, bitMap, pos []byte, offset int) []byte {
	var idx int
	values := col.FloatValues()
	cmpData, _ := compare.(float64)
	for i := 0; i < col.Len; i++ {
		idx = offset + i
		if bitmap.IsNil(pos, idx) {
			continue
		}
		if values[idx] < cmpData {
			bitmap.SetBitMap(pos, idx)
		}
	}
	return pos
}

func GetIntegerGTEConditionBitMapWithoutNull(col *record.ColVal, compare interface{}, bitMap, pos []byte, offset int) []byte {
	var idx int
	values := col.IntegerValues()
	cmpData, _ := compare.(int64)
	for i := 0; i < col.Len; i++ {
		idx = offset + i
		if bitmap.IsNil(pos, idx) {
			continue
		}
		if values[idx] < cmpData {
			bitmap.SetBitMap(pos, idx)
		}
	}
	return pos
}

func GetStringGTEConditionBitMapWithoutNull(col *record.ColVal, compare interface{}, bitMap, pos []byte, offset int) []byte {
	var idx int
	cmpData := util.Str2bytes(compare.(string))
	for i := 0; i < col.Len-1; i++ {
		idx = offset + i
		if bitmap.IsNil(pos, idx) {
			continue
		}
		if bytes.Compare(col.Val[col.Offset[i]:col.Offset[i+1]], cmpData) < 0 {
			bitmap.SetBitMap(pos, idx)
		}
	}
	idx = offset + col.Len - 1
	if bitmap.IsNil(pos, idx) {
		return pos
	}
	if bytes.Compare(col.Val[col.Offset[col.Len-1]:], cmpData) < 0 {
		bitmap.SetBitMap(pos, idx)
	}
	return pos
}

func GetFloatGTEConditionBitMapWithNull(col *record.ColVal, compare interface{}, bitMap, pos []byte, offset int) []byte {
	values := col.FloatValues()
	var idx int
	var index int
	cmpData, _ := compare.(float64)
	for i := 0; i < col.Len; i++ {
		idx = offset + i
		if bitmap.IsNil(pos, idx) {
			if !bitmap.IsNil(bitMap, idx) {
				index++
			}
			continue
		}

		if bitmap.IsNil(bitMap, idx) {
			bitmap.SetBitMap(pos, idx)
			continue
		}
		if values[index] < cmpData {
			bitmap.SetBitMap(pos, idx)
		}
		index++
	}
	return pos
}

func GetIntegerGTEConditionBitMapWithNull(col *record.ColVal, compare interface{}, bitMap, pos []byte, offset int) []byte {
	values := col.IntegerValues()
	var idx int
	var index int
	cmpData, _ := compare.(int64)
	for i := 0; i < col.Len; i++ {
		idx = offset + i
		if bitmap.IsNil(pos, idx) {
			if !bitmap.IsNil(bitMap, idx) {
				index++
			}
			continue
		}

		if bitmap.IsNil(bitMap, idx) {
			bitmap.SetBitMap(pos, idx)
			continue
		}
		if values[index] < cmpData {
			bitmap.SetBitMap(pos, idx)
		}
		index++
	}
	return pos
}

func GetStringGTEConditionBitMapWithNull(col *record.ColVal, compare interface{}, bitMap, pos []byte, offset int) []byte {
	var idx int
	cmpData := util.Str2bytes(compare.(string))
	for i := 0; i < col.Len-1; i++ {
		idx = offset + i
		if bitmap.IsNil(pos, idx) {
			continue
		}

		if bitmap.IsNil(bitMap, idx) {
			bitmap.SetBitMap(pos, idx)
			continue
		}
		if bytes.Compare(col.Val[col.Offset[i]:col.Offset[i+1]], cmpData) < 0 {
			bitmap.SetBitMap(pos, idx)
		}
	}
	idx = offset + col.Len - 1
	if bitmap.IsNil(pos, idx) {
		return pos
	}
	if bitmap.IsNil(bitMap, idx) || bytes.Compare(col.Val[col.Offset[col.Len-1]:], cmpData) < 0 {
		bitmap.SetBitMap(pos, idx)
	}
	return pos
}

func GetFloatEQConditionBitMap(col *record.ColVal, compare interface{}, bitMap, pos []byte, offset int) []byte {
	if col.NilCount == 0 {
		return GetFloatEQConditionBitMapWithoutNull(col, compare, bitMap, pos, offset)
	}
	return GetFloatEQConditionBitMapWithNull(col, compare, bitMap, pos, offset)
}

func GetIntegerEQConditionBitMap(col *record.ColVal, compare interface{}, bitMap, pos []byte, offset int) []byte {
	if col.NilCount == 0 {
		return GetIntegerEQConditionBitMapWithoutNull(col, compare, bitMap, pos, offset)
	}
	return GetIntegerEQConditionBitMapWithNull(col, compare, bitMap, pos, offset)
}

func GetStringEQConditionBitMap(col *record.ColVal, compare interface{}, bitMap, pos []byte, offset int) []byte {
	if col.NilCount == 0 {
		return GetStringEQConditionBitMapWithoutNull(col, compare, bitMap, pos, offset)
	}
	return GetStringEQConditionBitMapWithNull(col, compare, bitMap, pos, offset)
}

func GetBooleanEQConditionBitMap(col *record.ColVal, compare interface{}, bitMap, pos []byte, offset int) []byte {
	if col.NilCount == 0 {
		return GetBooleanEQConditionBitMapWithoutNull(col, compare, bitMap, pos, offset)
	}
	return GetBooleanEQConditionBitMapWithNull(col, compare, bitMap, pos, offset)
}

func GetFloatEQConditionBitMapWithoutNull(col *record.ColVal, compare interface{}, bitMap, pos []byte, offset int) []byte {
	var idx int
	values := col.FloatValues()
	cmpData, _ := compare.(float64)
	for i := 0; i < col.Len; i++ {
		idx = offset + i
		if bitmap.IsNil(pos, idx) {
			continue
		}
		if values[idx] != cmpData {
			bitmap.SetBitMap(pos, idx)
		}
	}
	return pos
}

func GetIntegerEQConditionBitMapWithoutNull(col *record.ColVal, compare interface{}, bitMap, pos []byte, offset int) []byte {
	var idx int
	values := col.IntegerValues()
	cmpData, _ := compare.(int64)
	for i := 0; i < col.Len; i++ {
		idx = offset + i
		if bitmap.IsNil(pos, idx) {
			continue
		}
		if values[idx] != cmpData {
			bitmap.SetBitMap(pos, idx)
		}
	}
	return pos
}

func GetStringEQConditionBitMapWithoutNull(col *record.ColVal, compare interface{}, bitMap, pos []byte, offset int) []byte {
	var idx int
	cmpData := util.Str2bytes(compare.(string))
	for i := 0; i < col.Len-1; i++ {
		idx = offset + i
		if bitmap.IsNil(pos, idx) {
			continue
		}
		if !bytes.Equal(col.Val[col.Offset[i]:col.Offset[i+1]], cmpData) {
			bitmap.SetBitMap(pos, idx)
		}
	}
	idx = offset + col.Len - 1
	if bitmap.IsNil(pos, idx) {
		return pos
	}
	if !bytes.Equal(col.Val[col.Offset[col.Len-1]:], cmpData) {
		bitmap.SetBitMap(pos, idx)
	}
	return pos
}

func GetBooleanEQConditionBitMapWithoutNull(col *record.ColVal, compare interface{}, bitMap, pos []byte, offset int) []byte {
	var idx int
	values := col.BooleanValues()
	cmpData, _ := compare.(bool)
	for i := 0; i < col.Len; i++ {
		idx = offset + i
		if bitmap.IsNil(pos, idx) {
			continue
		}
		if values[idx] != cmpData {
			bitmap.SetBitMap(pos, idx)
		}
	}
	return pos
}

func GetFloatEQConditionBitMapWithNull(col *record.ColVal, compare interface{}, bitMap, pos []byte, offset int) []byte {
	values := col.FloatValues()
	var idx int
	var index int
	cmpData, _ := compare.(float64)
	for i := 0; i < col.Len; i++ {
		idx = offset + i
		if bitmap.IsNil(pos, idx) {
			if !bitmap.IsNil(bitMap, idx) {
				index++
			}
			continue
		}

		if bitmap.IsNil(bitMap, idx) {
			bitmap.SetBitMap(pos, idx)
			continue
		}
		if values[index] != cmpData {
			bitmap.SetBitMap(pos, idx)
		}
		index++
	}
	return pos
}

func GetIntegerEQConditionBitMapWithNull(col *record.ColVal, compare interface{}, bitMap, pos []byte, offset int) []byte {
	values := col.IntegerValues()
	var idx int
	var index int
	cmpData, _ := compare.(int64)
	for i := 0; i < col.Len; i++ {
		idx = offset + i
		if bitmap.IsNil(pos, idx) {
			if !bitmap.IsNil(bitMap, idx) {
				index++
			}
			continue
		}

		if bitmap.IsNil(bitMap, idx) {
			bitmap.SetBitMap(pos, idx)
			continue
		}
		if values[index] != cmpData {
			bitmap.SetBitMap(pos, idx)
		}
		index++
	}
	return pos
}

func GetStringEQConditionBitMapWithNull(col *record.ColVal, compare interface{}, bitMap, pos []byte, offset int) []byte {
	var idx int
	cmpData := util.Str2bytes(compare.(string))
	for i := 0; i < col.Len-1; i++ {
		idx = offset + i
		if bitmap.IsNil(pos, idx) {
			continue
		}

		if bitmap.IsNil(bitMap, idx) {
			bitmap.SetBitMap(pos, idx)
			continue
		}
		if !bytes.Equal(col.Val[col.Offset[i]:col.Offset[i+1]], cmpData) {
			bitmap.SetBitMap(pos, idx)
		}
	}
	idx = offset + col.Len - 1
	if bitmap.IsNil(pos, idx) {
		return pos
	}
	if bitmap.IsNil(bitMap, idx) || !bytes.Equal(col.Val[col.Offset[col.Len-1]:], cmpData) {
		bitmap.SetBitMap(pos, idx)
	}
	return pos
}

func GetBooleanEQConditionBitMapWithNull(col *record.ColVal, compare interface{}, bitMap, pos []byte, offset int) []byte {
	values := col.BooleanValues()
	var idx int
	var index int
	cmpData, _ := compare.(bool)
	for i := 0; i < col.Len; i++ {
		idx = offset + i
		if bitmap.IsNil(pos, idx) {
			if !bitmap.IsNil(bitMap, idx) {
				index++
			}
			continue
		}

		if bitmap.IsNil(bitMap, idx) {
			bitmap.SetBitMap(pos, idx)
			continue
		}
		if values[index] != cmpData {
			bitmap.SetBitMap(pos, idx)
		}
		index++
	}
	return pos
}

func GetFloatNEQConditionBitMap(col *record.ColVal, compare interface{}, bitMap, pos []byte, offset int) []byte {
	if col.NilCount == 0 {
		return GetFloatNEQConditionBitMapWithoutNull(col, compare, bitMap, pos, offset)
	}
	return GetFloatNEQConditionBitMapWithNull(col, compare, bitMap, pos, offset)
}

func GetIntegerNEQConditionBitMap(col *record.ColVal, compare interface{}, bitMap, pos []byte, offset int) []byte {
	if col.NilCount == 0 {
		return GetIntegerNEQConditionBitMapWithoutNull(col, compare, bitMap, pos, offset)
	}
	return GetIntegerNEQConditionBitMapWithNull(col, compare, bitMap, pos, offset)
}

func GetStringNEQConditionBitMap(col *record.ColVal, compare interface{}, bitMap, pos []byte, offset int) []byte {
	if col.NilCount == 0 {
		return GetStringNEQConditionBitMapWithoutNull(col, compare, bitMap, pos, offset)
	}
	return GetStringNEQConditionBitMapWithNull(col, compare, bitMap, pos, offset)
}

func GetBooleanNEQConditionBitMap(col *record.ColVal, compare interface{}, bitMap, pos []byte, offset int) []byte {
	if col.NilCount == 0 {
		return GetBooleanNEQConditionBitMapWithoutNull(col, compare, bitMap, pos, offset)
	}
	return GetBooleanNEQConditionBitMapWithNull(col, compare, bitMap, pos, offset)
}

func GetFloatNEQConditionBitMapWithoutNull(col *record.ColVal, compare interface{}, bitMap, pos []byte, offset int) []byte {
	var idx int
	values := col.FloatValues()
	cmpData, _ := compare.(float64)
	for i := 0; i < col.Len; i++ {
		idx = offset + i
		if bitmap.IsNil(pos, idx) {
			continue
		}
		if values[idx] == cmpData {
			bitmap.SetBitMap(pos, idx)
		}
	}
	return pos
}

func GetIntegerNEQConditionBitMapWithoutNull(col *record.ColVal, compare interface{}, bitMap, pos []byte, offset int) []byte {
	var idx int
	values := col.IntegerValues()
	cmpData, _ := compare.(int64)
	for i := 0; i < col.Len; i++ {
		idx = offset + i
		if bitmap.IsNil(pos, idx) {
			continue
		}
		if values[idx] == cmpData {
			bitmap.SetBitMap(pos, idx)
		}
	}
	return pos
}

func GetStringNEQConditionBitMapWithoutNull(col *record.ColVal, compare interface{}, bitMap, pos []byte, offset int) []byte {
	var idx int
	cmpData := util.Str2bytes(compare.(string))
	for i := 0; i < col.Len-1; i++ {
		idx = offset + i
		if bitmap.IsNil(pos, idx) {
			continue
		}
		if bytes.Equal(col.Val[col.Offset[i]:col.Offset[i+1]], cmpData) {
			bitmap.SetBitMap(pos, idx)
		}
	}
	idx = offset + col.Len - 1
	if bitmap.IsNil(pos, idx) {
		return pos
	}
	if bytes.Equal(col.Val[col.Offset[col.Len-1]:], cmpData) {
		bitmap.SetBitMap(pos, idx)
	}
	return pos
}

func GetBooleanNEQConditionBitMapWithoutNull(col *record.ColVal, compare interface{}, bitMap, pos []byte, offset int) []byte {
	var idx int
	values := col.BooleanValues()
	cmpData, _ := compare.(bool)
	for i := 0; i < col.Len; i++ {
		idx = offset + i
		if bitmap.IsNil(pos, idx) {
			continue
		}
		if values[idx] == cmpData {
			bitmap.SetBitMap(pos, idx)
		}
	}
	return pos
}

func GetFloatNEQConditionBitMapWithNull(col *record.ColVal, compare interface{}, bitMap, pos []byte, offset int) []byte {
	values := col.FloatValues()
	var idx int
	var index int
	cmpData, _ := compare.(float64)
	for i := 0; i < col.Len; i++ {
		idx = offset + i
		if bitmap.IsNil(pos, idx) {
			if !bitmap.IsNil(bitMap, idx) {
				index++
			}
			continue
		}

		if bitmap.IsNil(bitMap, idx) {
			bitmap.SetBitMap(pos, idx)
			continue
		}
		if values[index] == cmpData {
			bitmap.SetBitMap(pos, idx)
		}
		index++
	}
	return pos
}

func GetIntegerNEQConditionBitMapWithNull(col *record.ColVal, compare interface{}, bitMap, pos []byte, offset int) []byte {
	values := col.IntegerValues()
	var idx int
	var index int
	cmpData, _ := compare.(int64)
	for i := 0; i < col.Len; i++ {
		idx = offset + i
		if bitmap.IsNil(pos, idx) {
			if !bitmap.IsNil(bitMap, idx) {
				index++
			}
			continue
		}

		if bitmap.IsNil(bitMap, idx) {
			bitmap.SetBitMap(pos, idx)
			continue
		}
		if values[index] == cmpData {
			bitmap.SetBitMap(pos, idx)
		}
		index++
	}
	return pos
}

func GetStringNEQConditionBitMapWithNull(col *record.ColVal, compare interface{}, bitMap, pos []byte, offset int) []byte {
	var idx int
	cmpData := util.Str2bytes(compare.(string))
	for i := 0; i < col.Len-1; i++ {
		idx = offset + i
		if bitmap.IsNil(pos, idx) {
			continue
		}

		if bitmap.IsNil(bitMap, idx) {
			bitmap.SetBitMap(pos, idx)
			continue
		}
		if bytes.Equal(col.Val[col.Offset[i]:col.Offset[i+1]], cmpData) {
			bitmap.SetBitMap(pos, idx)
		}
	}
	idx = offset + col.Len - 1
	if bitmap.IsNil(pos, idx) {
		return pos
	}
	if bitmap.IsNil(bitMap, idx) || bytes.Equal(col.Val[col.Offset[col.Len-1]:], cmpData) {
		bitmap.SetBitMap(pos, idx)
	}
	return pos
}

func GetBooleanNEQConditionBitMapWithNull(col *record.ColVal, compare interface{}, bitMap, pos []byte, offset int) []byte {
	values := col.BooleanValues()
	var idx int
	var index int
	cmpData, _ := compare.(bool)
	for i := 0; i < col.Len; i++ {
		idx = offset + i
		if bitmap.IsNil(pos, idx) {
			if !bitmap.IsNil(bitMap, idx) {
				index++
			}
			continue
		}

		if bitmap.IsNil(bitMap, idx) {
			bitmap.SetBitMap(pos, idx)
			continue
		}
		if values[index] == cmpData {
			bitmap.SetBitMap(pos, idx)
		}
		index++
	}
	return pos
}
